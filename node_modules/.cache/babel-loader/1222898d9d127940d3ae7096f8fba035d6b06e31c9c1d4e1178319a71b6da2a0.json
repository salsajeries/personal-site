{"ast":null,"code":"/*!\n * OverlayScrollbars\n * Version: 2.0.1\n *\n * Copyright (c) Rene Haas | KingSora.\n * https://github.com/KingSora\n *\n * Released under the MIT license.\n */\n\nfunction each(t, n) {\n  if (isArrayLike(t)) {\n    for (let o = 0; o < t.length; o++) {\n      if (false === n(t[o], o, t)) {\n        break;\n      }\n    }\n  } else if (t) {\n    each(Object.keys(t), o => n(t[o], o, t));\n  }\n  return t;\n}\nfunction style(t, n) {\n  const o = isString(n);\n  const s = isArray(n) || o;\n  if (s) {\n    let s = o ? \"\" : {};\n    if (t) {\n      const e = window.getComputedStyle(t, null);\n      s = o ? getCSSVal(t, e, n) : n.reduce((n, o) => {\n        n[o] = getCSSVal(t, e, o);\n        return n;\n      }, s);\n    }\n    return s;\n  }\n  t && each(keys(n), o => setCSSVal(t, o, n[o]));\n}\nconst createCache = (t, n) => {\n  const {\n    o: o,\n    u: s,\n    _: e\n  } = t;\n  let c = o;\n  let r;\n  const cacheUpdateContextual = (t, n) => {\n    const o = c;\n    const i = t;\n    const l = n || (s ? !s(o, i) : o !== i);\n    if (l || e) {\n      c = i;\n      r = o;\n    }\n    return [c, l, r];\n  };\n  const cacheUpdateIsolated = t => cacheUpdateContextual(n(c, r), t);\n  const getCurrentCache = t => [c, !!t, r];\n  return [n ? cacheUpdateIsolated : cacheUpdateContextual, getCurrentCache];\n};\nconst isClient = () => \"undefined\" !== typeof window;\nconst t = isClient() && Node.ELEMENT_NODE;\nconst {\n  toString: n,\n  hasOwnProperty: o\n} = Object.prototype;\nconst isUndefined = t => void 0 === t;\nconst isNull = t => null === t;\nconst type = t => isUndefined(t) || isNull(t) ? `${t}` : n.call(t).replace(/^\\[object (.+)\\]$/, \"$1\").toLowerCase();\nconst isNumber = t => \"number\" === typeof t;\nconst isString = t => \"string\" === typeof t;\nconst isBoolean = t => \"boolean\" === typeof t;\nconst isFunction = t => \"function\" === typeof t;\nconst isArray = t => Array.isArray(t);\nconst isObject = t => \"object\" === typeof t && !isArray(t) && !isNull(t);\nconst isArrayLike = t => {\n  const n = !!t && t.length;\n  const o = isNumber(n) && n > -1 && n % 1 == 0;\n  return isArray(t) || !isFunction(t) && o ? n > 0 && isObject(t) ? n - 1 in t : true : false;\n};\nconst isPlainObject = t => {\n  if (!t || !isObject(t) || \"object\" !== type(t)) {\n    return false;\n  }\n  let n;\n  const s = \"constructor\";\n  const e = t[s];\n  const c = e && e.prototype;\n  const r = o.call(t, s);\n  const i = c && o.call(c, \"isPrototypeOf\");\n  if (e && !r && !i) {\n    return false;\n  }\n  for (n in t) {}\n  return isUndefined(n) || o.call(t, n);\n};\nconst isHTMLElement = n => {\n  const o = HTMLElement;\n  return n ? o ? n instanceof o : n.nodeType === t : false;\n};\nconst isElement = n => {\n  const o = Element;\n  return n ? o ? n instanceof o : n.nodeType === t : false;\n};\nconst indexOf = (t, n, o) => t.indexOf(n, o);\nconst push = (t, n, o) => {\n  !o && !isString(n) && isArrayLike(n) ? Array.prototype.push.apply(t, n) : t.push(n);\n  return t;\n};\nconst from = t => {\n  const n = Array.from;\n  const o = [];\n  if (n && t) {\n    return n(t);\n  }\n  if (t instanceof Set) {\n    t.forEach(t => {\n      push(o, t);\n    });\n  } else {\n    each(t, t => {\n      push(o, t);\n    });\n  }\n  return o;\n};\nconst isEmptyArray = t => !!t && 0 === t.length;\nconst runEachAndClear = (t, n, o) => {\n  const runFn = t => t && t.apply(void 0, n || []);\n  each(t, runFn);\n  !o && (t.length = 0);\n};\nconst hasOwnProperty = (t, n) => Object.prototype.hasOwnProperty.call(t, n);\nconst keys = t => t ? Object.keys(t) : [];\nconst assignDeep = (t, n, o, s, e, c, r) => {\n  const i = [n, o, s, e, c, r];\n  if ((\"object\" !== typeof t || isNull(t)) && !isFunction(t)) {\n    t = {};\n  }\n  each(i, n => {\n    each(keys(n), o => {\n      const s = n[o];\n      if (t === s) {\n        return true;\n      }\n      const e = isArray(s);\n      if (s && (isPlainObject(s) || e)) {\n        const n = t[o];\n        let c = n;\n        if (e && !isArray(n)) {\n          c = [];\n        } else if (!e && !isPlainObject(n)) {\n          c = {};\n        }\n        t[o] = assignDeep(c, s);\n      } else {\n        t[o] = s;\n      }\n    });\n  });\n  return t;\n};\nconst isEmptyObject = t => {\n  for (const n in t) {\n    return false;\n  }\n  return true;\n};\nconst getSetProp = (t, n, o, s) => {\n  if (isUndefined(s)) {\n    return o ? o[t] : n;\n  }\n  o && (isString(s) || isNumber(s)) && (o[t] = s);\n};\nconst attr = (t, n, o) => {\n  if (isUndefined(o)) {\n    return t ? t.getAttribute(n) : null;\n  }\n  t && t.setAttribute(n, o);\n};\nconst attrClass = (t, n, o, s) => {\n  if (o) {\n    const e = attr(t, n) || \"\";\n    const c = new Set(e.split(\" \"));\n    c[s ? \"add\" : \"delete\"](o);\n    attr(t, n, from(c).join(\" \").trim());\n  }\n};\nconst hasAttrClass = (t, n, o) => {\n  const s = attr(t, n) || \"\";\n  const e = new Set(s.split(\" \"));\n  return e.has(o);\n};\nconst removeAttr = (t, n) => {\n  t && t.removeAttribute(n);\n};\nconst scrollLeft = (t, n) => getSetProp(\"scrollLeft\", 0, t, n);\nconst scrollTop = (t, n) => getSetProp(\"scrollTop\", 0, t, n);\nconst s = isClient() && Element.prototype;\nconst find = (t, n) => {\n  const o = [];\n  const s = n ? isElement(n) ? n : null : document;\n  return s ? push(o, s.querySelectorAll(t)) : o;\n};\nconst findFirst = (t, n) => {\n  const o = n ? isElement(n) ? n : null : document;\n  return o ? o.querySelector(t) : null;\n};\nconst is = (t, n) => {\n  if (isElement(t)) {\n    const o = s.matches || s.msMatchesSelector;\n    return o.call(t, n);\n  }\n  return false;\n};\nconst contents = t => t ? from(t.childNodes) : [];\nconst parent = t => t ? t.parentElement : null;\nconst closest = (t, n) => {\n  if (isElement(t)) {\n    const o = s.closest;\n    if (o) {\n      return o.call(t, n);\n    }\n    do {\n      if (is(t, n)) {\n        return t;\n      }\n      t = parent(t);\n    } while (t);\n  }\n  return null;\n};\nconst liesBetween = (t, n, o) => {\n  const s = t && closest(t, n);\n  const e = t && findFirst(o, s);\n  const c = closest(e, n) === s;\n  return s && e ? s === t || e === t || c && closest(closest(t, o), n) !== s : false;\n};\nconst before = (t, n, o) => {\n  if (o && t) {\n    let s = n;\n    let e;\n    if (isArrayLike(o)) {\n      e = document.createDocumentFragment();\n      each(o, t => {\n        if (t === s) {\n          s = t.previousSibling;\n        }\n        e.appendChild(t);\n      });\n    } else {\n      e = o;\n    }\n    if (n) {\n      if (!s) {\n        s = t.firstChild;\n      } else if (s !== n) {\n        s = s.nextSibling;\n      }\n    }\n    t.insertBefore(e, s || null);\n  }\n};\nconst appendChildren = (t, n) => {\n  before(t, null, n);\n};\nconst insertBefore = (t, n) => {\n  before(parent(t), t, n);\n};\nconst insertAfter = (t, n) => {\n  before(parent(t), t && t.nextSibling, n);\n};\nconst removeElements = t => {\n  if (isArrayLike(t)) {\n    each(from(t), t => removeElements(t));\n  } else if (t) {\n    const n = parent(t);\n    if (n) {\n      n.removeChild(t);\n    }\n  }\n};\nconst createDiv = t => {\n  const n = document.createElement(\"div\");\n  if (t) {\n    attr(n, \"class\", t);\n  }\n  return n;\n};\nconst createDOM = t => {\n  const n = createDiv();\n  n.innerHTML = t.trim();\n  return each(contents(n), t => removeElements(t));\n};\nconst firstLetterToUpper = t => t.charAt(0).toUpperCase() + t.slice(1);\nconst getDummyStyle = () => createDiv().style;\nconst e = [\"-webkit-\", \"-moz-\", \"-o-\", \"-ms-\"];\nconst c = [\"WebKit\", \"Moz\", \"O\", \"MS\", \"webkit\", \"moz\", \"o\", \"ms\"];\nconst r = {};\nconst i = {};\nconst cssProperty = t => {\n  let n = i[t];\n  if (hasOwnProperty(i, t)) {\n    return n;\n  }\n  const o = firstLetterToUpper(t);\n  const s = getDummyStyle();\n  each(e, e => {\n    const c = e.replace(/-/g, \"\");\n    const r = [t, e + t, c + o, firstLetterToUpper(c) + o];\n    return !(n = r.find(t => void 0 !== s[t]));\n  });\n  return i[t] = n || \"\";\n};\nconst jsAPI = t => {\n  if (isClient()) {\n    let n = r[t] || window[t];\n    if (hasOwnProperty(r, t)) {\n      return n;\n    }\n    each(c, o => {\n      n = n || window[o + firstLetterToUpper(t)];\n      return !n;\n    });\n    r[t] = n;\n    return n;\n  }\n};\nconst l = jsAPI(\"MutationObserver\");\nconst a = jsAPI(\"IntersectionObserver\");\nconst u = jsAPI(\"ResizeObserver\");\nconst d = jsAPI(\"cancelAnimationFrame\");\nconst f = jsAPI(\"requestAnimationFrame\");\nconst _ = isClient() && window.setTimeout;\nconst h = isClient() && window.clearTimeout;\nconst equal = (t, n, o, s) => {\n  if (t && n) {\n    let e = true;\n    each(o, o => {\n      const c = s ? s(t[o]) : t[o];\n      const r = s ? s(n[o]) : n[o];\n      if (c !== r) {\n        e = false;\n      }\n    });\n    return e;\n  }\n  return false;\n};\nconst equalWH = (t, n) => equal(t, n, [\"w\", \"h\"]);\nconst equalXY = (t, n) => equal(t, n, [\"x\", \"y\"]);\nconst equalTRBL = (t, n) => equal(t, n, [\"t\", \"r\", \"b\", \"l\"]);\nconst equalBCRWH = (t, n, o) => equal(t, n, [\"width\", \"height\"], o && (t => Math.round(t)));\nconst noop = () => {};\nconst selfClearTimeout = t => {\n  let n;\n  const o = t ? _ : f;\n  const s = t ? h : d;\n  return [e => {\n    s(n);\n    n = o(e, isFunction(t) ? t() : t);\n  }, () => s(n)];\n};\nconst debounce = (t, n) => {\n  let o;\n  let s;\n  let e;\n  let c = noop;\n  const {\n    g: r,\n    v: i,\n    p: l\n  } = n || {};\n  const a = function invokeFunctionToDebounce(n) {\n    c();\n    h(o);\n    o = s = void 0;\n    c = noop;\n    t.apply(this, n);\n  };\n  const mergeParms = t => l && s ? l(s, t) : t;\n  const flush = () => {\n    if (c !== noop) {\n      a(mergeParms(e) || e);\n    }\n  };\n  const u = function debouncedFn() {\n    const t = from(arguments);\n    const n = isFunction(r) ? r() : r;\n    const l = isNumber(n) && n >= 0;\n    if (l) {\n      const r = isFunction(i) ? i() : i;\n      const l = isNumber(r) && r >= 0;\n      const u = n > 0 ? _ : f;\n      const g = n > 0 ? h : d;\n      const v = mergeParms(t);\n      const w = v || t;\n      const p = a.bind(0, w);\n      c();\n      const b = u(p, n);\n      c = () => g(b);\n      if (l && !o) {\n        o = _(flush, r);\n      }\n      s = e = w;\n    } else {\n      a(t);\n    }\n  };\n  u.m = flush;\n  return u;\n};\nconst {\n  max: g\n} = Math;\nconst animationCurrentTime = () => performance.now();\nconst animateNumber = (t, n, o, s, e) => {\n  let c = 0;\n  const r = animationCurrentTime();\n  const i = Math.max(0, o);\n  const frame = o => {\n    const l = animationCurrentTime();\n    const a = l - r;\n    const u = a >= i;\n    const d = o ? 1 : 1 - (g(0, r + i - l) / i || 0);\n    const _ = (n - t) * (isFunction(e) ? e(d, d * i, 0, 1, i) : d) + t;\n    const h = u || 1 === d;\n    s && s(_, d, h);\n    c = h ? 0 : f(() => frame());\n  };\n  frame();\n  return t => {\n    d(c);\n    t && frame(t);\n  };\n};\nconst v = /[^\\x20\\t\\r\\n\\f]+/g;\nconst classListAction = (t, n, o) => {\n  const s = t && t.classList;\n  let e;\n  let c = 0;\n  let r = false;\n  if (s && n && isString(n)) {\n    const t = n.match(v) || [];\n    r = t.length > 0;\n    while (e = t[c++]) {\n      r = !!o(s, e) && r;\n    }\n  }\n  return r;\n};\nconst hasClass = (t, n) => classListAction(t, n, (t, n) => t.contains(n));\nconst removeClass = (t, n) => {\n  classListAction(t, n, (t, n) => t.remove(n));\n};\nconst addClass = (t, n) => {\n  classListAction(t, n, (t, n) => t.add(n));\n  return removeClass.bind(0, t, n);\n};\nconst w = {\n  opacity: 1,\n  zindex: 1\n};\nconst parseToZeroOrNumber = (t, n) => {\n  const o = n ? parseFloat(t) : parseInt(t, 10);\n  return o === o ? o : 0;\n};\nconst adaptCSSVal = (t, n) => !w[t.toLowerCase()] && isNumber(n) ? `${n}px` : n;\nconst getCSSVal = (t, n, o) => null != n ? n[o] || n.getPropertyValue(o) : t.style[o];\nconst setCSSVal = (t, n, o) => {\n  try {\n    const {\n      style: s\n    } = t;\n    if (!isUndefined(s[n])) {\n      s[n] = adaptCSSVal(n, o);\n    } else {\n      s.setProperty(n, o);\n    }\n  } catch (s) {}\n};\nconst directionIsRTL = t => \"rtl\" === style(t, \"direction\");\nconst topRightBottomLeft = (t, n, o) => {\n  const s = n ? `${n}-` : \"\";\n  const e = o ? `-${o}` : \"\";\n  const c = `${s}top${e}`;\n  const r = `${s}right${e}`;\n  const i = `${s}bottom${e}`;\n  const l = `${s}left${e}`;\n  const a = style(t, [c, r, i, l]);\n  return {\n    t: parseToZeroOrNumber(a[c], true),\n    r: parseToZeroOrNumber(a[r], true),\n    b: parseToZeroOrNumber(a[i], true),\n    l: parseToZeroOrNumber(a[l], true)\n  };\n};\nconst {\n  round: p\n} = Math;\nconst b = {\n  w: 0,\n  h: 0\n};\nconst windowSize = () => ({\n  w: window.innerWidth,\n  h: window.innerHeight\n});\nconst offsetSize = t => t ? {\n  w: t.offsetWidth,\n  h: t.offsetHeight\n} : b;\nconst clientSize = t => t ? {\n  w: t.clientWidth,\n  h: t.clientHeight\n} : b;\nconst scrollSize = t => t ? {\n  w: t.scrollWidth,\n  h: t.scrollHeight\n} : b;\nconst fractionalSize = t => {\n  const n = parseFloat(style(t, \"height\")) || 0;\n  const o = parseFloat(style(t, \"width\")) || 0;\n  return {\n    w: o - p(o),\n    h: n - p(n)\n  };\n};\nconst getBoundingClientRect = t => t.getBoundingClientRect();\nlet m;\nconst supportPassiveEvents = () => {\n  if (isUndefined(m)) {\n    m = false;\n    try {\n      window.addEventListener(\"test\", null, Object.defineProperty({}, \"passive\", {\n        get() {\n          m = true;\n        }\n      }));\n    } catch (t) {}\n  }\n  return m;\n};\nconst splitEventNames = t => t.split(\" \");\nconst off = (t, n, o, s) => {\n  each(splitEventNames(n), n => {\n    t.removeEventListener(n, o, s);\n  });\n};\nconst on = (t, n, o, s) => {\n  var e;\n  const c = supportPassiveEvents();\n  const r = null != (e = c && s && s.S) ? e : c;\n  const i = s && s.$ || false;\n  const l = s && s.C || false;\n  const a = [];\n  const u = c ? {\n    passive: r,\n    capture: i\n  } : i;\n  each(splitEventNames(n), n => {\n    const s = l ? e => {\n      t.removeEventListener(n, s, i);\n      o && o(e);\n    } : o;\n    push(a, off.bind(null, t, n, s, i));\n    t.addEventListener(n, s, u);\n  });\n  return runEachAndClear.bind(0, a);\n};\nconst stopPropagation = t => t.stopPropagation();\nconst preventDefault = t => t.preventDefault();\nconst y = {\n  x: 0,\n  y: 0\n};\nconst absoluteCoordinates = t => {\n  const n = t ? getBoundingClientRect(t) : 0;\n  return n ? {\n    x: n.left + window.pageYOffset,\n    y: n.top + window.pageXOffset\n  } : y;\n};\nconst manageListener = (t, n) => {\n  each(isArray(n) ? n : [n], t);\n};\nconst createEventListenerHub = t => {\n  const n = new Map();\n  const removeEvent = (t, o) => {\n    if (t) {\n      const s = n.get(t);\n      manageListener(t => {\n        if (s) {\n          s[t ? \"delete\" : \"clear\"](t);\n        }\n      }, o);\n    } else {\n      n.forEach(t => {\n        t.clear();\n      });\n      n.clear();\n    }\n  };\n  const addEvent = (t, o) => {\n    if (isString(t)) {\n      const s = n.get(t) || new Set();\n      n.set(t, s);\n      manageListener(t => {\n        isFunction(t) && s.add(t);\n      }, o);\n      return removeEvent.bind(0, t, o);\n    }\n    if (isBoolean(o) && o) {\n      removeEvent();\n    }\n    const s = keys(t);\n    const e = [];\n    each(s, n => {\n      const o = t[n];\n      o && push(e, addEvent(n, o));\n    });\n    return runEachAndClear.bind(0, e);\n  };\n  const triggerEvent = (t, o) => {\n    const s = n.get(t);\n    each(from(s), t => {\n      if (o && !isEmptyArray(o)) {\n        t.apply(0, o);\n      } else {\n        t();\n      }\n    });\n  };\n  addEvent(t || {});\n  return [addEvent, removeEvent, triggerEvent];\n};\nconst opsStringify = t => JSON.stringify(t, (t, n) => {\n  if (isFunction(n)) {\n    throw new Error();\n  }\n  return n;\n});\nconst S = {\n  paddingAbsolute: false,\n  showNativeOverlaidScrollbars: false,\n  update: {\n    elementEvents: [[\"img\", \"load\"]],\n    debounce: [0, 33],\n    attributes: null,\n    ignoreMutation: null\n  },\n  overflow: {\n    x: \"scroll\",\n    y: \"scroll\"\n  },\n  scrollbars: {\n    theme: \"os-theme-dark\",\n    visibility: \"auto\",\n    autoHide: \"never\",\n    autoHideDelay: 1300,\n    dragScroll: true,\n    clickScroll: false,\n    pointers: [\"mouse\", \"touch\", \"pen\"]\n  }\n};\nconst getOptionsDiff = (t, n) => {\n  const o = {};\n  const s = keys(n).concat(keys(t));\n  each(s, s => {\n    const e = t[s];\n    const c = n[s];\n    if (isObject(e) && isObject(c)) {\n      assignDeep(o[s] = {}, getOptionsDiff(e, c));\n      if (isEmptyObject(o[s])) {\n        delete o[s];\n      }\n    } else if (hasOwnProperty(n, s) && c !== e) {\n      let t = true;\n      if (isArray(e) || isArray(c)) {\n        try {\n          if (opsStringify(e) === opsStringify(c)) {\n            t = false;\n          }\n        } catch (r) {}\n      }\n      if (t) {\n        o[s] = c;\n      }\n    }\n  });\n  return o;\n};\nconst x = \"os-environment\";\nconst $ = `${x}-flexbox-glue`;\nconst C = `${$}-max`;\nconst O = \"data-overlayscrollbars\";\nconst z = \"data-overlayscrollbars-initialize\";\nconst T = `${O}-overflow-x`;\nconst E = `${O}-overflow-y`;\nconst I = \"overflowVisible\";\nconst A = \"scrollbarHidden\";\nconst L = \"updating\";\nconst H = \"os-padding\";\nconst M = \"os-viewport\";\nconst P = `${M}-arrange`;\nconst D = \"os-content\";\nconst R = `${M}-scrollbar-hidden`;\nconst k = `os-overflow-visible`;\nconst B = \"os-size-observer\";\nconst V = `${B}-appear`;\nconst Y = `${B}-listener`;\nconst j = `${Y}-scroll`;\nconst N = `${Y}-item`;\nconst q = `${N}-final`;\nconst F = \"os-trinsic-observer\";\nconst G = \"os-theme-none\";\nconst X = \"os-scrollbar\";\nconst U = `${X}-rtl`;\nconst W = `${X}-horizontal`;\nconst Z = `${X}-vertical`;\nconst J = `${X}-track`;\nconst K = `${X}-handle`;\nconst Q = `${X}-visible`;\nconst tt = `${X}-cornerless`;\nconst nt = `${X}-transitionless`;\nconst ot = `${X}-interaction`;\nconst st = `${X}-unusable`;\nconst et = `${X}-auto-hidden`;\nconst ct = `${X}-wheel`;\nconst rt = `${J}-interactive`;\nconst it = `${K}-interactive`;\nconst lt = {};\nconst getPlugins = () => lt;\nconst addPlugin = t => {\n  const n = [];\n  each(isArray(t) ? t : [t], t => {\n    const o = keys(t);\n    each(o, o => {\n      push(n, lt[o] = t[o]);\n    });\n  });\n  return n;\n};\nconst at = {\n  boolean: \"__TPL_boolean_TYPE__\",\n  number: \"__TPL_number_TYPE__\",\n  string: \"__TPL_string_TYPE__\",\n  array: \"__TPL_array_TYPE__\",\n  object: \"__TPL_object_TYPE__\",\n  function: \"__TPL_function_TYPE__\",\n  null: \"__TPL_null_TYPE__\"\n};\nconst ut = at.number;\nconst dt = at.boolean;\nconst ft = [at.array, at.null];\nconst _t = \"hidden scroll visible visible-hidden\";\nconst ht = \"visible hidden auto\";\nconst gt = \"never scroll leavemove\";\n({\n  paddingAbsolute: dt,\n  showNativeOverlaidScrollbars: dt,\n  update: {\n    elementEvents: ft,\n    attributes: ft,\n    debounce: [at.number, at.array, at.null],\n    ignoreMutation: [at.function, at.null]\n  },\n  overflow: {\n    x: _t,\n    y: _t\n  },\n  scrollbars: {\n    theme: [at.string, at.null],\n    visibility: ht,\n    autoHide: gt,\n    autoHideDelay: ut,\n    dragScroll: dt,\n    clickScroll: dt,\n    pointers: [at.array, at.null]\n  }\n});\nconst vt = \"__osOptionsValidationPlugin\";\nconst wt = 3333333;\nconst pt = \"scroll\";\nconst bt = \"__osSizeObserverPlugin\";\nconst mt = /* @__PURE__ */(() => ({\n  [bt]: {\n    O: (t, n, o) => {\n      const s = createDOM(`<div class=\"${N}\" dir=\"ltr\"><div class=\"${N}\"><div class=\"${q}\"></div></div><div class=\"${N}\"><div class=\"${q}\" style=\"width: 200%; height: 200%\"></div></div></div>`);\n      appendChildren(t, s);\n      addClass(t, j);\n      const e = s[0];\n      const c = e.lastChild;\n      const r = e.firstChild;\n      const i = null == r ? void 0 : r.firstChild;\n      let l = offsetSize(e);\n      let a = l;\n      let u = false;\n      let _;\n      const reset = () => {\n        scrollLeft(r, wt);\n        scrollTop(r, wt);\n        scrollLeft(c, wt);\n        scrollTop(c, wt);\n      };\n      const onResized = t => {\n        _ = 0;\n        if (u) {\n          l = a;\n          n(true === t);\n        }\n      };\n      const onScroll = t => {\n        a = offsetSize(e);\n        u = !t || !equalWH(a, l);\n        if (t) {\n          stopPropagation(t);\n          if (u && !_) {\n            d(_);\n            _ = f(onResized);\n          }\n        } else {\n          onResized(false === t);\n        }\n        reset();\n      };\n      const h = push([], [on(r, pt, onScroll), on(c, pt, onScroll)]);\n      style(i, {\n        width: wt,\n        height: wt\n      });\n      f(reset);\n      return [o ? onScroll.bind(0, false) : reset, h];\n    }\n  }\n}))();\nlet yt = 0;\nconst {\n  round: St,\n  abs: xt\n} = Math;\nconst getWindowDPR = () => {\n  const t = window.screen.deviceXDPI || 0;\n  const n = window.screen.logicalXDPI || 1;\n  return window.devicePixelRatio || t / n;\n};\nconst diffBiggerThanOne = (t, n) => {\n  const o = xt(t);\n  const s = xt(n);\n  return !(o === s || o + 1 === s || o - 1 === s);\n};\nconst $t = \"__osScrollbarsHidingPlugin\";\nconst Ct = /* @__PURE__ */(() => ({\n  [$t]: {\n    T: t => {\n      const {\n        I: n,\n        A: o,\n        L: s\n      } = t;\n      const e = !s && !n && (o.x || o.y);\n      const c = e ? document.createElement(\"style\") : false;\n      if (c) {\n        attr(c, \"id\", `${P}-${yt}`);\n        yt++;\n      }\n      return c;\n    },\n    H: (t, n, o, s, e, c, r) => {\n      const arrangeViewport = (n, c, r, i) => {\n        if (t) {\n          const {\n            M: t\n          } = e();\n          const {\n            P: l,\n            D: a\n          } = n;\n          const {\n            x: u,\n            y: d\n          } = a;\n          const {\n            x: f,\n            y: _\n          } = l;\n          const h = i ? \"paddingRight\" : \"paddingLeft\";\n          const g = t[h];\n          const v = t.paddingTop;\n          const w = c.w + r.w;\n          const p = c.h + r.h;\n          const b = {\n            w: _ && d ? `${_ + w - g}px` : \"\",\n            h: f && u ? `${f + p - v}px` : \"\"\n          };\n          if (s) {\n            const {\n              sheet: t\n            } = s;\n            if (t) {\n              const {\n                cssRules: n\n              } = t;\n              if (n) {\n                if (!n.length) {\n                  t.insertRule(`#${attr(s, \"id\")} + .${P}::before {}`, 0);\n                }\n                const o = n[0].style;\n                o.width = b.w;\n                o.height = b.h;\n              }\n            }\n          } else {\n            style(o, {\n              \"--os-vaw\": b.w,\n              \"--os-vah\": b.h\n            });\n          }\n        }\n        return t;\n      };\n      const undoViewportArrange = (s, i, l) => {\n        if (t) {\n          const a = l || c(s);\n          const {\n            M: u\n          } = e();\n          const {\n            D: d\n          } = a;\n          const {\n            x: f,\n            y: _\n          } = d;\n          const h = {};\n          const assignProps = t => each(t.split(\" \"), t => {\n            h[t] = u[t];\n          });\n          if (f) {\n            assignProps(\"marginBottom paddingTop paddingBottom\");\n          }\n          if (_) {\n            assignProps(\"marginLeft marginRight paddingLeft paddingRight\");\n          }\n          const g = style(o, keys(h));\n          removeClass(o, P);\n          if (!n) {\n            h.height = \"\";\n          }\n          style(o, h);\n          return [() => {\n            r(a, i, t, g);\n            style(o, g);\n            addClass(o, P);\n          }, a];\n        }\n        return [noop];\n      };\n      return [arrangeViewport, undoViewportArrange];\n    },\n    R: () => {\n      let t = {\n        w: 0,\n        h: 0\n      };\n      let n = 0;\n      return (o, s, e) => {\n        const c = windowSize();\n        const r = {\n          w: c.w - t.w,\n          h: c.h - t.h\n        };\n        if (0 === r.w && 0 === r.h) {\n          return;\n        }\n        const i = {\n          w: xt(r.w),\n          h: xt(r.h)\n        };\n        const l = {\n          w: xt(St(c.w / (t.w / 100))),\n          h: xt(St(c.h / (t.h / 100)))\n        };\n        const a = getWindowDPR();\n        const u = i.w > 2 && i.h > 2;\n        const d = !diffBiggerThanOne(l.w, l.h);\n        const f = a !== n && a > 0;\n        const _ = u && d && f;\n        if (_) {\n          const [t, n] = s();\n          assignDeep(o.k, t);\n          if (n) {\n            e();\n          }\n        }\n        t = c;\n        n = a;\n      };\n    }\n  }\n}))();\nconst Ot = \"__osClickScrollPlugin\";\nconst zt = /* @__PURE__ */(() => ({\n  [Ot]: {\n    O: (t, n, o, s, e) => {\n      let c = 0;\n      let r = noop;\n      const animateClickScroll = i => {\n        r = animateNumber(i, i + s * Math.sign(o), 133, (o, i, l) => {\n          t(o);\n          const a = n();\n          const u = a + s;\n          const d = e >= a && e <= u;\n          if (l && !d) {\n            if (c) {\n              animateClickScroll(o);\n            } else {\n              const t = setTimeout(() => {\n                animateClickScroll(o);\n              }, 222);\n              r = () => {\n                clearTimeout(t);\n              };\n            }\n            c++;\n          }\n        });\n      };\n      animateClickScroll(0);\n      return () => r();\n    }\n  }\n}))();\nlet Tt;\nconst getNativeScrollbarSize = (t, n, o, s) => {\n  appendChildren(t, n);\n  const e = clientSize(n);\n  const c = offsetSize(n);\n  const r = fractionalSize(o);\n  s && removeElements(n);\n  return {\n    x: c.h - e.h + r.h,\n    y: c.w - e.w + r.w\n  };\n};\nconst getNativeScrollbarsHiding = t => {\n  let n = false;\n  const o = addClass(t, R);\n  try {\n    n = \"none\" === style(t, cssProperty(\"scrollbar-width\")) || \"none\" === window.getComputedStyle(t, \"::-webkit-scrollbar\").getPropertyValue(\"display\");\n  } catch (s) {}\n  o();\n  return n;\n};\nconst getRtlScrollBehavior = (t, n) => {\n  const o = \"hidden\";\n  style(t, {\n    overflowX: o,\n    overflowY: o,\n    direction: \"rtl\"\n  });\n  scrollLeft(t, 0);\n  const s = absoluteCoordinates(t);\n  const e = absoluteCoordinates(n);\n  scrollLeft(t, -999);\n  const c = absoluteCoordinates(n);\n  return {\n    i: s.x === e.x,\n    n: e.x !== c.x\n  };\n};\nconst getFlexboxGlue = (t, n) => {\n  const o = addClass(t, $);\n  const s = getBoundingClientRect(t);\n  const e = getBoundingClientRect(n);\n  const c = equalBCRWH(e, s, true);\n  const r = addClass(t, C);\n  const i = getBoundingClientRect(t);\n  const l = getBoundingClientRect(n);\n  const a = equalBCRWH(l, i, true);\n  o();\n  r();\n  return c && a;\n};\nconst createEnvironment = () => {\n  const {\n    body: t\n  } = document;\n  const n = createDOM(`<div class=\"${x}\"><div></div></div>`);\n  const o = n[0];\n  const s = o.firstChild;\n  const [e,, c] = createEventListenerHub();\n  const [r, i] = createCache({\n    o: getNativeScrollbarSize(t, o, s),\n    u: equalXY\n  }, getNativeScrollbarSize.bind(0, t, o, s, true));\n  const [l] = i();\n  const a = getNativeScrollbarsHiding(o);\n  const u = {\n    x: 0 === l.x,\n    y: 0 === l.y\n  };\n  const d = {\n    elements: {\n      host: null,\n      padding: !a,\n      viewport: t => a && t === t.ownerDocument.body && t,\n      content: false\n    },\n    scrollbars: {\n      slot: true\n    },\n    cancel: {\n      nativeScrollbarsOverlaid: false,\n      body: null\n    }\n  };\n  const f = assignDeep({}, S);\n  const _ = assignDeep.bind(0, {}, f);\n  const h = assignDeep.bind(0, {}, d);\n  const g = {\n    k: l,\n    A: u,\n    I: a,\n    L: \"-1\" === style(o, \"zIndex\"),\n    B: getRtlScrollBehavior(o, s),\n    V: getFlexboxGlue(o, s),\n    Y: e.bind(0, \"z\"),\n    j: e.bind(0, \"r\"),\n    N: h,\n    q: t => assignDeep(d, t) && h(),\n    F: _,\n    G: t => assignDeep(f, t) && _(),\n    X: assignDeep({}, d),\n    U: assignDeep({}, f)\n  };\n  const v = window.addEventListener;\n  const w = debounce(t => c(t ? \"z\" : \"r\"), {\n    g: 33,\n    v: 99\n  });\n  removeAttr(o, \"style\");\n  removeElements(o);\n  v(\"resize\", w.bind(0, false));\n  if (!a && (!u.x || !u.y)) {\n    let t;\n    v(\"resize\", () => {\n      const n = getPlugins()[$t];\n      t = t || n && n.R();\n      t && t(g, r, w.bind(0, true));\n    });\n  }\n  return g;\n};\nconst getEnvironment = () => {\n  if (!Tt) {\n    Tt = createEnvironment();\n  }\n  return Tt;\n};\nconst resolveInitialization = (t, n) => isFunction(n) ? n.apply(0, t) : n;\nconst staticInitializationElement = (t, n, o, s) => {\n  const e = isUndefined(s) ? o : s;\n  const c = resolveInitialization(t, e);\n  return c || n.apply(0, t);\n};\nconst dynamicInitializationElement = (t, n, o, s) => {\n  const e = isUndefined(s) ? o : s;\n  const c = resolveInitialization(t, e);\n  return !!c && (isHTMLElement(c) ? c : n.apply(0, t));\n};\nconst cancelInitialization = (t, n, o) => {\n  const {\n    nativeScrollbarsOverlaid: s,\n    body: e\n  } = o || {};\n  const {\n    A: c,\n    I: r\n  } = getEnvironment();\n  const {\n    nativeScrollbarsOverlaid: i,\n    body: l\n  } = n;\n  const a = null != s ? s : i;\n  const u = isUndefined(e) ? l : e;\n  const d = (c.x || c.y) && a;\n  const f = t && (isNull(u) ? !r : u);\n  return !!d || !!f;\n};\nconst Et = new WeakMap();\nconst addInstance = (t, n) => {\n  Et.set(t, n);\n};\nconst removeInstance = t => {\n  Et.delete(t);\n};\nconst getInstance = t => Et.get(t);\nconst getPropByPath = (t, n) => t ? n.split(\".\").reduce((t, n) => t && hasOwnProperty(t, n) ? t[n] : void 0, t) : void 0;\nconst createOptionCheck = (t, n, o) => s => [getPropByPath(t, s), o || void 0 !== getPropByPath(n, s)];\nconst createState = t => {\n  let n = t;\n  return [() => n, t => {\n    n = assignDeep({}, n, t);\n  }];\n};\nconst It = \"tabindex\";\nconst At = createDiv.bind(0, \"\");\nconst unwrap = t => {\n  appendChildren(parent(t), contents(t));\n  removeElements(t);\n};\nconst createStructureSetupElements = t => {\n  const n = getEnvironment();\n  const {\n    N: o,\n    I: s\n  } = n;\n  const e = getPlugins()[$t];\n  const c = e && e.T;\n  const {\n    elements: r\n  } = o();\n  const {\n    host: i,\n    padding: l,\n    viewport: a,\n    content: u\n  } = r;\n  const d = isHTMLElement(t);\n  const f = d ? {} : t;\n  const {\n    elements: _\n  } = f;\n  const {\n    host: h,\n    padding: g,\n    viewport: v,\n    content: w\n  } = _ || {};\n  const p = d ? t : f.target;\n  const b = is(p, \"textarea\");\n  const m = p.ownerDocument;\n  const y = m.documentElement;\n  const S = p === m.body;\n  const x = m.defaultView;\n  const $ = staticInitializationElement.bind(0, [p]);\n  const C = dynamicInitializationElement.bind(0, [p]);\n  const I = resolveInitialization.bind(0, [p]);\n  const A = $.bind(0, At, a);\n  const L = C.bind(0, At, u);\n  const P = A(v);\n  const k = P === p;\n  const B = k && S;\n  const V = !k && L(w);\n  const Y = !k && isHTMLElement(P) && P === V;\n  const j = Y && !!I(u);\n  const N = j ? A() : P;\n  const q = j ? V : L();\n  const F = Y ? N : P;\n  const G = B ? y : F;\n  const X = b ? $(At, i, h) : p;\n  const U = B ? G : X;\n  const W = Y ? q : V;\n  const Z = m.activeElement;\n  const J = !k && x.top === x && Z === p;\n  const K = {\n    W: p,\n    Z: U,\n    J: G,\n    K: !k && C(At, l, g),\n    tt: W,\n    nt: !k && !s && c && c(n),\n    ot: B ? y : G,\n    st: B ? m : G,\n    et: x,\n    ct: m,\n    rt: b,\n    it: S,\n    lt: d,\n    ut: k,\n    dt: Y,\n    ft: (t, n) => k ? hasAttrClass(G, O, n) : hasClass(G, t),\n    _t: (t, n, o) => k ? attrClass(G, O, n, o) : (o ? addClass : removeClass)(G, t)\n  };\n  const Q = keys(K).reduce((t, n) => {\n    const o = K[n];\n    return push(t, o && !parent(o) ? o : false);\n  }, []);\n  const elementIsGenerated = t => t ? indexOf(Q, t) > -1 : null;\n  const {\n    W: tt,\n    Z: nt,\n    K: ot,\n    J: st,\n    tt: et,\n    nt: ct\n  } = K;\n  const rt = [() => {\n    removeAttr(nt, O);\n    removeAttr(nt, z);\n    removeAttr(tt, z);\n    if (S) {\n      removeAttr(y, O);\n      removeAttr(y, z);\n    }\n  }];\n  const it = b && elementIsGenerated(nt);\n  let lt = b ? tt : contents([et, st, ot, nt, tt].find(t => false === elementIsGenerated(t)));\n  const at = B ? tt : et || st;\n  const appendElements = () => {\n    attr(nt, O, k ? \"viewport\" : \"host\");\n    const t = addClass(ot, H);\n    const n = addClass(st, !k && M);\n    const o = addClass(et, D);\n    const e = S && !k ? addClass(parent(p), R) : noop;\n    if (it) {\n      insertAfter(tt, nt);\n      push(rt, () => {\n        insertAfter(nt, tt);\n        removeElements(nt);\n      });\n    }\n    appendChildren(at, lt);\n    appendChildren(nt, ot);\n    appendChildren(ot || nt, !k && st);\n    appendChildren(st, et);\n    push(rt, () => {\n      e();\n      removeAttr(st, T);\n      removeAttr(st, E);\n      if (elementIsGenerated(et)) {\n        unwrap(et);\n      }\n      if (elementIsGenerated(st)) {\n        unwrap(st);\n      }\n      if (elementIsGenerated(ot)) {\n        unwrap(ot);\n      }\n      t();\n      n();\n      o();\n    });\n    if (s && !k) {\n      push(rt, removeClass.bind(0, st, R));\n    }\n    if (ct) {\n      insertBefore(st, ct);\n      push(rt, removeElements.bind(0, ct));\n    }\n    if (J) {\n      const t = attr(st, It);\n      attr(st, It, \"-1\");\n      st.focus();\n      const revertViewportTabIndex = () => t ? attr(st, It, t) : removeAttr(st, It);\n      const n = on(m, \"pointerdown keydown\", () => {\n        revertViewportTabIndex();\n        n();\n      });\n      push(rt, [revertViewportTabIndex, n]);\n    } else if (Z && Z.focus) {\n      Z.focus();\n    }\n    lt = 0;\n  };\n  return [K, appendElements, runEachAndClear.bind(0, rt)];\n};\nconst createTrinsicUpdateSegment = (t, n) => {\n  const {\n    tt: o\n  } = t;\n  const [s] = n;\n  return t => {\n    const {\n      V: n\n    } = getEnvironment();\n    const {\n      ht: e\n    } = s();\n    const {\n      gt: c\n    } = t;\n    const r = (o || !n) && c;\n    if (r) {\n      style(o, {\n        height: e ? \"\" : \"100%\"\n      });\n    }\n    return {\n      vt: r,\n      wt: r\n    };\n  };\n};\nconst createPaddingUpdateSegment = (t, n) => {\n  const [o, s] = n;\n  const {\n    Z: e,\n    K: c,\n    J: r,\n    ut: i\n  } = t;\n  const [l, a] = createCache({\n    u: equalTRBL,\n    o: topRightBottomLeft()\n  }, topRightBottomLeft.bind(0, e, \"padding\", \"\"));\n  return (t, n, e) => {\n    let [u, d] = a(e);\n    const {\n      I: f,\n      V: _\n    } = getEnvironment();\n    const {\n      bt: h\n    } = o();\n    const {\n      vt: g,\n      wt: v,\n      yt: w\n    } = t;\n    const [p, b] = n(\"paddingAbsolute\");\n    const m = !_ && v;\n    if (g || d || m) {\n      [u, d] = l(e);\n    }\n    const y = !i && (b || w || d);\n    if (y) {\n      const t = !p || !c && !f;\n      const n = u.r + u.l;\n      const o = u.t + u.b;\n      const e = {\n        marginRight: t && !h ? -n : 0,\n        marginBottom: t ? -o : 0,\n        marginLeft: t && h ? -n : 0,\n        top: t ? -u.t : 0,\n        right: t ? h ? -u.r : \"auto\" : 0,\n        left: t ? h ? \"auto\" : -u.l : 0,\n        width: t ? `calc(100% + ${n}px)` : \"\"\n      };\n      const i = {\n        paddingTop: t ? u.t : 0,\n        paddingRight: t ? u.r : 0,\n        paddingBottom: t ? u.b : 0,\n        paddingLeft: t ? u.l : 0\n      };\n      style(c || r, e);\n      style(r, i);\n      s({\n        K: u,\n        St: !t,\n        M: c ? i : assignDeep({}, e, i)\n      });\n    }\n    return {\n      xt: y\n    };\n  };\n};\nconst {\n  max: Lt\n} = Math;\nconst Ht = Lt.bind(0, 0);\nconst Mt = \"visible\";\nconst Pt = \"hidden\";\nconst Dt = 42;\nconst Rt = {\n  u: equalWH,\n  o: {\n    w: 0,\n    h: 0\n  }\n};\nconst kt = {\n  u: equalXY,\n  o: {\n    x: Pt,\n    y: Pt\n  }\n};\nconst getOverflowAmount = (t, n) => {\n  const o = window.devicePixelRatio % 1 !== 0 ? 1 : 0;\n  const s = {\n    w: Ht(t.w - n.w),\n    h: Ht(t.h - n.h)\n  };\n  return {\n    w: s.w > o ? s.w : 0,\n    h: s.h > o ? s.h : 0\n  };\n};\nconst conditionalClass = (t, n, o) => o ? addClass(t, n) : removeClass(t, n);\nconst overflowIsVisible = t => 0 === t.indexOf(Mt);\nconst createOverflowUpdateSegment = (t, n) => {\n  const [o, s] = n;\n  const {\n    Z: e,\n    K: c,\n    J: r,\n    nt: i,\n    ut: l,\n    _t: a,\n    it: u,\n    et: d\n  } = t;\n  const {\n    k: f,\n    V: _,\n    I: h,\n    A: g\n  } = getEnvironment();\n  const v = getPlugins()[$t];\n  const w = !l && !h && (g.x || g.y);\n  const p = u && l;\n  const [b, m] = createCache(Rt, fractionalSize.bind(0, r));\n  const [y, S] = createCache(Rt, scrollSize.bind(0, r));\n  const [x, $] = createCache(Rt);\n  const [C, z] = createCache(Rt);\n  const [L] = createCache(kt);\n  const fixFlexboxGlue = (t, n) => {\n    style(r, {\n      height: \"\"\n    });\n    if (n) {\n      const {\n        St: n,\n        K: s\n      } = o();\n      const {\n        $t: c,\n        P: i\n      } = t;\n      const l = fractionalSize(e);\n      const a = clientSize(e);\n      const u = \"content-box\" === style(r, \"boxSizing\");\n      const d = n || u ? s.b + s.t : 0;\n      const f = !(g.x && u);\n      style(r, {\n        height: a.h + l.h + (c.x && f ? i.x : 0) - d\n      });\n    }\n  };\n  const getViewportOverflowState = (t, n) => {\n    const o = !h && !t ? Dt : 0;\n    const getStatePerAxis = (t, s, e) => {\n      const c = style(r, t);\n      const i = n ? n[t] : c;\n      const l = \"scroll\" === i;\n      const a = s ? o : e;\n      const u = l && !h ? a : 0;\n      const d = s && !!o;\n      return [c, l, u, d];\n    };\n    const [s, e, c, i] = getStatePerAxis(\"overflowX\", g.x, f.x);\n    const [l, a, u, d] = getStatePerAxis(\"overflowY\", g.y, f.y);\n    return {\n      Ct: {\n        x: s,\n        y: l\n      },\n      $t: {\n        x: e,\n        y: a\n      },\n      P: {\n        x: c,\n        y: u\n      },\n      D: {\n        x: i,\n        y: d\n      }\n    };\n  };\n  const setViewportOverflowState = (t, n, o, s) => {\n    const setAxisOverflowStyle = (t, n) => {\n      const o = overflowIsVisible(t);\n      const s = n && o && t.replace(`${Mt}-`, \"\") || \"\";\n      return [n && !o ? t : \"\", overflowIsVisible(s) ? \"hidden\" : s];\n    };\n    const [e, c] = setAxisOverflowStyle(o.x, n.x);\n    const [r, i] = setAxisOverflowStyle(o.y, n.y);\n    s.overflowX = c && r ? c : e;\n    s.overflowY = i && e ? i : r;\n    return getViewportOverflowState(t, s);\n  };\n  const hideNativeScrollbars = (t, n, s, e) => {\n    const {\n      P: c,\n      D: r\n    } = t;\n    const {\n      x: i,\n      y: l\n    } = r;\n    const {\n      x: a,\n      y: u\n    } = c;\n    const {\n      M: d\n    } = o();\n    const f = n ? \"marginLeft\" : \"marginRight\";\n    const _ = n ? \"paddingLeft\" : \"paddingRight\";\n    const h = d[f];\n    const g = d.marginBottom;\n    const v = d[_];\n    const w = d.paddingBottom;\n    e.width = `calc(100% + ${u + -1 * h}px)`;\n    e[f] = -u + h;\n    e.marginBottom = -a + g;\n    if (s) {\n      e[_] = v + (l ? u : 0);\n      e.paddingBottom = w + (i ? a : 0);\n    }\n  };\n  const [H, M] = v ? v.H(w, _, r, i, o, getViewportOverflowState, hideNativeScrollbars) : [() => w, () => [noop]];\n  return (t, n, i) => {\n    const {\n      vt: u,\n      Ot: f,\n      wt: v,\n      xt: w,\n      gt: P,\n      yt: D\n    } = t;\n    const {\n      ht: B,\n      bt: V\n    } = o();\n    const [Y, j] = n(\"showNativeOverlaidScrollbars\");\n    const [N, q] = n(\"overflow\");\n    const F = Y && g.x && g.y;\n    const G = !l && !_ && (u || v || f || j || P);\n    const X = overflowIsVisible(N.x);\n    const U = overflowIsVisible(N.y);\n    const W = X || U;\n    let Z = m(i);\n    let J = S(i);\n    let K = $(i);\n    let Q = z(i);\n    let tt;\n    if (j && h) {\n      a(R, A, !F);\n    }\n    if (G) {\n      tt = getViewportOverflowState(F);\n      fixFlexboxGlue(tt, B);\n    }\n    if (u || w || v || D || j) {\n      if (W) {\n        a(k, I, false);\n      }\n      const [t, n] = M(F, V, tt);\n      const [o, s] = Z = b(i);\n      const [e, c] = J = y(i);\n      const l = clientSize(r);\n      let u = e;\n      let f = l;\n      t();\n      if ((c || s || j) && n && !F && H(n, e, o, V)) {\n        f = clientSize(r);\n        u = scrollSize(r);\n      }\n      const _ = {\n        w: Ht(Lt(e.w, u.w) + o.w),\n        h: Ht(Lt(e.h, u.h) + o.h)\n      };\n      const h = {\n        w: Ht((p ? d.innerWidth : f.w + Ht(l.w - e.w)) + o.w),\n        h: Ht((p ? d.innerHeight + o.h : f.h + Ht(l.h - e.h)) + o.h)\n      };\n      Q = C(h);\n      K = x(getOverflowAmount(_, h), i);\n    }\n    const [nt, ot] = Q;\n    const [st, et] = K;\n    const [ct, rt] = J;\n    const [it, lt] = Z;\n    const at = {\n      x: st.w > 0,\n      y: st.h > 0\n    };\n    const ut = X && U && (at.x || at.y) || X && at.x && !at.y || U && at.y && !at.x;\n    if (w || D || lt || rt || ot || et || q || j || G) {\n      const t = {\n        marginRight: 0,\n        marginBottom: 0,\n        marginLeft: 0,\n        width: \"\",\n        overflowY: \"\",\n        overflowX: \"\"\n      };\n      const n = setViewportOverflowState(F, at, N, t);\n      const o = H(n, ct, it, V);\n      if (!l) {\n        hideNativeScrollbars(n, V, o, t);\n      }\n      if (G) {\n        fixFlexboxGlue(n, B);\n      }\n      if (l) {\n        attr(e, T, t.overflowX);\n        attr(e, E, t.overflowY);\n      } else {\n        style(r, t);\n      }\n    }\n    attrClass(e, O, I, ut);\n    conditionalClass(c, k, ut);\n    !l && conditionalClass(r, k, W);\n    const [dt, ft] = L(getViewportOverflowState(F).Ct);\n    s({\n      Ct: dt,\n      zt: {\n        x: nt.w,\n        y: nt.h\n      },\n      Tt: {\n        x: st.w,\n        y: st.h\n      },\n      Et: at\n    });\n    return {\n      It: ft,\n      At: ot,\n      Lt: et\n    };\n  };\n};\nconst prepareUpdateHints = (t, n, o) => {\n  const s = {};\n  const e = n || {};\n  const c = keys(t).concat(keys(e));\n  each(c, n => {\n    const c = t[n];\n    const r = e[n];\n    s[n] = !!(o || c || r);\n  });\n  return s;\n};\nconst createStructureSetupUpdate = (t, n) => {\n  const {\n    W: o,\n    J: s,\n    _t: e,\n    ut: c\n  } = t;\n  const {\n    I: r,\n    A: i,\n    V: l\n  } = getEnvironment();\n  const a = !r && (i.x || i.y);\n  const u = [createTrinsicUpdateSegment(t, n), createPaddingUpdateSegment(t, n), createOverflowUpdateSegment(t, n)];\n  return (t, n, r) => {\n    const i = prepareUpdateHints(assignDeep({\n      vt: false,\n      xt: false,\n      yt: false,\n      gt: false,\n      At: false,\n      Lt: false,\n      It: false,\n      Ot: false,\n      wt: false\n    }, n), {}, r);\n    const d = a || !l;\n    const f = d && scrollLeft(s);\n    const _ = d && scrollTop(s);\n    e(\"\", L, true);\n    let h = i;\n    each(u, n => {\n      h = prepareUpdateHints(h, n(h, t, !!r) || {}, r);\n    });\n    scrollLeft(s, f);\n    scrollTop(s, _);\n    e(\"\", L);\n    if (!c) {\n      scrollLeft(o, 0);\n      scrollTop(o, 0);\n    }\n    return h;\n  };\n};\nconst createEventContentChange = (t, n, o) => {\n  let s;\n  let e = false;\n  const destroy = () => {\n    e = true;\n  };\n  const updateElements = c => {\n    if (o) {\n      const r = o.reduce((n, o) => {\n        if (o) {\n          const [s, e] = o;\n          const r = e && s && (c ? c(s) : find(s, t));\n          if (r && r.length && e && isString(e)) {\n            push(n, [r, e.trim()], true);\n          }\n        }\n        return n;\n      }, []);\n      each(r, o => each(o[0], c => {\n        const r = o[1];\n        const i = s.get(c) || [];\n        const l = t.contains(c);\n        if (l) {\n          const t = on(c, r, o => {\n            if (e) {\n              t();\n              s.delete(c);\n            } else {\n              n(o);\n            }\n          });\n          s.set(c, push(i, t));\n        } else {\n          runEachAndClear(i);\n          s.delete(c);\n        }\n      }));\n    }\n  };\n  if (o) {\n    s = new WeakMap();\n    updateElements();\n  }\n  return [destroy, updateElements];\n};\nconst createDOMObserver = (t, n, o, s) => {\n  let e = false;\n  const {\n    Ht: c,\n    Mt: r,\n    Pt: i,\n    Dt: a,\n    Rt: u,\n    kt: d\n  } = s || {};\n  const f = debounce(() => {\n    if (e) {\n      o(true);\n    }\n  }, {\n    g: 33,\n    v: 99\n  });\n  const [_, h] = createEventContentChange(t, f, i);\n  const g = c || [];\n  const v = r || [];\n  const w = g.concat(v);\n  const observerCallback = (e, c) => {\n    const r = u || noop;\n    const i = d || noop;\n    const l = new Set();\n    const f = new Set();\n    let _ = false;\n    let g = false;\n    each(e, o => {\n      const {\n        attributeName: e,\n        target: c,\n        type: u,\n        oldValue: d,\n        addedNodes: h,\n        removedNodes: w\n      } = o;\n      const p = \"attributes\" === u;\n      const b = \"childList\" === u;\n      const m = t === c;\n      const y = p && isString(e) ? attr(c, e) : 0;\n      const S = 0 !== y && d !== y;\n      const x = indexOf(v, e) > -1 && S;\n      if (n && (b || !m)) {\n        const n = !p;\n        const u = p && S;\n        const f = u && a && is(c, a);\n        const _ = f ? !r(c, e, d, y) : n || u;\n        const v = _ && !i(o, !!f, t, s);\n        each(h, t => l.add(t));\n        each(w, t => l.add(t));\n        g = g || v;\n      }\n      if (!n && m && S && !r(c, e, d, y)) {\n        f.add(e);\n        _ = _ || x;\n      }\n    });\n    if (l.size > 0) {\n      h(t => from(l).reduce((n, o) => {\n        push(n, find(t, o));\n        return is(o, t) ? push(n, o) : n;\n      }, []));\n    }\n    if (n) {\n      !c && g && o(false);\n      return [false];\n    }\n    if (f.size > 0 || _) {\n      const t = [from(f), _];\n      !c && o.apply(0, t);\n      return t;\n    }\n  };\n  const p = new l(t => observerCallback(t));\n  p.observe(t, {\n    attributes: true,\n    attributeOldValue: true,\n    attributeFilter: w,\n    subtree: n,\n    childList: n,\n    characterData: n\n  });\n  e = true;\n  return [() => {\n    if (e) {\n      _();\n      p.disconnect();\n      e = false;\n    }\n  }, () => {\n    if (e) {\n      f.m();\n      const t = p.takeRecords();\n      return !isEmptyArray(t) && observerCallback(t, true);\n    }\n  }];\n};\nconst Bt = 3333333;\nconst domRectHasDimensions = t => t && (t.height || t.width);\nconst createSizeObserver = (t, n, o) => {\n  const {\n    Bt: s = false,\n    Vt: e = false\n  } = o || {};\n  const c = getPlugins()[bt];\n  const {\n    B: r\n  } = getEnvironment();\n  const i = createDOM(`<div class=\"${B}\"><div class=\"${Y}\"></div></div>`);\n  const l = i[0];\n  const a = l.firstChild;\n  const d = directionIsRTL.bind(0, t);\n  const [f] = createCache({\n    o: void 0,\n    _: true,\n    u: (t, n) => !(!t || !domRectHasDimensions(t) && domRectHasDimensions(n))\n  });\n  const onSizeChangedCallbackProxy = t => {\n    const o = isArray(t) && t.length > 0 && isObject(t[0]);\n    const e = !o && isBoolean(t[0]);\n    let c = false;\n    let i = false;\n    let a = true;\n    if (o) {\n      const [n,, o] = f(t.pop().contentRect);\n      const s = domRectHasDimensions(n);\n      const e = domRectHasDimensions(o);\n      c = !o || !s;\n      i = !e && s;\n      a = !c;\n    } else if (e) {\n      [, a] = t;\n    } else {\n      i = true === t;\n    }\n    if (s && a) {\n      const n = e ? t[0] : directionIsRTL(l);\n      scrollLeft(l, n ? r.n ? -Bt : r.i ? 0 : Bt : Bt);\n      scrollTop(l, Bt);\n    }\n    if (!c) {\n      n({\n        vt: !e,\n        Yt: e ? t : void 0,\n        Vt: !!i\n      });\n    }\n  };\n  const _ = [];\n  let h = e ? onSizeChangedCallbackProxy : false;\n  return [() => {\n    runEachAndClear(_);\n    removeElements(l);\n  }, () => {\n    if (u) {\n      const t = new u(onSizeChangedCallbackProxy);\n      t.observe(a);\n      push(_, () => {\n        t.disconnect();\n      });\n    } else if (c) {\n      const [t, n] = c.O(a, onSizeChangedCallbackProxy, e);\n      h = t;\n      push(_, n);\n    }\n    if (s) {\n      const [t] = createCache({\n        o: !d()\n      }, d);\n      push(_, on(l, \"scroll\", n => {\n        const o = t();\n        const [s, e] = o;\n        if (e) {\n          removeClass(a, \"ltr rtl\");\n          if (s) {\n            addClass(a, \"rtl\");\n          } else {\n            addClass(a, \"ltr\");\n          }\n          onSizeChangedCallbackProxy(o);\n        }\n        stopPropagation(n);\n      }));\n    }\n    if (h) {\n      addClass(l, V);\n      push(_, on(l, \"animationstart\", h, {\n        C: !!u\n      }));\n    }\n    if (u || c) {\n      appendChildren(t, l);\n    }\n  }];\n};\nconst isHeightIntrinsic = t => 0 === t.h || t.isIntersecting || t.intersectionRatio > 0;\nconst createTrinsicObserver = (t, n) => {\n  let o;\n  const s = createDiv(F);\n  const e = [];\n  const [c] = createCache({\n    o: false\n  });\n  const triggerOnTrinsicChangedCallback = (t, o) => {\n    if (t) {\n      const s = c(isHeightIntrinsic(t));\n      const [, e] = s;\n      if (e) {\n        !o && n(s);\n        return [s];\n      }\n    }\n  };\n  const intersectionObserverCallback = (t, n) => {\n    if (t && t.length > 0) {\n      return triggerOnTrinsicChangedCallback(t.pop(), n);\n    }\n  };\n  return [() => {\n    runEachAndClear(e);\n    removeElements(s);\n  }, () => {\n    if (a) {\n      o = new a(t => intersectionObserverCallback(t), {\n        root: t\n      });\n      o.observe(s);\n      push(e, () => {\n        o.disconnect();\n      });\n    } else {\n      const onSizeChanged = () => {\n        const t = offsetSize(s);\n        triggerOnTrinsicChangedCallback(t);\n      };\n      const [t, n] = createSizeObserver(s, onSizeChanged);\n      push(e, t);\n      n();\n      onSizeChanged();\n    }\n    appendChildren(t, s);\n  }, () => {\n    if (o) {\n      return intersectionObserverCallback(o.takeRecords(), true);\n    }\n  }];\n};\nconst Vt = `[${O}]`;\nconst Yt = `.${M}`;\nconst jt = [\"tabindex\"];\nconst Nt = [\"wrap\", \"cols\", \"rows\"];\nconst qt = [\"id\", \"class\", \"style\", \"open\"];\nconst createStructureSetupObservers = (t, n, o) => {\n  let s;\n  let e;\n  let c;\n  const {\n    Z: r,\n    J: i,\n    tt: l,\n    rt: a,\n    ut: d,\n    ft: f,\n    _t: _\n  } = t;\n  const {\n    V: h\n  } = getEnvironment();\n  const [g] = createCache({\n    u: equalWH,\n    o: {\n      w: 0,\n      h: 0\n    }\n  }, () => {\n    const t = f(k, I);\n    const n = f(P, \"\");\n    const o = n && scrollLeft(i);\n    const s = n && scrollTop(i);\n    _(k, I);\n    _(P, \"\");\n    _(\"\", L, true);\n    const e = scrollSize(l);\n    const c = scrollSize(i);\n    const r = fractionalSize(i);\n    _(k, I, t);\n    _(P, \"\", n);\n    _(\"\", L);\n    scrollLeft(i, o);\n    scrollTop(i, s);\n    return {\n      w: c.w + e.w + r.w,\n      h: c.h + e.h + r.h\n    };\n  });\n  const v = a ? Nt : qt.concat(Nt);\n  const w = debounce(o, {\n    g: () => s,\n    v: () => e,\n    p(t, n) {\n      const [o] = t;\n      const [s] = n;\n      return [keys(o).concat(keys(s)).reduce((t, n) => {\n        t[n] = o[n] || s[n];\n        return t;\n      }, {})];\n    }\n  });\n  const updateViewportAttrsFromHost = t => {\n    each(t || jt, t => {\n      if (indexOf(jt, t) > -1) {\n        const n = attr(r, t);\n        if (isString(n)) {\n          attr(i, t, n);\n        } else {\n          removeAttr(i, t);\n        }\n      }\n    });\n  };\n  const onTrinsicChanged = (t, s) => {\n    const [e, c] = t;\n    const r = {\n      gt: c\n    };\n    n({\n      ht: e\n    });\n    !s && o(r);\n    return r;\n  };\n  const onSizeChanged = _ref => {\n    let {\n      vt: t,\n      Yt: s,\n      Vt: e\n    } = _ref;\n    const c = !t || e ? o : w;\n    let r = false;\n    if (s) {\n      const [t, o] = s;\n      r = o;\n      n({\n        bt: t\n      });\n    }\n    c({\n      vt: t,\n      yt: r\n    });\n  };\n  const onContentMutation = (t, n) => {\n    const [, s] = g();\n    const e = {\n      wt: s\n    };\n    const c = t ? o : w;\n    if (s) {\n      !n && c(e);\n    }\n    return e;\n  };\n  const onHostMutation = (t, n, o) => {\n    const s = {\n      Ot: n\n    };\n    if (n) {\n      !o && w(s);\n    } else if (!d) {\n      updateViewportAttrsFromHost(t);\n    }\n    return s;\n  };\n  const [p, b, m] = l || !h ? createTrinsicObserver(r, onTrinsicChanged) : [noop, noop, noop];\n  const [y, S] = !d ? createSizeObserver(r, onSizeChanged, {\n    Vt: true,\n    Bt: true\n  }) : [noop, noop];\n  const [x, $] = createDOMObserver(r, false, onHostMutation, {\n    Mt: qt,\n    Ht: qt.concat(jt)\n  });\n  const C = d && u && new u(onSizeChanged.bind(0, {\n    vt: true\n  }));\n  C && C.observe(r);\n  updateViewportAttrsFromHost();\n  return [() => {\n    p();\n    y();\n    c && c[0]();\n    C && C.disconnect();\n    x();\n  }, () => {\n    S();\n    b();\n  }, () => {\n    const t = {};\n    const n = $();\n    const o = m();\n    const s = c && c[1]();\n    if (n) {\n      assignDeep(t, onHostMutation.apply(0, push(n, true)));\n    }\n    if (o) {\n      assignDeep(t, onTrinsicChanged.apply(0, push(o, true)));\n    }\n    if (s) {\n      assignDeep(t, onContentMutation.apply(0, push(s, true)));\n    }\n    return t;\n  }, t => {\n    const [n] = t(\"update.ignoreMutation\");\n    const [o, r] = t(\"update.attributes\");\n    const [a, u] = t(\"update.elementEvents\");\n    const [f, _] = t(\"update.debounce\");\n    const h = u || r;\n    const ignoreMutationFromOptions = t => isFunction(n) && n(t);\n    if (h) {\n      if (c) {\n        c[1]();\n        c[0]();\n      }\n      c = createDOMObserver(l || i, true, onContentMutation, {\n        Ht: v.concat(o || []),\n        Pt: a,\n        Dt: Vt,\n        kt: (t, n) => {\n          const {\n            target: o,\n            attributeName: s\n          } = t;\n          const e = !n && s && !d ? liesBetween(o, Vt, Yt) : false;\n          return e || !!closest(o, `.${X}`) || !!ignoreMutationFromOptions(t);\n        }\n      });\n    }\n    if (_) {\n      w.m();\n      if (isArray(f)) {\n        const t = f[0];\n        const n = f[1];\n        s = isNumber(t) && t;\n        e = isNumber(n) && n;\n      } else if (isNumber(f)) {\n        s = f;\n        e = false;\n      } else {\n        s = false;\n        e = false;\n      }\n    }\n  }];\n};\nconst Ft = {\n  x: 0,\n  y: 0\n};\nconst Gt = {\n  K: {\n    t: 0,\n    r: 0,\n    b: 0,\n    l: 0\n  },\n  St: false,\n  M: {\n    marginRight: 0,\n    marginBottom: 0,\n    marginLeft: 0,\n    paddingTop: 0,\n    paddingRight: 0,\n    paddingBottom: 0,\n    paddingLeft: 0\n  },\n  zt: Ft,\n  Tt: Ft,\n  Ct: {\n    x: \"hidden\",\n    y: \"hidden\"\n  },\n  Et: {\n    x: false,\n    y: false\n  },\n  ht: false,\n  bt: false\n};\nconst createStructureSetup = (t, n) => {\n  const o = createOptionCheck(n, {});\n  const s = createState(Gt);\n  const [e, c, r] = createEventListenerHub();\n  const [i, l] = s;\n  const [a, u, d] = createStructureSetupElements(t);\n  const f = createStructureSetupUpdate(a, s);\n  const triggerUpdateEvent = (t, n, o) => {\n    const s = keys(t).some(n => t[n]);\n    const e = s || !isEmptyObject(n) || o;\n    if (e) {\n      r(\"u\", [t, n, o]);\n    }\n    return e;\n  };\n  const [_, h, g, v] = createStructureSetupObservers(a, l, t => triggerUpdateEvent(f(o, t), {}, false));\n  const w = i.bind(0);\n  w.jt = t => e(\"u\", t);\n  w.Nt = () => {\n    const {\n      W: t,\n      J: n\n    } = a;\n    const o = scrollLeft(t);\n    const s = scrollTop(t);\n    h();\n    u();\n    scrollLeft(n, o);\n    scrollTop(n, s);\n  };\n  w.qt = a;\n  return [(t, o) => {\n    const s = createOptionCheck(n, t, o);\n    v(s);\n    return triggerUpdateEvent(f(s, g(), o), t, !!o);\n  }, w, () => {\n    c();\n    _();\n    d();\n  }];\n};\nconst {\n  round: Xt\n} = Math;\nconst getScale = t => {\n  const {\n    width: n,\n    height: o\n  } = getBoundingClientRect(t);\n  const {\n    w: s,\n    h: e\n  } = offsetSize(t);\n  return {\n    x: Xt(n) / s || 1,\n    y: Xt(o) / e || 1\n  };\n};\nconst continuePointerDown = (t, n, o) => {\n  const s = n.scrollbars;\n  const {\n    button: e,\n    isPrimary: c,\n    pointerType: r\n  } = t;\n  const {\n    pointers: i\n  } = s;\n  return 0 === e && c && s[o ? \"dragScroll\" : \"clickScroll\"] && (i || []).includes(r);\n};\nconst createRootClickStopPropagationEvents = (t, n) => on(t, \"mousedown\", on.bind(0, n, \"click\", stopPropagation, {\n  C: true,\n  $: true\n}), {\n  $: true\n});\nconst createInteractiveScrollEvents = (t, n, o, s, e, c) => {\n  const {\n    B: r\n  } = getEnvironment();\n  const {\n    Ft: i,\n    Gt: l,\n    Xt: a\n  } = o;\n  const u = `scroll${c ? \"Left\" : \"Top\"}`;\n  const d = `client${c ? \"X\" : \"Y\"}`;\n  const f = c ? \"width\" : \"height\";\n  const _ = c ? \"left\" : \"top\";\n  const h = c ? \"w\" : \"h\";\n  const g = c ? \"x\" : \"y\";\n  const createRelativeHandleMove = (t, n) => o => {\n    const {\n      Tt: d\n    } = e();\n    const f = offsetSize(l)[h] - offsetSize(i)[h];\n    const _ = n * o / f;\n    const v = _ * d[g];\n    const w = directionIsRTL(a);\n    const p = w && c ? r.n || r.i ? 1 : -1 : 1;\n    s[u] = t + v * p;\n  };\n  return on(l, \"pointerdown\", o => {\n    const e = closest(o.target, `.${K}`) === i;\n    if (continuePointerDown(o, t, e)) {\n      const t = !e && o.shiftKey;\n      const getHandleRect = () => getBoundingClientRect(i);\n      const getTrackRect = () => getBoundingClientRect(l);\n      const getHandleOffset = (t, n) => (t || getHandleRect())[_] - (n || getTrackRect())[_];\n      const c = createRelativeHandleMove(s[u] || 0, 1 / getScale(s)[g]);\n      const r = o[d];\n      const a = getHandleRect();\n      const h = getTrackRect();\n      const v = a[f];\n      const w = getHandleOffset(a, h) + v / 2;\n      const p = r - h[_];\n      const b = e ? 0 : p - w;\n      const m = [on(n, \"selectstart\", t => preventDefault(t), {\n        S: false\n      }), on(l, \"pointermove\", n => {\n        const o = n[d] - r;\n        if (e || t) {\n          c(b + o);\n        }\n      })];\n      if (t) {\n        c(b);\n      } else if (!e) {\n        const t = getPlugins()[Ot];\n        if (t) {\n          push(m, t.O(c, getHandleOffset, b, v, p));\n        }\n      }\n      on(l, \"pointerup\", t => {\n        runEachAndClear(m);\n        l.releasePointerCapture(t.pointerId);\n      }, {\n        C: true\n      });\n      l.setPointerCapture(o.pointerId);\n    }\n  });\n};\nconst createScrollbarsSetupEvents = (t, n) => (o, s, e, c, r, i) => {\n  const {\n    Xt: l\n  } = o;\n  const [a, u] = selfClearTimeout(333);\n  const d = !!r.scrollBy;\n  let f = true;\n  return runEachAndClear.bind(0, [on(l, \"pointerenter\", () => {\n    s(ot, true);\n  }), on(l, \"pointerleave pointercancel\", () => {\n    s(ot);\n  }), on(l, \"wheel\", t => {\n    const {\n      deltaX: n,\n      deltaY: o,\n      deltaMode: e\n    } = t;\n    if (d && f && 0 === e && parent(l) === c) {\n      r.scrollBy({\n        left: n,\n        top: o,\n        behavior: \"smooth\"\n      });\n    }\n    f = false;\n    s(ct, true);\n    a(() => {\n      f = true;\n      s(ct);\n    });\n    preventDefault(t);\n  }, {\n    S: false,\n    $: true\n  }), createRootClickStopPropagationEvents(l, e), createInteractiveScrollEvents(t, e, o, r, n, i), u]);\n};\nconst {\n  min: Ut,\n  max: Wt,\n  abs: Zt,\n  round: Jt\n} = Math;\nconst getScrollbarHandleLengthRatio = (t, n, o, s) => {\n  if (s) {\n    const t = o ? \"x\" : \"y\";\n    const {\n      Tt: n,\n      zt: e\n    } = s;\n    const c = e[t];\n    const r = n[t];\n    return Wt(0, Ut(1, c / (c + r)));\n  }\n  const e = o ? \"w\" : \"h\";\n  const c = offsetSize(t)[e];\n  const r = offsetSize(n)[e];\n  return Wt(0, Ut(1, c / r));\n};\nconst getScrollbarHandleOffsetRatio = (t, n, o, s, e, c) => {\n  const {\n    B: r\n  } = getEnvironment();\n  const i = c ? \"x\" : \"y\";\n  const l = c ? \"Left\" : \"Top\";\n  const {\n    Tt: a\n  } = s;\n  const u = Jt(a[i]);\n  const d = Zt(o[`scroll${l}`]);\n  const f = c && e;\n  const _ = r.i ? d : u - d;\n  const h = f ? _ : d;\n  const g = Ut(1, h / u);\n  const v = getScrollbarHandleLengthRatio(t, n, c);\n  return 1 / v * (1 - v) * g;\n};\nconst createScrollbarsSetupElements = (t, n, o) => {\n  const {\n    N: s\n  } = getEnvironment();\n  const {\n    scrollbars: e\n  } = s();\n  const {\n    slot: c\n  } = e;\n  const {\n    ct: r,\n    W: i,\n    Z: l,\n    J: a,\n    lt: u,\n    ot: d,\n    it: f,\n    ut: h\n  } = n;\n  const {\n    scrollbars: g\n  } = u ? {} : t;\n  const {\n    slot: v\n  } = g || {};\n  const w = dynamicInitializationElement([i, l, a], () => h && f ? i : l, c, v);\n  const scrollbarStructureAddRemoveClass = (t, n, o) => {\n    const s = o ? addClass : removeClass;\n    each(t, t => {\n      s(t.Xt, n);\n    });\n  };\n  const scrollbarsHandleStyle = (t, n) => {\n    each(t, t => {\n      const [o, s] = n(t);\n      style(o, s);\n    });\n  };\n  const scrollbarStructureRefreshHandleLength = (t, n, o) => {\n    scrollbarsHandleStyle(t, t => {\n      const {\n        Ft: s,\n        Gt: e\n      } = t;\n      return [s, {\n        [o ? \"width\" : \"height\"]: `${(100 * getScrollbarHandleLengthRatio(s, e, o, n)).toFixed(3)}%`\n      }];\n    });\n  };\n  const scrollbarStructureRefreshHandleOffset = (t, n, o) => {\n    const s = o ? \"X\" : \"Y\";\n    scrollbarsHandleStyle(t, t => {\n      const {\n        Ft: e,\n        Gt: c,\n        Xt: r\n      } = t;\n      const i = getScrollbarHandleOffsetRatio(e, c, d, n, directionIsRTL(r), o);\n      const l = i === i;\n      return [e, {\n        transform: l ? `translate${s}(${(100 * i).toFixed(3)}%)` : \"\"\n      }];\n    });\n  };\n  const p = [];\n  const b = [];\n  const m = [];\n  const scrollbarsAddRemoveClass = (t, n, o) => {\n    const s = isBoolean(o);\n    const e = s ? o : true;\n    const c = s ? !o : true;\n    e && scrollbarStructureAddRemoveClass(b, t, n);\n    c && scrollbarStructureAddRemoveClass(m, t, n);\n  };\n  const refreshScrollbarsHandleLength = t => {\n    scrollbarStructureRefreshHandleLength(b, t, true);\n    scrollbarStructureRefreshHandleLength(m, t);\n  };\n  const refreshScrollbarsHandleOffset = t => {\n    scrollbarStructureRefreshHandleOffset(b, t, true);\n    scrollbarStructureRefreshHandleOffset(m, t);\n  };\n  const generateScrollbarDOM = t => {\n    const n = t ? W : Z;\n    const s = t ? b : m;\n    const e = isEmptyArray(s) ? nt : \"\";\n    const c = createDiv(`${X} ${n} ${e}`);\n    const i = createDiv(J);\n    const a = createDiv(K);\n    const u = {\n      Xt: c,\n      Gt: i,\n      Ft: a\n    };\n    appendChildren(c, i);\n    appendChildren(i, a);\n    push(s, u);\n    push(p, [removeElements.bind(0, c), o(u, scrollbarsAddRemoveClass, r, l, d, t)]);\n    return u;\n  };\n  const y = generateScrollbarDOM.bind(0, true);\n  const S = generateScrollbarDOM.bind(0, false);\n  const appendElements = () => {\n    appendChildren(w, b[0].Xt);\n    appendChildren(w, m[0].Xt);\n    _(() => {\n      scrollbarsAddRemoveClass(nt);\n    }, 300);\n  };\n  y();\n  S();\n  return [{\n    Ut: refreshScrollbarsHandleLength,\n    Wt: refreshScrollbarsHandleOffset,\n    Zt: scrollbarsAddRemoveClass,\n    Jt: {\n      Kt: b,\n      Qt: y,\n      tn: scrollbarsHandleStyle.bind(0, b)\n    },\n    nn: {\n      Kt: m,\n      Qt: S,\n      tn: scrollbarsHandleStyle.bind(0, m)\n    }\n  }, appendElements, runEachAndClear.bind(0, p)];\n};\nconst createScrollbarsSetup = (t, n, o, s) => {\n  let e;\n  let c;\n  let r;\n  let i;\n  let l;\n  let a = 0;\n  const u = createState({});\n  const [d] = u;\n  const [f, _] = selfClearTimeout();\n  const [h, g] = selfClearTimeout();\n  const [v, w] = selfClearTimeout(100);\n  const [p, b] = selfClearTimeout(100);\n  const [m, y] = selfClearTimeout(() => a);\n  const [S, x, $] = createScrollbarsSetupElements(t, o.qt, createScrollbarsSetupEvents(n, o));\n  const {\n    Z: C,\n    J: O,\n    ot: z,\n    st: T,\n    ut: E,\n    it: I\n  } = o.qt;\n  const {\n    Jt: A,\n    nn: L,\n    Zt: H,\n    Ut: M,\n    Wt: P\n  } = S;\n  const {\n    tn: D\n  } = A;\n  const {\n    tn: R\n  } = L;\n  const styleScrollbarPosition = t => {\n    const {\n      Xt: n\n    } = t;\n    const o = E && !I && parent(n) === O && n;\n    return [o, {\n      transform: o ? `translate(${scrollLeft(z)}px, ${scrollTop(z)}px)` : \"\"\n    }];\n  };\n  const manageScrollbarsAutoHide = (t, n) => {\n    y();\n    if (t) {\n      H(et);\n    } else {\n      const hide = () => H(et, true);\n      if (a > 0 && !n) {\n        m(hide);\n      } else {\n        hide();\n      }\n    }\n  };\n  const onHostMouseEnter = () => {\n    i = c;\n    i && manageScrollbarsAutoHide(true);\n  };\n  const k = [w, y, b, g, _, $, on(C, \"pointerover\", onHostMouseEnter, {\n    C: true\n  }), on(C, \"pointerenter\", onHostMouseEnter), on(C, \"pointerleave\", () => {\n    i = false;\n    c && manageScrollbarsAutoHide(false);\n  }), on(C, \"pointermove\", () => {\n    e && f(() => {\n      w();\n      manageScrollbarsAutoHide(true);\n      p(() => {\n        e && manageScrollbarsAutoHide(false);\n      });\n    });\n  }), on(T, \"scroll\", t => {\n    h(() => {\n      P(o());\n      r && manageScrollbarsAutoHide(true);\n      v(() => {\n        r && !i && manageScrollbarsAutoHide(false);\n      });\n    });\n    s(t);\n    E && D(styleScrollbarPosition);\n    E && R(styleScrollbarPosition);\n  })];\n  const B = d.bind(0);\n  B.qt = S;\n  B.Nt = x;\n  return [(t, s, i) => {\n    const {\n      At: u,\n      Lt: d,\n      It: f,\n      yt: _\n    } = i;\n    const {\n      A: h\n    } = getEnvironment();\n    const g = createOptionCheck(n, t, s);\n    const v = o();\n    const {\n      Tt: w,\n      Ct: p,\n      bt: b\n    } = v;\n    const [m, y] = g(\"showNativeOverlaidScrollbars\");\n    const [S, x] = g(\"scrollbars.theme\");\n    const [$, C] = g(\"scrollbars.visibility\");\n    const [O, z] = g(\"scrollbars.autoHide\");\n    const [T] = g(\"scrollbars.autoHideDelay\");\n    const [E, A] = g(\"scrollbars.dragScroll\");\n    const [L, D] = g(\"scrollbars.clickScroll\");\n    const R = u || d || _;\n    const k = f || C;\n    const B = m && h.x && h.y;\n    const setScrollbarVisibility = (t, n) => {\n      const o = \"visible\" === $ || \"auto\" === $ && \"scroll\" === t;\n      H(Q, o, n);\n      return o;\n    };\n    a = T;\n    if (y) {\n      H(G, B);\n    }\n    if (x) {\n      H(l);\n      H(S, true);\n      l = S;\n    }\n    if (z) {\n      e = \"move\" === O;\n      c = \"leave\" === O;\n      r = \"never\" !== O;\n      manageScrollbarsAutoHide(!r, true);\n    }\n    if (A) {\n      H(it, E);\n    }\n    if (D) {\n      H(rt, L);\n    }\n    if (k) {\n      const t = setScrollbarVisibility(p.x, true);\n      const n = setScrollbarVisibility(p.y, false);\n      const o = t && n;\n      H(tt, !o);\n    }\n    if (R) {\n      M(v);\n      P(v);\n      H(st, !w.x, true);\n      H(st, !w.y, false);\n      H(U, b && !I);\n    }\n  }, B, runEachAndClear.bind(0, k)];\n};\nconst invokePluginInstance = (t, n, o) => {\n  if (isFunction(t)) {\n    t(n || void 0, o || void 0);\n  }\n};\nconst OverlayScrollbars = (t, n, o) => {\n  const {\n    F: s,\n    N: e,\n    Y: c,\n    j: r\n  } = getEnvironment();\n  const i = getPlugins();\n  const l = isHTMLElement(t);\n  const a = l ? t : t.target;\n  const u = getInstance(a);\n  if (n && !u) {\n    let u = false;\n    const validateOptions = t => {\n      const n = getPlugins()[vt];\n      const o = n && n.O;\n      return o ? o(t, true) : t;\n    };\n    const d = assignDeep({}, s(), validateOptions(n));\n    const [f, _, h] = createEventListenerHub(o);\n    const [g, v, w] = createStructureSetup(t, d);\n    const [p, b, m] = createScrollbarsSetup(t, d, v, t => h(\"scroll\", [$, t]));\n    const update = (t, n) => g(t, !!n);\n    const y = update.bind(0, {}, true);\n    const S = c(y);\n    const x = r(y);\n    const destroy = t => {\n      removeInstance(a);\n      S();\n      x();\n      m();\n      w();\n      u = true;\n      h(\"destroyed\", [$, !!t]);\n      _();\n    };\n    const $ = {\n      options(t, n) {\n        if (t) {\n          const o = n ? s() : {};\n          const e = getOptionsDiff(d, assignDeep(o, validateOptions(t)));\n          if (!isEmptyObject(e)) {\n            assignDeep(d, e);\n            update(e);\n          }\n        }\n        return assignDeep({}, d);\n      },\n      on: f,\n      off: (t, n) => {\n        t && n && _(t, n);\n      },\n      state() {\n        const {\n          zt: t,\n          Tt: n,\n          Ct: o,\n          Et: s,\n          K: e,\n          St: c,\n          bt: r\n        } = v();\n        return assignDeep({}, {\n          overflowEdge: t,\n          overflowAmount: n,\n          overflowStyle: o,\n          hasOverflow: s,\n          padding: e,\n          paddingAbsolute: c,\n          directionRTL: r,\n          destroyed: u\n        });\n      },\n      elements() {\n        const {\n          W: t,\n          Z: n,\n          K: o,\n          J: s,\n          tt: e,\n          ot: c,\n          st: r\n        } = v.qt;\n        const {\n          Jt: i,\n          nn: l\n        } = b.qt;\n        const translateScrollbarStructure = t => {\n          const {\n            Ft: n,\n            Gt: o,\n            Xt: s\n          } = t;\n          return {\n            scrollbar: s,\n            track: o,\n            handle: n\n          };\n        };\n        const translateScrollbarsSetupElement = t => {\n          const {\n            Kt: n,\n            Qt: o\n          } = t;\n          const s = translateScrollbarStructure(n[0]);\n          return assignDeep({}, s, {\n            clone: () => {\n              const t = translateScrollbarStructure(o());\n              p({}, true, {});\n              return t;\n            }\n          });\n        };\n        return assignDeep({}, {\n          target: t,\n          host: n,\n          padding: o || s,\n          viewport: s,\n          content: e || s,\n          scrollOffsetElement: c,\n          scrollEventElement: r,\n          scrollbarHorizontal: translateScrollbarsSetupElement(i),\n          scrollbarVertical: translateScrollbarsSetupElement(l)\n        });\n      },\n      update: t => update({}, t),\n      destroy: destroy.bind(0)\n    };\n    v.jt((t, n, o) => {\n      p(n, o, t);\n    });\n    addInstance(a, $);\n    each(keys(i), t => invokePluginInstance(i[t], 0, $));\n    if (cancelInitialization(v.qt.it, e().cancel, !l && t.cancel)) {\n      destroy(true);\n      return $;\n    }\n    v.Nt();\n    b.Nt();\n    h(\"initialized\", [$]);\n    v.jt((t, n, o) => {\n      const {\n        vt: s,\n        yt: e,\n        gt: c,\n        At: r,\n        Lt: i,\n        It: l,\n        wt: a,\n        Ot: u\n      } = t;\n      h(\"updated\", [$, {\n        updateHints: {\n          sizeChanged: s,\n          directionChanged: e,\n          heightIntrinsicChanged: c,\n          overflowEdgeChanged: r,\n          overflowAmountChanged: i,\n          overflowStyleChanged: l,\n          contentMutation: a,\n          hostMutation: u\n        },\n        changedOptions: n,\n        force: o\n      }]);\n    });\n    $.update(true);\n    return $;\n  }\n  return u;\n};\nOverlayScrollbars.plugin = t => {\n  each(addPlugin(t), t => invokePluginInstance(t, OverlayScrollbars));\n};\nOverlayScrollbars.valid = t => {\n  const n = t && t.elements;\n  const o = isFunction(n) && n();\n  return isPlainObject(o) && !!getInstance(o.target);\n};\nOverlayScrollbars.env = () => {\n  const {\n    k: t,\n    A: n,\n    I: o,\n    B: s,\n    V: e,\n    L: c,\n    X: r,\n    U: i,\n    N: l,\n    q: a,\n    F: u,\n    G: d\n  } = getEnvironment();\n  return assignDeep({}, {\n    scrollbarsSize: t,\n    scrollbarsOverlaid: n,\n    scrollbarsHiding: o,\n    rtlScrollBehavior: s,\n    flexboxGlue: e,\n    cssCustomProperties: c,\n    staticDefaultInitialization: r,\n    staticDefaultOptions: i,\n    getDefaultInitialization: l,\n    setDefaultInitialization: a,\n    getDefaultOptions: u,\n    setDefaultOptions: d\n  });\n};\nexport { zt as ClickScrollPlugin, OverlayScrollbars, Ct as ScrollbarsHidingPlugin, mt as SizeObserverPlugin };","map":{"version":3,"mappings":"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","names":["source","callback","isArrayLike","i","length","each","Object","keys","key","elm","styles","getSingleStyle","isString","getStyles","isArray","getStylesResult","computedStyle","window","getComputedStyle","getCSSVal","reduce","result","setCSSVal","createCache","options","update","o","_initialValue","u","_equal","_","_alwaysUpdateValues","_value","_previous","cacheUpdateContextual","newValue","force","curr","newVal","changed","cacheUpdateIsolated","getCurrentCache","isClient","ElementNodeType","Node","ELEMENT_NODE","toString","hasOwnProperty","prototype","isUndefined","obj","undefined","isNull","type","call","replace","toLowerCase","isNumber","isBoolean","isFunction","Array","isObject","lengthCorrectFormat","isPlainObject","cstr","ctor","ctorProto","hasOwnConstructor","hasIsPrototypeOf","isHTMLElement","instanceofObj","HTMLElement","nodeType","isElement","Element","indexOf","arr","item","fromIndex","push","array","items","arrayIsSingleItem","apply","from","original","Set","forEach","value","isEmptyArray","runEachAndClear","args","keep","runFn","fn","prop","assignDeep","target","object1","object2","object3","object4","object5","object6","sources","copy","copyIsArray","src","clone","isEmptyObject","name","getSetProp","topLeft","fallback","attr","attrName","getAttribute","setAttribute","attrClass","add","currValues","currValuesSet","split","join","trim","hasAttrClass","has","removeAttr","removeAttribute","scrollLeft","scrollTop","getElmPrototype","find","selector","rootElm","document","querySelectorAll","findFirst","querySelector","is","matches","msMatchesSelector","contents","childNodes","parent","parentElement","closest","closestFn","liesBetween","highBoundarySelector","deepBoundarySelector","closestHighBoundaryElm","closestDeepBoundaryElm","deepBoundaryIsValid","before","parentElm","preferredAnchor","insertedElms","anchor","fragment","createDocumentFragment","insertedElm","previousSibling","appendChild","firstChild","nextSibling","insertBefore","appendChildren","node","children","insertedNodes","insertAfter","removeElements","nodes","e","removeChild","createDiv","classNames","div","createElement","createDOM","html","createdDiv","innerHTML","firstLetterToUpper","str","charAt","toUpperCase","slice","getDummyStyle","style","cssPrefixes","jsPrefixes","jsCache","cssCache","cssProperty","uppercasedName","elmStyle","prefix","prefixWithoutDashes","resultPossibilities","resultPossibility","jsAPI","MutationObserverConstructor","IntersectionObserverConstructor","ResizeObserverConstructor","cAF","rAF","setT","setTimeout","clearT","clearTimeout","equal","a","b","props","propMutation","compareA","compareB","equalWH","equalXY","equalTRBL","equalBCRWH","round","Math","noop","selfClearTimeout","timeout","id","setTFn","clearTFn","debounce","functionToDebounce","maxTimeoutId","prevArguments","latestArguments","clear","g","_timeout","v","_maxDelay","p","_mergeParams","invokeFunctionToDebounce","this","mergeParms","flush","debouncedFn","arguments","finalTimeout","hasTimeout","finalMaxWait","hasMaxWait","setTimeoutFn","clearTimeoutFn","mergeParamsResult","invokedArgs","boundInvoke","bind","timeoutId","_flush","max","animationCurrentTime","performance","now","animateNumber","to","duration","onFrame","easing","animationFrameId","timeStart","finalDuration","frame","complete","timeNow","timeElapsed","stopAnimation","percent","progress","animationCompleted","rnothtmlwhite","classListAction","className","action","classList","clazz","classes","match","hasClass","contains","removeClass","remove","addClass","cssNumber","opacity","zindex","parseToZeroOrNumber","toFloat","num","parseFloat","parseInt","adaptCSSVal","val","getPropertyValue","setProperty","directionIsRTL","topRightBottomLeft","propertyPrefix","propertySuffix","finalPrefix","finalSuffix","top","right","bottom","left","t","r","l","zeroObj","w","h","windowSize","innerWidth","innerHeight","offsetSize","offsetWidth","offsetHeight","clientSize","clientWidth","clientHeight","scrollSize","scrollWidth","scrollHeight","fractionalSize","cssHeight","cssWidth","getBoundingClientRect","passiveEventsSupport","supportPassiveEvents","addEventListener","defineProperty","get","splitEventNames","eventNames","off","listener","capture","eventName","removeEventListener","on","doSupportPassiveEvents","passive","_passive","_ref","_capture","once","_once","offListeners","nativeOptions","finalListener","evt","stopPropagation","preventDefault","x","y","absoluteCoordinates","rect","pageYOffset","pageXOffset","manageListener","createEventListenerHub","initialEventListeners","events","Map","removeEvent","eventSet","currListener","addEvent","nameOrEventListeners","listenerOrPure","set","eventListenerKeys","offFns","eventListener","triggerEvent","event","opsStringify","JSON","stringify","Error","defaultOptions","paddingAbsolute","showNativeOverlaidScrollbars","elementEvents","attributes","ignoreMutation","overflow","scrollbars","theme","visibility","autoHide","autoHideDelay","dragScroll","clickScroll","pointers","getOptionsDiff","currOptions","newOptions","diff","optionsKeys","concat","optionKey","currOptionValue","newOptionValue","isDiff","classNameEnvironment","classNameEnvironmentFlexboxGlue","classNameEnvironmentFlexboxGlueMax","dataAttributeHost","dataAttributeInitialize","dataAttributeHostOverflowX","dataAttributeHostOverflowY","dataValueHostOverflowVisible","dataValueHostScrollbarHidden","dataValueHostUpdating","classNamePadding","classNameViewport","classNameViewportArrange","classNameContent","classNameViewportScrollbarHidden","classNameOverflowVisible","classNameSizeObserver","classNameSizeObserverAppear","classNameSizeObserverListener","classNameSizeObserverListenerScroll","classNameSizeObserverListenerItem","classNameSizeObserverListenerItemFinal","classNameTrinsicObserver","classNameScrollbarThemeNone","classNameScrollbar","classNameScrollbarRtl","classNameScrollbarHorizontal","classNameScrollbarVertical","classNameScrollbarTrack","classNameScrollbarHandle","classNameScrollbarVisible","classNameScrollbarCornerless","classNameScrollbarTransitionless","classNameScrollbarInteraction","classNameScrollbarUnusable","classNameScrollbarAutoHidden","classNameScrollbarWheel","classNameScrollbarTrackInteractive","classNameScrollbarHandleInteractive","pluginRegistry","getPlugins","addPlugin","addedPlugin","plugin","pluginNameKeys","optionsTemplateTypes","boolean","number","string","object","function","null","numberAllowedValues","oTypes","booleanAllowedValues","arrayNullValues","overflowAllowedValues","scrollbarsVisibilityAllowedValues","scrollbarsAutoHideAllowedValues","optionsValidationPluginName","scrollAmount","scrollEventName","sizeObserverPluginName","SizeObserverPlugin","listenerElement","onSizeChangedCallback","observeAppearChange","observerElementChildren","observerElementChildrenRoot","shrinkElement","lastChild","expandElement","expandElementChild","cacheSize","currSize","isDirty","rAFId","reset","onResized","appear","onScroll","scrollEvent","width","height","contentArrangeCounter","abs","getWindowDPR","dDPI","screen","deviceXDPI","sDPI","logicalXDPI","devicePixelRatio","diffBiggerThanOne","valOne","valTwo","absValOne","absValTwo","scrollbarsHidingPluginName","ScrollbarsHidingPlugin","_createUniqueViewportArrangeElement","env","I","_nativeScrollbarsHiding","A","_nativeScrollbarsOverlaid","L","_cssCustomProperties","create","_overflowUpdateSegment","doViewportArrange","flexboxGlue","viewport","viewportArrange","getState","getViewportOverflowState","hideNativeScrollbars","arrangeViewport","viewportOverflowState","viewportScrollSize","sizeFraction","M","_viewportPaddingStyle","P","_scrollbarsHideOffset","D","_scrollbarsHideOffsetArrange","arrangeX","arrangeY","hideOffsetX","hideOffsetY","viewportArrangeHorizontalPaddingKey","viewportArrangeHorizontalPaddingValue","viewportArrangeVerticalPaddingValue","paddingTop","fractionalContentWidth","fractionalContenHeight","arrangeSize","sheet","cssRules","insertRule","ruleStyle","undoViewportArrange","finalViewportOverflowState","viewportPaddingStyle","finalPaddingStyle","assignProps","prevStyle","_envWindowZoom","size","dpr","envInstance","updateNativeScrollbarSizeCache","sizeNew","deltaSize","deltaAbsSize","deltaAbsRatio","dprNew","deltaIsBigger","difference","dprChanged","isZoom","scrollbarSize","scrollbarSizeChanged","_nativeScrollbarsSize","clickScrollPluginName","ClickScrollPlugin","moveHandleRelative","getHandleOffset","startOffset","handleLength","relativeTrackPointerOffset","iteration","animateClickScroll","clickScrollProgress","sign","animationProgress","handleStartBound","handleEndBound","mouseBetweenHandleBounds","firstIterationPauseTimeout","environmentInstance","getNativeScrollbarSize","body","measureElm","measureElmChild","cSize","oSize","fSize","getNativeScrollbarsHiding","testElm","revertClass","ex","getRtlScrollBehavior","childElm","strHidden","overflowX","overflowY","direction","parentOffset","childOffset","childOffsetAfterScroll","n","getFlexboxGlue","revertFbxGlue","minOffsetsizeParent","minOffsetsize","supportsMin","revertFbxGlueMax","maxOffsetsizeParent","maxOffsetsize","supportsMax","createEnvironment","envDOM","envElm","envChildElm","getNativeScrollbarSizeCache","nativeScrollbarsSize","nativeScrollbarsHiding","nativeScrollbarsOverlaid","staticDefaultInitialization","elements","host","padding","ownerDocument","content","slot","cancel","staticDefaultOptions","getDefaultOptions","getDefaultInitialization","_rtlScrollBehavior","_flexboxGlue","_addZoomListener","_addResizeListener","_getDefaultInitialization","_setDefaultInitialization","newInitializationStrategy","_getDefaultOptions","_setDefaultOptions","newDefaultOptions","_staticDefaultInitialization","_staticDefaultOptions","windowAddEventListener","debouncedWindowResize","zoom","resizeFn","scrollbarsHidingPlugin","getEnvironment","resolveInitialization","staticInitializationElement","fallbackStaticInitializationElement","defaultStaticInitializationElement","staticInitializationElementValue","staticInitialization","resolvedInitialization","dynamicInitializationElement","fallbackDynamicInitializationElement","defaultDynamicInitializationElement","dynamicInitializationElementValue","dynamicInitialization","cancelInitialization","isBody","defaultCancelInitialization","cancelInitializationValue","defaultNativeScrollbarsOverlaid","defaultbody","resolvedNativeScrollbarsOverlaid","resolvedDocumentScrollingElement","finalNativeScrollbarsOverlaid","finalDocumentScrollingElement","targetInstanceMap","WeakMap","addInstance","osInstance","removeInstance","delete","getInstance","getPropByPath","path","createOptionCheck","changedOptions","createState","initialState","state","newState","tabIndexStr","createNewDiv","unwrap","createStructureSetupElements","N","createUniqueViewportArrangeElement","defaultInitElements","defaultHostInitialization","defaultPaddingInitialization","defaultViewportInitialization","defaultContentInitialization","targetIsElm","targetStructureInitialization","initElements","hostInitialization","paddingInitialization","viewportInitialization","contentInitialization","targetElement","isTextarea","docElement","documentElement","wnd","defaultView","generalStaticInitializationElement","generalDynamicInitializationElement","generalResolveInitialization","generateViewportElement","generateContentElement","possibleViewportElement","viewportIsTarget","viewportIsTargetBody","possibleContentElement","viewportIsContent","defaultContentElementPresent","viewportIstContentViewport","viewportIsContentContent","nonBodyViewportElement","viewportElement","nonBodyHostElement","hostElement","contentElement","activeElm","activeElement","setViewportFocus","evaluatedTargetObj","_target","_host","_viewport","_padding","_content","_viewportArrange","_scrollOffsetElement","_scrollEventElement","_windowElm","_documentElm","_isTextarea","_isBody","_targetIsElm","_viewportIsTarget","_viewportIsContent","_viewportHasClass","attributeClassName","_viewportAddRemoveClass","generatedElements","elementIsGenerated","W","Z","K","J","tt","nt","destroyFns","isTextareaHostGenerated","targetContents","contentSlot","appendElements","removePaddingClass","removeViewportClass","removeContentClass","removeHtmlClass","ogTabindex","focus","revertViewportTabIndex","createTrinsicUpdateSegment","structureSetupElements","updateHints","V","ht","_heightIntrinsic","gt","_heightIntrinsicChanged","heightIntrinsicChanged","_sizeChanged","_contentMutation","createPaddingUpdateSegment","setState","_isSingleElm","updatePaddingCache","currentPaddingCache","checkOption","paddingChanged","_nativeScrollbarStyling","bt","_directionIsRTL","vt","wt","yt","_directionChanged","paddingAbsoluteChanged","contentMutation","paddingStyleChanged","paddingRelative","paddingHorizontal","paddingVertical","paddingStyle","marginRight","marginBottom","marginLeft","viewportStyle","paddingRight","paddingBottom","paddingLeft","_paddingAbsolute","_paddingStyleChanged","max0","strVisible","overlaidScrollbarsHideOffset","whCacheOptions","xyCacheOptions","getOverflowAmount","viewportClientSize","tollerance","amount","conditionalClass","overflowIsVisible","overflowBehavior","createOverflowUpdateSegment","ut","_t","it","et","k","updateSizeFraction","getCurrentSizeFraction","updateViewportScrollSizeCache","getCurrentViewportScrollSizeCache","updateOverflowAmountCache","getCurrentOverflowAmountCache","updateOverflowEdge","getCurrentOverflowEdgeCache","updateOverflowStyleCache","fixFlexboxGlue","heightIntrinsic","St","$t","_overflowScroll","hostClientSize","isContentBox","subtractXScrollbar","viewportStyleObj","arrangeHideOffset","getStatePerAxis","styleKey","isOverlaid","nativeScrollbarSize","overflowStyle","objectPrefferedOverflowStyle","overflowScroll","nonScrollbarStylingHideOffset","scrollbarsHideOffset","scrollbarsHideOffsetArrange","xOverflowStyle","xOverflowScroll","xScrollbarsHideOffset","xScrollbarsHideOffsetArrange","yOverflowStyle","yOverflowScroll","yScrollbarsHideOffset","yScrollbarsHideOffsetArrange","_overflowStyle","setViewportOverflowState","hasOverflow","overflowOption","setAxisOverflowStyle","behavior","hasOverflowAxis","overflowVisible","overflowVisibleBehavior","visibleBehaviorX","visibleBehaviorY","horizontalMarginKey","viewportHorizontalPaddingKey","horizontalMarginValue","verticalMarginValue","horizontalPaddingValue","verticalPaddingValue","Ot","_hostMutation","xt","showNativeOverlaidScrollbarsOption","showNativeOverlaidScrollbarsChanged","overflowChanged","adjustFlexboxGlue","overflowXVisible","overflowYVisible","sizeFractionCache","viewportScrollSizeCache","overflowAmuntCache","overflowEdgeCache","preMeasureViewportOverflowState","redoViewportArrange","undoViewportArrangeOverflowState","sizeFractionChanged","viewportScrollSizeChanged","viewportclientSize","arrangedViewportScrollSize","arrangedViewportClientSize","overflowAmountScrollSize","overflowAmountClientSize","overflowEdge","overflowEdgeChanged","overflowAmount","overflowAmountChanged","removeClipping","viewportArranged","overflowStyleChanged","_overflowEdge","_overflowAmount","_hasOverflow","_overflowStyleChanged","_overflowEdgeChanged","_overflowAmountChanged","prepareUpdateHints","leading","adaptive","finalAdaptive","objKeys","leadingValue","adaptiveValue","createStructureSetupUpdate","updateSegments","initialUpdateHints","adjustScrollOffset","scrollOffsetX","scrollOffsetY","adaptivedUpdateHints","updateSegment","createEventContentChange","eventContentChange","map","destroyed","destroy","updateElements","getElements","eventElmList","entries","isTargetChild","createDOMObserver","isContentObserver","isConnected","Ht","_attributes","Mt","_styleChangingAttributes","Pt","_eventContentChange","Dt","_nestedTargetSelector","Rt","_ignoreTargetChange","kt","_ignoreContentChange","debouncedEventContentChange","destroyEventContentChange","updateEventContentChangeElements","finalAttributes","finalStyleChangingAttributes","observedAttributes","observerCallback","mutations","fromRecords","ignoreTargetChange","ignoreContentChange","totalChangedNodes","targetChangedAttrs","targetStyleChanged","contentChanged","mutation","attributeName","mutationTarget","oldValue","addedNodes","removedNodes","isAttributesType","isChildListType","targetIsMutationTarget","attributeValue","attributeChanged","styleChangingAttrChanged","notOnlyAttrChanged","contentAttrChanged","isNestedTarget","baseAssertion","contentFinalChanged","mutationObserver","observe","attributeOldValue","attributeFilter","subtree","childList","characterData","disconnect","records","takeRecords","domRectHasDimensions","createSizeObserver","_direction","observeDirectionChange","_appear","sizeObserverPlugin","rtlScrollBehavior","baseElements","sizeObserver","getIsDirectionRTL","updateResizeObserverContentRectCache","currVal","onSizeChangedCallbackProxy","sizeChangedContext","isResizeObserverCall","hasDirectionCache","skip","doDirectionScroll","currRContentRect","prevContentRect","pop","contentRect","hasDimensions","hadDimensions","rtl","_directionIsRTLCache","appearCallback","resizeObserverInstance","pluginAppearCallback","pluginOffListeners","updateDirectionIsRTLCache","directionIsRTLCacheValues","directionIsRTLCache","directionIsRTLCacheChanged","isHeightIntrinsic","ioEntryOrSize","isIntersecting","intersectionRatio","createTrinsicObserver","onTrinsicChangedCallback","intersectionObserverInstance","trinsicObserver","updateHeightIntrinsicCache","triggerOnTrinsicChangedCallback","updateValue","intersectionObserverCallback","root","onSizeChanged","newSize","destroySizeObserver","appendSizeObserver","hostSelector","viewportSelector","viewportAttrsFromTarget","baseStyleChangingAttrsTextarea","baseStyleChangingAttrs","createStructureSetupObservers","structureSetupUpdate","debounceTimeout","debounceMaxDelay","contentMutationObserver","rt","ft","updateContentSizeCache","hasOver","hasVpStyle","contentScroll","viewportScroll","fractional","contentMutationObserverAttr","structureSetupUpdateWithDebouncedAdaptiveUpdateHints","prev","prevObj","currObj","updateViewportAttrsFromHost","attribute","hostAttr","onTrinsicChanged","heightIntrinsicCache","updateFn","directionChanged","directionIsRTLChanged","onContentMutation","contentChangedThroughEvent","contentSizeChanged","onHostMutation","destroyTrinsicObserver","appendTrinsicObserver","updateTrinsicObserver","destroyHostMutationObserver","updateHostMutationObserver","viewportIsTargetResizeObserver","hostUpdateResult","trinsicUpdateResult","contentUpdateResult","attributesChanged","elementEventsChanged","debounceValue","debounceChanged","updateContentMutationObserver","ignoreMutationFromOptions","ignore","maxWait","initialXYNumber","initialStructureSetupUpdateState","createStructureSetup","checkOptionsFallback","appendStructureElements","destroyElements","updateStructure","triggerUpdateEvent","truthyUpdateHints","some","destroyObservers","appendObserverElements","updateObservers","updateObserversOptions","structureSetupState","_addOnUpdatedListener","_appendElements","initialScrollLeft","initialScrollTop","_elements","getScale","element","continuePointerDown","isDragScroll","scrollbarOptions","button","isPrimary","pointerType","includes","createRootClickStopPropagationEvents","scrollbar","documentElm","createInteractiveScrollEvents","doc","scrollbarStructure","scrollOffsetElement","isHorizontal","B","Ft","_handle","Gt","_track","Xt","_scrollbar","scrollLeftTopKey","clientXYKey","widthHeightKey","leftTopKey","whKey","xyKey","createRelativeHandleMove","mouseDownScroll","invertedScale","deltaMovement","Tt","handleTrackDiff","scrollDeltaPercent","scrollDelta","isRTL","negateMultiplactor","pointerDownEvent","instantClickScroll","shiftKey","getHandleRect","getTrackRect","handleRect","trackRect","pointerDownOffset","handleCenter","pointerMoveEvent","relativeMovement","pointerUpEvent","releasePointerCapture","pointerId","setPointerCapture","createScrollbarsSetupEvents","scrollbarsAddRemoveClass","hostElm","scrollOffsetElm","wheelTimeout","clearScrollTimeout","scrollByFn","scrollBy","wheelScrollBy","wheelEvent","deltaX","deltaY","deltaMode","min","getScrollbarHandleLengthRatio","scrollbarHandle","scrollbarTrack","axis","zt","viewportSize","handleSize","trackSize","getScrollbarHandleOffsetRatio","scrollLeftTop","scrollPositionMax","scrollPosition","handleRTL","rtlNormalizedScrollPosition","finalScrollPosition","scrollPercent","lengthRatio","createScrollbarsSetupElements","scrollbarsSetupEvents","defaultInitScrollbars","defaultInitScrollbarsSlot","ct","lt","ot","scrollbarsInit","initScrollbarsSlot","evaluatedScrollbarSlot","scrollbarStructureAddRemoveClass","scrollbarStructures","scrollbarsHandleStyle","scrollbarStructureRefreshHandleLength","structure","toFixed","scrollbarStructureRefreshHandleOffset","translateAxis","offsetRatio","validOffsetRatio","transform","horizontalScrollbars","verticalScrollbars","onlyHorizontal","singleAxis","runHorizontal","runVertical","refreshScrollbarsHandleLength","refreshScrollbarsHandleOffset","generateScrollbarDOM","scrollbarClassName","arrToPush","transitionlessClass","track","handle","generateHorizontalScrollbarStructure","generateVerticalScrollbarStructure","_refreshScrollbarsHandleLength","_refreshScrollbarsHandleOffset","_scrollbarsAddRemoveClass","_horizontal","_scrollbarStructures","_clone","_handleStyle","_vertical","createScrollbarsSetup","autoHideIsMove","autoHideIsLeave","autoHideNotNever","mouseInHost","prevTheme","globalAutoHideDelay","requestMouseMoveAnimationFrame","cancelMouseMoveAnimationFrame","requestScrollAnimationFrame","cancelScrollAnimationFrame","scrollTimeout","auotHideMoveTimeout","clearAutoHideTimeout","auotHideTimeout","clearAutoTimeout","st","Jt","nn","Zt","Ut","Wt","styleHorizontal","styleVertical","styleScrollbarPosition","manageScrollbarsAutoHide","removeAutoHide","delayless","hide","onHostMouseEnter","scrollbarsSetupState","structureUpdateHints","At","Lt","It","currStructureSetupState","Ct","themeChanged","visibilityChanged","autoHideChanged","dragScrollChanged","clickScrollChanged","updateHandle","updateVisibility","setScrollbarVisibility","isVisible","xVisible","yVisible","hasCorner","invokePluginInstance","pluginInstance","staticObj","instanceObj","OverlayScrollbars","eventListeners","F","Y","j","plugins","targetIsElement","instanceTarget","potentialInstance","validateOptions","optionsValidationPlugin","validate","currentOptions","structureState","destroyStructure","updateScrollbars","scrollbarsState","destroyScrollbars","instance","forceUpdate","removeZoomListener","removeResizeListener","canceled","pure","base","Et","directionRTL","translateScrollbarStructure","translateScrollbarsSetupElement","scrollbarsSetupElement","Kt","Qt","translatedStructure","scrollEventElement","scrollbarHorizontal","scrollbarVertical","pluginName","sizeChanged","hostMutation","valid","hasElmsFn","X","U","q","G","scrollbarsSize","scrollbarsOverlaid","scrollbarsHiding","cssCustomProperties","setDefaultInitialization","setDefaultOptions"],"sources":["/Users/salwajeries/repos/personal-site/personal-site/node_modules/src/support/utils/array.ts","/Users/salwajeries/repos/personal-site/personal-site/node_modules/src/support/dom/style.ts","/Users/salwajeries/repos/personal-site/personal-site/node_modules/src/support/cache.ts","/Users/salwajeries/repos/personal-site/personal-site/node_modules/src/support/compatibility/server.ts","/Users/salwajeries/repos/personal-site/personal-site/node_modules/src/support/utils/types.ts","/Users/salwajeries/repos/personal-site/personal-site/node_modules/src/support/utils/object.ts","/Users/salwajeries/repos/personal-site/personal-site/node_modules/src/support/dom/attribute.ts","/Users/salwajeries/repos/personal-site/personal-site/node_modules/src/support/dom/traversal.ts","/Users/salwajeries/repos/personal-site/personal-site/node_modules/src/support/dom/manipulation.ts","/Users/salwajeries/repos/personal-site/personal-site/node_modules/src/support/dom/create.ts","/Users/salwajeries/repos/personal-site/personal-site/node_modules/src/support/compatibility/vendors.ts","/Users/salwajeries/repos/personal-site/personal-site/node_modules/src/support/compatibility/apis.ts","/Users/salwajeries/repos/personal-site/personal-site/node_modules/src/support/utils/equal.ts","/Users/salwajeries/repos/personal-site/personal-site/node_modules/src/support/utils/function.ts","/Users/salwajeries/repos/personal-site/personal-site/node_modules/src/support/dom/animation.ts","/Users/salwajeries/repos/personal-site/personal-site/node_modules/src/support/dom/class.ts","/Users/salwajeries/repos/personal-site/personal-site/node_modules/src/support/dom/dimensions.ts","/Users/salwajeries/repos/personal-site/personal-site/node_modules/src/support/dom/events.ts","/Users/salwajeries/repos/personal-site/personal-site/node_modules/src/support/dom/offset.ts","/Users/salwajeries/repos/personal-site/personal-site/node_modules/src/support/eventListeners.ts","/Users/salwajeries/repos/personal-site/personal-site/node_modules/src/options.ts","/Users/salwajeries/repos/personal-site/personal-site/node_modules/src/classnames.ts","/Users/salwajeries/repos/personal-site/personal-site/node_modules/src/plugins/plugins.ts","/Users/salwajeries/repos/personal-site/personal-site/node_modules/src/plugins/optionsValidationPlugin/validation.ts","/Users/salwajeries/repos/personal-site/personal-site/node_modules/src/plugins/optionsValidationPlugin/optionsValidationPlugin.ts","/Users/salwajeries/repos/personal-site/personal-site/node_modules/src/plugins/sizeObserverPlugin/sizeObserverPlugin.ts","/Users/salwajeries/repos/personal-site/personal-site/node_modules/src/plugins/scrollbarsHidingPlugin/scrollbarsHidingPlugin.ts","/Users/salwajeries/repos/personal-site/personal-site/node_modules/src/plugins/clickScrollPlugin/clickScrollPlugin.ts","/Users/salwajeries/repos/personal-site/personal-site/node_modules/src/environment.ts","/Users/salwajeries/repos/personal-site/personal-site/node_modules/src/initialization.ts","/Users/salwajeries/repos/personal-site/personal-site/node_modules/src/instances.ts","/Users/salwajeries/repos/personal-site/personal-site/node_modules/src/setups/setups.ts","/Users/salwajeries/repos/personal-site/personal-site/node_modules/src/setups/structureSetup/structureSetup.elements.ts","/Users/salwajeries/repos/personal-site/personal-site/node_modules/src/setups/structureSetup/updateSegments/trinsicUpdateSegment.ts","/Users/salwajeries/repos/personal-site/personal-site/node_modules/src/setups/structureSetup/updateSegments/paddingUpdateSegment.ts","/Users/salwajeries/repos/personal-site/personal-site/node_modules/src/setups/structureSetup/updateSegments/overflowUpdateSegment.ts","/Users/salwajeries/repos/personal-site/personal-site/node_modules/src/setups/structureSetup/structureSetup.update.ts","/Users/salwajeries/repos/personal-site/personal-site/node_modules/src/observers/domObserver.ts","/Users/salwajeries/repos/personal-site/personal-site/node_modules/src/observers/sizeObserver.ts","/Users/salwajeries/repos/personal-site/personal-site/node_modules/src/observers/trinsicObserver.ts","/Users/salwajeries/repos/personal-site/personal-site/node_modules/src/setups/structureSetup/structureSetup.observers.ts","/Users/salwajeries/repos/personal-site/personal-site/node_modules/src/setups/structureSetup/structureSetup.ts","/Users/salwajeries/repos/personal-site/personal-site/node_modules/src/setups/scrollbarsSetup/scrollbarsSetup.events.ts","/Users/salwajeries/repos/personal-site/personal-site/node_modules/src/setups/scrollbarsSetup/scrollbarsSetup.calculations.ts","/Users/salwajeries/repos/personal-site/personal-site/node_modules/src/setups/scrollbarsSetup/scrollbarsSetup.elements.ts","/Users/salwajeries/repos/personal-site/personal-site/node_modules/src/setups/scrollbarsSetup/scrollbarsSetup.ts","/Users/salwajeries/repos/personal-site/personal-site/node_modules/src/overlayscrollbars.ts"],"sourcesContent":["import { isArrayLike, isString } from '~/support/utils/types';\nimport type { PlainObject } from '~/typings';\n\ntype RunEachItem = ((...args: any) => any | any[]) | null | undefined;\n\n/**\n * Iterates through a array or object\n * @param arrayLikeOrObject The array or object through which shall be iterated.\n * @param callback The function which is responsible for the iteration.\n * If the function returns true its treated like a \"continue\" statement.\n * If the function returns false its treated like a \"break\" statement.\n */\nexport function each<T>(\n  array: Array<T> | ReadonlyArray<T>,\n  callback: (value: T, indexOrKey: number, source: Array<T>) => boolean | unknown\n): Array<T> | ReadonlyArray<T>;\nexport function each<T>(\n  array: Array<T> | ReadonlyArray<T> | false | null | undefined,\n  callback: (value: T, indexOrKey: number, source: Array<T>) => boolean | unknown\n): Array<T> | ReadonlyArray<T> | false | null | undefined;\nexport function each<T>(\n  arrayLikeObject: ArrayLike<T>,\n  callback: (value: T, indexOrKey: number, source: ArrayLike<T>) => boolean | unknown\n): ArrayLike<T>;\nexport function each<T>(\n  arrayLikeObject: ArrayLike<T> | false | null | undefined,\n  callback: (value: T, indexOrKey: number, source: ArrayLike<T>) => boolean | unknown\n): ArrayLike<T> | false | null | undefined;\nexport function each(\n  obj: PlainObject,\n  callback: (value: any, indexOrKey: string, source: PlainObject) => boolean | unknown\n): PlainObject;\nexport function each(\n  obj: PlainObject | false | null | undefined,\n  callback: (value: any, indexOrKey: string, source: PlainObject) => boolean | unknown\n): PlainObject | false | null | undefined;\nexport function each<T>(\n  source: Array<T> | ArrayLike<T> | ReadonlyArray<T> | PlainObject | false | null | undefined,\n  callback: (value: T, indexOrKey: any, source: any) => boolean | unknown\n): Array<T> | ArrayLike<T> | ReadonlyArray<T> | PlainObject | false | null | undefined {\n  if (isArrayLike(source)) {\n    for (let i = 0; i < source.length; i++) {\n      if (callback(source[i], i, source) === false) {\n        break;\n      }\n    }\n  } else if (source) {\n    // cant use support func keys here due to circular dep\n    each(Object.keys(source), (key) => callback(source[key], key, source));\n  }\n  return source;\n}\n\n/**\n * Returns the index of the given inside the given array or -1 if the given item isn't part of the given array.\n * @param arr The array.\n * @param item The item.\n * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the search starts at index 0.\n */\nexport const indexOf = <T = any>(arr: T[], item: T, fromIndex?: number): number =>\n  arr.indexOf(item, fromIndex);\n\n/**\n * Pushesh all given items into the given array and returns it.\n * @param array The array the items shall be pushed into.\n * @param items The items which shall be pushed into the array.\n */\nexport const push = <T>(array: T[], items: T | ArrayLike<T>, arrayIsSingleItem?: boolean): T[] => {\n  !arrayIsSingleItem && !isString(items) && isArrayLike(items)\n    ? Array.prototype.push.apply(array, items as T[])\n    : array.push(items as T);\n  return array;\n};\n\n/**\n * Creates a shallow-copied Array instance from an array-like or iterable object.\n * @param arr The object from which the array instance shall be created.\n */\nexport const from = <T = any>(arr?: ArrayLike<T> | Set<T>) => {\n  const original = Array.from;\n  const result: T[] = [];\n\n  if (original && arr) {\n    return original(arr);\n  }\n\n  if (arr instanceof Set) {\n    arr.forEach((value) => {\n      push(result, value);\n    });\n  } else {\n    each(arr, (elm) => {\n      push(result, elm);\n    });\n  }\n\n  return result;\n};\n\n/**\n * Check whether the passed array is empty.\n * @param array The array which shall be checked.\n */\nexport const isEmptyArray = (array: any[] | null | undefined): boolean =>\n  !!array && array.length === 0;\n\n/**\n * Calls all functions in the passed array/set of functions.\n * @param arr The array filled with function which shall be called.\n * @param args The args with which each function is called.\n * @param keep True when the Set / array should not be cleared afterwards, false otherwise.\n */\nexport const runEachAndClear = (arr: RunEachItem[], args?: any[], keep?: boolean): void => {\n  // eslint-disable-next-line prefer-spread\n  const runFn = (fn: RunEachItem) => fn && fn.apply(undefined, args || []);\n  each(arr, runFn);\n  !keep && ((arr as any[]).length = 0);\n};\n","import { each, keys } from '~/support/utils';\nimport { isString, isNumber, isArray, isUndefined } from '~/support/utils/types';\nimport type { PlainObject, StyleObject } from '~/typings';\n\nexport interface TRBL {\n  t: number;\n  r: number;\n  b: number;\n  l: number;\n}\n\nconst cssNumber = {\n  // animationiterationcount: 1,\n  // columncount: 1,\n  // fillopacity: 1,\n  // flexgrow: 1,\n  // flexshrink: 1,\n  // fontweight: 1,\n  // lineheight: 1,\n  // order: 1,\n  // orphans: 1,\n  // widows: 1,\n  // zoom: 1,\n  opacity: 1,\n  zindex: 1,\n};\n\nconst parseToZeroOrNumber = (value: string, toFloat?: boolean): number => {\n  /* istanbul ignore next */\n  const num = toFloat ? parseFloat(value) : parseInt(value, 10);\n  // num === num means num is not NaN\n  /* istanbul ignore next */\n  return num === num ? num : 0; // eslint-disable-line no-self-compare\n};\n\nconst adaptCSSVal = (prop: string, val: string | number): string | number =>\n  !cssNumber[prop.toLowerCase()] && isNumber(val) ? `${val}px` : val;\n\nconst getCSSVal = (elm: HTMLElement, computedStyle: CSSStyleDeclaration, prop: string): string =>\n  /* istanbul ignore next */\n  computedStyle != null\n    ? computedStyle[prop] || computedStyle.getPropertyValue(prop)\n    : elm.style[prop];\n\nconst setCSSVal = (elm: HTMLElement, prop: string, val: string | number): void => {\n  try {\n    const { style: elmStyle } = elm;\n    if (!isUndefined(elmStyle[prop])) {\n      elmStyle[prop] = adaptCSSVal(prop, val);\n    } else {\n      elmStyle.setProperty(prop, val as string);\n    }\n  } catch (e) {}\n};\n\n/**\n * Gets or sets the passed styles to the passed element.\n * @param elm The element to which the styles shall be applied to / be read from.\n * @param styles The styles which shall be set or read.\n */\nexport function style<CustomCssProps>(\n  elm: HTMLElement | false | null | undefined,\n  styles: StyleObject<CustomCssProps>\n): void;\nexport function style(elm: HTMLElement | false | null | undefined, styles: string): string;\nexport function style(\n  elm: HTMLElement | false | null | undefined,\n  styles: Array<string> | string\n): { [key: string]: string };\nexport function style<CustomCssProps>(\n  elm: HTMLElement | false | null | undefined,\n  styles: StyleObject<CustomCssProps> | Array<string> | string\n): { [key: string]: string } | string | void {\n  const getSingleStyle = isString(styles);\n  const getStyles = isArray(styles) || getSingleStyle;\n\n  if (getStyles) {\n    let getStylesResult: string | PlainObject = getSingleStyle ? '' : {};\n    if (elm) {\n      const computedStyle: CSSStyleDeclaration = window.getComputedStyle(elm, null);\n      getStylesResult = getSingleStyle\n        ? getCSSVal(elm, computedStyle, styles as string)\n        : (styles as Array<string>).reduce((result, key) => {\n            result[key] = getCSSVal(elm, computedStyle, key as string);\n            return result;\n          }, getStylesResult);\n    }\n    return getStylesResult;\n  }\n  elm && each(keys(styles), (key) => setCSSVal(elm, key, styles[key]));\n}\n\nexport const directionIsRTL = (elm: HTMLElement | false | null | undefined): boolean =>\n  style(elm, 'direction') === 'rtl';\n\n/**\n * Returns the top right bottom left values of the passed css property.\n * @param elm The element of which the values shall be returned.\n * @param propertyPrefix The css property prefix. (e.g. \"border\")\n * @param propertySuffix The css property suffix. (e.g. \"width\")\n */\nexport const topRightBottomLeft = (\n  elm?: HTMLElement | false | null | undefined,\n  propertyPrefix?: string,\n  propertySuffix?: string\n): TRBL => {\n  const finalPrefix = propertyPrefix ? `${propertyPrefix}-` : '';\n  const finalSuffix = propertySuffix ? `-${propertySuffix}` : '';\n  const top = `${finalPrefix}top${finalSuffix}`;\n  const right = `${finalPrefix}right${finalSuffix}`;\n  const bottom = `${finalPrefix}bottom${finalSuffix}`;\n  const left = `${finalPrefix}left${finalSuffix}`;\n  const result = style(elm, [top, right, bottom, left]);\n  return {\n    t: parseToZeroOrNumber(result[top], true),\n    r: parseToZeroOrNumber(result[right], true),\n    b: parseToZeroOrNumber(result[bottom], true),\n    l: parseToZeroOrNumber(result[left], true),\n  };\n};\n","export interface CacheOptions<Value> {\n  // initial value of _value.\n  _initialValue: Value;\n  // Custom comparison function if shallow compare isn't enough. Returns true if nothing changed.\n  _equal?: EqualCachePropFunction<Value>;\n  // If true always updates _value and _previous, otherwise they update only when they changed.\n  _alwaysUpdateValues?: boolean;\n}\n\nexport type CacheValues<T> = [value: T, changed: boolean, previous?: T];\n\nexport type EqualCachePropFunction<Value> = (currentVal: Value, newVal: Value) => boolean;\n\nexport type CacheUpdater<Value> = (current: Value, previous?: Value) => Value;\n\nexport type UpdateCacheContextual<Value> = (newValue: Value, force?: boolean) => CacheValues<Value>;\n\nexport type UpdateCache<Value> = (force?: boolean) => CacheValues<Value>;\n\nexport type GetCurrentCache<Value> = (force?: boolean) => CacheValues<Value>;\n\nexport type Cache<Value> = [UpdateCache<Value>, GetCurrentCache<Value>];\n\nexport type CacheContextual<Value> = [UpdateCacheContextual<Value>, GetCurrentCache<Value>];\n\ntype CreateCache = {\n  <Value>(options: CacheOptions<Value>): CacheContextual<Value>;\n  <Value>(options: CacheOptions<Value>, update: CacheUpdater<Value>): Cache<Value>;\n  <Value>(options: CacheOptions<Value>, update?: CacheUpdater<Value>):\n    | CacheContextual<Value>\n    | Cache<Value>;\n};\n\nexport const createCache: CreateCache = <Value>(\n  options: CacheOptions<Value>,\n  update?: CacheUpdater<Value>\n): CacheContextual<Value> | Cache<Value> => {\n  const { _initialValue, _equal, _alwaysUpdateValues } = options;\n  let _value: Value = _initialValue;\n  let _previous: Value | undefined;\n\n  const cacheUpdateContextual: UpdateCacheContextual<Value> = (newValue, force?) => {\n    const curr = _value;\n\n    const newVal = newValue;\n    const changed = force || (_equal ? !_equal(curr, newVal) : curr !== newVal);\n\n    if (changed || _alwaysUpdateValues) {\n      _value = newVal;\n      _previous = curr;\n    }\n\n    return [_value, changed, _previous];\n  };\n  const cacheUpdateIsolated: UpdateCache<Value> = (force?) =>\n    cacheUpdateContextual(update!(_value, _previous), force);\n\n  const getCurrentCache: GetCurrentCache<Value> = (force?: boolean) => [\n    _value,\n    !!force, // changed\n    _previous,\n  ];\n\n  return [update ? cacheUpdateIsolated : cacheUpdateContextual, getCurrentCache] as\n    | CacheContextual<Value>\n    | Cache<Value>;\n};\n","export const isClient = () => typeof window !== 'undefined';\n","import { isClient } from '~/support/compatibility/server';\nimport type { PlainObject } from '~/typings';\n\nconst ElementNodeType = isClient() && Node.ELEMENT_NODE;\nconst { toString, hasOwnProperty } = Object.prototype;\n\nexport const isUndefined = (obj: any): obj is undefined => obj === undefined;\n\nexport const isNull = (obj: any): obj is null => obj === null;\n\nexport const type = (obj: any): string =>\n  isUndefined(obj) || isNull(obj)\n    ? `${obj}`\n    : toString\n        .call(obj)\n        .replace(/^\\[object (.+)\\]$/, '$1')\n        .toLowerCase();\n\nexport const isNumber = (obj: any): obj is number => typeof obj === 'number';\n\nexport const isString = (obj: any): obj is string => typeof obj === 'string';\n\nexport const isBoolean = (obj: any): obj is boolean => typeof obj === 'boolean';\n\nexport const isFunction = (obj: any): obj is (...args: any[]) => any => typeof obj === 'function';\n\nexport const isArray = <T = any>(obj: any): obj is Array<T> => Array.isArray(obj);\n\nexport const isObject = (obj: any): boolean =>\n  typeof obj === 'object' && !isArray(obj) && !isNull(obj);\n\n/**\n * Returns true if the given object is array like, false otherwise.\n * @param obj The Object\n */\nexport const isArrayLike = <T extends PlainObject = any>(obj: any): obj is ArrayLike<T> => {\n  const length = !!obj && obj.length;\n  const lengthCorrectFormat = isNumber(length) && length > -1 && length % 1 == 0; // eslint-disable-line eqeqeq\n\n  return isArray(obj) || (!isFunction(obj) && lengthCorrectFormat)\n    ? length > 0 && isObject(obj)\n      ? length - 1 in obj\n      : true\n    : false;\n};\n\n/**\n * Returns true if the given object is a \"plain\" (e.g. { key: value }) object, false otherwise.\n * @param obj The Object.\n */\nexport const isPlainObject = <T = any>(obj: any): obj is PlainObject<T> => {\n  if (!obj || !isObject(obj) || type(obj) !== 'object') return false;\n\n  let key;\n  const cstr = 'constructor';\n  const ctor = obj[cstr];\n  const ctorProto = ctor && ctor.prototype;\n  const hasOwnConstructor = hasOwnProperty.call(obj, cstr);\n  const hasIsPrototypeOf = ctorProto && hasOwnProperty.call(ctorProto, 'isPrototypeOf');\n\n  if (ctor && !hasOwnConstructor && !hasIsPrototypeOf) {\n    return false;\n  }\n\n  /* eslint-disable no-restricted-syntax */\n  for (key in obj) {\n    /**/\n  }\n  /* eslint-enable */\n\n  return isUndefined(key) || hasOwnProperty.call(obj, key);\n};\n\n/**\n * Checks whether the given object is a HTMLElement.\n * @param obj The object which shall be checked.\n */\nexport const isHTMLElement = (obj: any): obj is HTMLElement => {\n  const instanceofObj = HTMLElement;\n  return obj\n    ? instanceofObj\n      ? obj instanceof instanceofObj\n      : obj.nodeType === ElementNodeType\n    : false;\n};\n\n/**\n * Checks whether the given object is a Element.\n * @param obj The object which shall be checked.\n */\nexport const isElement = (obj: any): obj is Element => {\n  const instanceofObj = Element;\n  return obj\n    ? instanceofObj\n      ? obj instanceof instanceofObj\n      : obj.nodeType === ElementNodeType\n    : false;\n};\n","import { isArray, isFunction, isPlainObject, isNull } from '~/support/utils/types';\nimport { each } from '~/support/utils/array';\n\n/**\n * Determines whether the passed object has a property with the passed name.\n * @param obj The object.\n * @param prop The name of the property.\n */\nexport const hasOwnProperty = (obj: any, prop: string | number | symbol): boolean =>\n  Object.prototype.hasOwnProperty.call(obj, prop);\n\n/**\n * Returns the names of the enumerable string properties and methods of an object.\n * @param obj The object of which the properties shall be returned.\n */\nexport const keys = (obj: any): Array<string> => (obj ? Object.keys(obj) : []);\n\ntype AssignDeep = {\n  <T, U>(target: T, object1: U): T & U;\n  <T, U, V>(target: T, object1: U, object2: V): T & U & V;\n  <T, U, V, W>(target: T, object1: U, object2: V, object3: W): T & U & V & W;\n  <T, U, V, W, X>(target: T, object1: U, object2: V, object3: W, object4: X): T & U & V & W & X;\n  <T, U, V, W, X, Y>(target: T, object1: U, object2: V, object3: W, object4: X, object5: Y): T &\n    U &\n    V &\n    W &\n    X &\n    Y;\n  <T, U, V, W, X, Y, Z>(\n    target: T,\n    object1?: U,\n    object2?: V,\n    object3?: W,\n    object4?: X,\n    object5?: Y,\n    object6?: Z\n  ): T & U & V & W & X & Y & Z;\n};\n\n// https://github.com/jquery/jquery/blob/master/src/core.js#L116\nexport const assignDeep: AssignDeep = <T, U, V, W, X, Y, Z>(\n  target: T,\n  object1?: U,\n  object2?: V,\n  object3?: W,\n  object4?: X,\n  object5?: Y,\n  object6?: Z\n): T & U & V & W & X & Y & Z => {\n  const sources: Array<any> = [object1, object2, object3, object4, object5, object6];\n\n  // Handle case when target is a string or something (possible in deep copy)\n  if ((typeof target !== 'object' || isNull(target)) && !isFunction(target)) {\n    target = {} as T;\n  }\n\n  each(sources, (source) => {\n    // Extend the base object\n    each(keys(source), (key) => {\n      const copy: any = source[key];\n\n      // Prevent Object.prototype pollution\n      // Prevent never-ending loop\n      if (target === copy) {\n        return true;\n      }\n\n      const copyIsArray = isArray(copy);\n\n      // Recurse if we're merging plain objects or arrays\n      if (copy && (isPlainObject(copy) || copyIsArray)) {\n        const src = target[key];\n        let clone: any = src;\n\n        // Ensure proper type for the source value\n        if (copyIsArray && !isArray(src)) {\n          clone = [];\n        } else if (!copyIsArray && !isPlainObject(src)) {\n          clone = {};\n        }\n\n        // Never move original objects, clone them\n        target[key] = assignDeep(clone, copy) as any;\n      } else {\n        target[key] = copy;\n      }\n    });\n  });\n\n  // Return the modified object\n  return target as any;\n};\n\n/**\n * Returns true if the given object is empty, false otherwise.\n * @param obj The Object.\n */\nexport const isEmptyObject = (obj: any): boolean => {\n  // eslint-disable-next-line no-restricted-syntax, no-unreachable-loop, guard-for-in\n  for (const name in obj) return false;\n  return true;\n  /* eslint-enable */\n};\n","import { from } from '~/support/utils/array';\nimport { isNumber, isString, isUndefined } from '~/support/utils/types';\n\ntype GetSetPropName = 'scrollLeft' | 'scrollTop' | 'value';\n\ntype Attr = {\n  (elm: HTMLElement | false | null | undefined, attrName: string): string | null;\n  (elm: HTMLElement | false | null | undefined, attrName: string, value: string): void;\n  (elm: HTMLElement | false | null | undefined, attrName: string, value?: string):\n    | string\n    | null\n    | void;\n};\n\ntype GetSetProp<T> = {\n  (elm: HTMLElement | false | null | undefined): T;\n  (elm: HTMLElement | false | null | undefined, value: T | false | null): void;\n  (elm: HTMLElement | false | null | undefined, value?: T | false | null): T | void;\n};\n\nconst getSetProp = (\n  topLeft: GetSetPropName,\n  fallback: number | string,\n  elm: HTMLElement | HTMLInputElement | false | null | undefined,\n  value?: number | string | false | null\n): number | string | void => {\n  if (isUndefined(value)) {\n    return elm ? elm[topLeft] : fallback;\n  }\n  elm && (isString(value) || isNumber(value)) && (elm[topLeft] = value);\n};\n\n/**\n * Gets or sets a attribute with the given attribute of the given element depending whether the value attribute is given.\n * Returns null if the element has no attribute with the given name.\n * @param elm The element of which the attribute shall be get or set.\n * @param attrName The attribute name which shall be get or set.\n * @param value The value of the attribute which shall be set.\n */\nexport const attr = ((\n  elm: HTMLElement | false | null | undefined,\n  attrName: string,\n  value?: string\n): string | null | void => {\n  if (isUndefined(value)) {\n    return elm ? elm.getAttribute(attrName) : null;\n  }\n  elm && elm.setAttribute(attrName, value);\n}) as Attr;\n\n/**\n * Treats the given attribute like the \"class\" attribute and adds or removes the given value from it.\n * @param elm The element.\n * @param attrName The attributeName to which the value shall be added or removed.\n * @param value The value which shall be added or removed.\n * @param add True if the value shall be added, false otherwise.\n */\nexport const attrClass = (\n  elm: HTMLElement | false | null | undefined,\n  attrName: string,\n  value: string,\n  add?: boolean\n) => {\n  if (value) {\n    const currValues = attr(elm, attrName) || '';\n    const currValuesSet = new Set(currValues.split(' '));\n    currValuesSet[add ? 'add' : 'delete'](value);\n\n    attr(elm, attrName, from(currValuesSet).join(' ').trim());\n  }\n};\n\n/**\n * Treats the given attribute like the \"class\" attribute and checks if the given value is in it.\n * @param elm The element.\n * @param attrName The attributeName from which the content shall be checked.\n * @param value The value.\n * @returns True if the given attribute has the value in it, false otherwise.\n */\nexport const hasAttrClass = (\n  elm: HTMLElement | false | null | undefined,\n  attrName: string,\n  value: string\n) => {\n  const currValues = attr(elm, attrName) || '';\n  const currValuesSet = new Set(currValues.split(' '));\n  return currValuesSet.has(value);\n};\n\n/**\n * Removes the given attribute from the given element.\n * @param elm The element of which the attribute shall be removed.\n * @param attrName The attribute name.\n */\nexport const removeAttr = (elm: Element | false | null | undefined, attrName: string): void => {\n  elm && elm.removeAttribute(attrName);\n};\n\n/**\n * Gets or sets the scrollLeft value of the given element depending whether the value attribute is given.\n * @param elm The element of which the scrollLeft value shall be get or set.\n * @param value The scrollLeft value which shall be set.\n */\nexport const scrollLeft = ((\n  elm: HTMLElement | false | null | undefined,\n  value?: number | false | null\n): number | void => getSetProp('scrollLeft', 0, elm, value) as number) as GetSetProp<number>;\n\n/**\n * Gets or sets the scrollTop value of the given element depending whether the value attribute is given.\n * @param elm The element of which the scrollTop value shall be get or set.\n * @param value The scrollTop value which shall be set.\n */\nexport const scrollTop = ((\n  elm: HTMLElement | false | null | undefined,\n  value?: number | false | null\n): number | void => getSetProp('scrollTop', 0, elm, value) as number) as GetSetProp<number>;\n\n/**\n * Gets or sets the value of the given input element depending whether the value attribute is given.\n * @param elm The input element of which the value shall be get or set.\n * @param value The value which shall be set.\n */\nexport const val = ((\n  elm: HTMLInputElement | false | null | undefined,\n  value?: string\n): string | void => getSetProp('value', '', elm, value) as string) as GetSetProp<string>;\n","import { isClient } from '~/support/compatibility/server';\nimport { isElement } from '~/support/utils/types';\nimport { push, from } from '~/support/utils/array';\n\ntype InputElementType = Node | Element | Node | false | null | undefined;\ntype OutputElementType = Node | Element | null;\n\nconst getElmPrototype = (isClient() && Element.prototype) as Element; // only Element.prototype wont work on server\n\n/**\n * Find all elements with the passed selector, outgoing (and including) the passed element or the document if no element was provided.\n * @param selector The selector which has to be searched by.\n * @param elm The element from which the search shall be outgoing.\n */\nconst find = (selector: string, elm?: InputElementType): Element[] => {\n  const arr: Array<Element> = [];\n  const rootElm = elm ? (isElement(elm) ? elm : null) : document;\n\n  return rootElm ? push(arr, rootElm.querySelectorAll(selector)) : arr;\n};\n\n/**\n * Find the first element with the passed selector, outgoing (and including) the passed element or the document if no element was provided.\n * @param selector The selector which has to be searched by.\n * @param elm The element from which the search shall be outgoing.\n */\nconst findFirst = (selector: string, elm?: InputElementType): OutputElementType => {\n  const rootElm = elm ? (isElement(elm) ? elm : null) : document;\n\n  return rootElm ? rootElm.querySelector(selector) : null;\n};\n\n/**\n * Determines whether the passed element is matching with the passed selector.\n * @param elm The element which has to be compared with the passed selector.\n * @param selector The selector which has to be compared with the passed element. Additional selectors: ':visible' and ':hidden'.\n */\nconst is = (elm: InputElementType, selector: string): boolean => {\n  if (isElement(elm)) {\n    /* istanbul ignore next */\n    // eslint-disable-next-line\n    const fn: (...args: any) => boolean =\n      // @ts-ignore\n      getElmPrototype.matches || getElmPrototype.msMatchesSelector;\n    return fn.call(elm, selector);\n  }\n  return false;\n};\n\n/**\n * Returns the children (no text-nodes or comments) of the passed element which are matching the passed selector. An empty array is returned if the passed element is null.\n * @param elm The element of which the children shall be returned.\n * @param selector The selector which must match with the children elements.\n */\nconst children = (elm: InputElementType, selector?: string): ReadonlyArray<Element> => {\n  const childs: Array<Element> = [];\n\n  return isElement(elm)\n    ? push(\n        childs,\n        from(elm.children).filter((child) => (selector ? is(child, selector) : child))\n      )\n    : childs;\n};\n\n/**\n * Returns the childNodes (incl. text-nodes or comments etc.) of the passed element. An empty array is returned if the passed element is null.\n * @param elm The element of which the childNodes shall be returned.\n */\nconst contents = (elm: InputElementType): ReadonlyArray<ChildNode> =>\n  elm ? from(elm.childNodes) : [];\n\n/**\n * Returns the parent element of the passed element, or null if the passed element is null.\n * @param elm The element of which the parent element shall be returned.\n */\nconst parent = (elm: InputElementType): OutputElementType => (elm ? elm.parentElement : null);\n\nconst closest = (elm: InputElementType, selector: string): OutputElementType => {\n  if (isElement(elm)) {\n    const closestFn = getElmPrototype.closest;\n    if (closestFn) {\n      return closestFn.call(elm, selector);\n    }\n\n    do {\n      if (is(elm, selector)) {\n        return elm as Element;\n      }\n      elm = parent(elm);\n    } while (elm);\n  }\n\n  return null;\n};\n\n/**\n * Determines whether the given element lies between two selectors in the DOM.\n * @param elm The element.\n * @param highBoundarySelector The high boundary selector.\n * @param deepBoundarySelector The deep boundary selector.\n */\nconst liesBetween = (\n  elm: InputElementType,\n  highBoundarySelector: string,\n  deepBoundarySelector: string\n): boolean => {\n  const closestHighBoundaryElm = elm && closest(elm, highBoundarySelector);\n  const closestDeepBoundaryElm = elm && findFirst(deepBoundarySelector, closestHighBoundaryElm);\n  const deepBoundaryIsValid =\n    closest(closestDeepBoundaryElm, highBoundarySelector) === closestHighBoundaryElm;\n\n  return closestHighBoundaryElm && closestDeepBoundaryElm\n    ? closestHighBoundaryElm === elm ||\n        closestDeepBoundaryElm === elm ||\n        (deepBoundaryIsValid &&\n          closest(closest(elm, deepBoundarySelector), highBoundarySelector) !==\n            closestHighBoundaryElm)\n    : false;\n};\n\nexport { find, findFirst, is, children, contents, parent, liesBetween, closest };\n","import { isArrayLike } from '~/support/utils/types';\nimport { each, from } from '~/support/utils/array';\nimport { parent } from '~/support/dom/traversal';\n\ntype NodeCollection = ArrayLike<Node> | Node | false | null | undefined;\n\n/**\n * Inserts Nodes before the given preferredAnchor element.\n * @param parentElm The parent of the preferredAnchor element or the element which shall be the parent of the inserted Nodes.\n * @param preferredAnchor The element before which the Nodes shall be inserted or null if the elements shall be appended at the end.\n * @param insertedElms The Nodes which shall be inserted.\n */\nconst before = (\n  parentElm: Node | false | null | undefined,\n  preferredAnchor: Node | false | null | undefined,\n  insertedElms: NodeCollection\n): void => {\n  if (insertedElms && parentElm) {\n    let anchor: Node | false | null | undefined = preferredAnchor;\n    let fragment: DocumentFragment | Node | null | undefined;\n\n    if (isArrayLike(insertedElms)) {\n      fragment = document.createDocumentFragment();\n\n      // append all insertedElms to the fragment and if one of these is the anchor, change the anchor\n      each(insertedElms, (insertedElm) => {\n        if (insertedElm === anchor) {\n          anchor = insertedElm.previousSibling;\n        }\n        fragment!.appendChild(insertedElm);\n      });\n    } else {\n      fragment = insertedElms;\n    }\n\n    // if the preferred anchor isn't null set it to a valid anchor\n    if (preferredAnchor) {\n      if (!anchor) {\n        anchor = parentElm.firstChild;\n      } else if (anchor !== preferredAnchor) {\n        anchor = anchor.nextSibling;\n      }\n    }\n\n    parentElm.insertBefore(fragment, anchor || null);\n  }\n};\n\n/**\n * Appends the given children at the end of the given Node.\n * @param node The Node to which the children shall be appended.\n * @param children The Nodes which shall be appended.\n */\nexport const appendChildren = (\n  node: Node | false | null | undefined,\n  children: NodeCollection\n): void => {\n  before(node, null, children);\n};\n\n/**\n * Prepends the given children at the start of the given Node.\n * @param node The Node to which the children shall be prepended.\n * @param children The Nodes which shall be prepended.\n */\nexport const prependChildren = (\n  node: Node | false | null | undefined,\n  children: NodeCollection\n): void => {\n  before(node, node && node.firstChild, children);\n};\n\n/**\n * Inserts the given Nodes before the given Node.\n * @param node The Node before which the given Nodes shall be inserted.\n * @param insertedNodes The Nodes which shall be inserted.\n */\nexport const insertBefore = (\n  node: Node | false | null | undefined,\n  insertedNodes: NodeCollection\n): void => {\n  before(parent(node), node, insertedNodes);\n};\n\n/**\n * Inserts the given Nodes after the given Node.\n * @param node The Node after which the given Nodes shall be inserted.\n * @param insertedNodes The Nodes which shall be inserted.\n */\nexport const insertAfter = (\n  node: Node | false | null | undefined,\n  insertedNodes: NodeCollection\n): void => {\n  before(parent(node), node && node.nextSibling, insertedNodes);\n};\n\n/**\n * Removes the given Nodes from their parent.\n * @param nodes The Nodes which shall be removed.\n */\nexport const removeElements = (nodes: NodeCollection): void => {\n  if (isArrayLike(nodes)) {\n    each(from(nodes), (e) => removeElements(e));\n  } else if (nodes) {\n    const parentElm = parent(nodes);\n    if (parentElm) {\n      parentElm.removeChild(nodes);\n    }\n  }\n};\n","import { each } from '~/support/utils/array';\nimport { attr } from '~/support/dom/attribute';\nimport { contents } from '~/support/dom/traversal';\nimport { removeElements } from '~/support/dom/manipulation';\n\n/**\n * Creates a div DOM node.\n */\nexport const createDiv = (classNames?: string): HTMLDivElement => {\n  const div = document.createElement('div');\n  if (classNames) {\n    attr(div, 'class', classNames);\n  }\n  return div;\n};\n\n/**\n * Creates DOM nodes modeled after the passed html string and returns the root dom nodes as a array.\n * @param html The html string after which the DOM nodes shall be created.\n */\nexport const createDOM = (html: string): ReadonlyArray<Node> => {\n  const createdDiv = createDiv();\n  createdDiv.innerHTML = html.trim();\n\n  return each(contents(createdDiv), (elm) => removeElements(elm));\n};\n","import { each } from '~/support/utils/array';\nimport { isClient } from '~/support/compatibility/server';\nimport { hasOwnProperty } from '~/support/utils/object';\nimport { createDiv } from '~/support/dom/create';\n\nconst firstLetterToUpper = (str: string): string => str.charAt(0).toUpperCase() + str.slice(1);\nconst getDummyStyle = (): CSSStyleDeclaration => createDiv().style;\n\n// https://developer.mozilla.org/en-US/docs/Glossary/Vendor_Prefix\n\nexport const cssPrefixes: ReadonlyArray<string> = ['-webkit-', '-moz-', '-o-', '-ms-'];\nexport const jsPrefixes: ReadonlyArray<string> = [\n  'WebKit',\n  'Moz',\n  'O',\n  'MS',\n  'webkit',\n  'moz',\n  'o',\n  'ms',\n];\n\nexport const jsCache: { [key: string]: any } = {};\nexport const cssCache: { [key: string]: string } = {};\n\n/**\n * Gets the name of the given CSS property with vendor prefix if it isn't supported without it, or and empty string if unsupported.\n * @param name The name of the CSS property which shall be get.\n */\nexport const cssProperty = (name: string): string => {\n  let result: string | undefined = cssCache[name];\n\n  if (hasOwnProperty(cssCache, name)) {\n    return result;\n  }\n\n  const uppercasedName: string = firstLetterToUpper(name);\n  const elmStyle: CSSStyleDeclaration = getDummyStyle();\n\n  each(cssPrefixes, (prefix: string) => {\n    const prefixWithoutDashes: string = prefix.replace(/-/g, '');\n    const resultPossibilities: Array<string> = [\n      name, // transition\n      prefix + name, // -webkit-transition\n      prefixWithoutDashes + uppercasedName, // webkitTransition\n      firstLetterToUpper(prefixWithoutDashes) + uppercasedName, // WebkitTransition\n    ];\n\n    // eslint-disable-next-line no-return-assign\n    return !(result = resultPossibilities.find(\n      (resultPossibility: string) => elmStyle[resultPossibility] !== undefined\n    ));\n  });\n\n  // eslint-disable-next-line no-return-assign\n  return (cssCache[name] = result || '');\n};\n\n/**\n * Get the name of the given CSS property value(s), with vendor prefix if it isn't supported without it, or an empty string if no value is supported.\n * @param property The CSS property to which the CSS property value(s) belong.\n * @param values The value(s) separated by spaces which shall be get.\n * @param suffix A suffix which is added to each value in case the value is a function or something else more advanced.\n */\nexport const cssPropertyValue = (property: string, values: string, suffix?: string): string => {\n  const name = `${property} ${values}`;\n  let result: string | undefined = cssCache[name];\n\n  if (hasOwnProperty(cssCache, name)) {\n    return result;\n  }\n\n  const dummyStyle: CSSStyleDeclaration = getDummyStyle();\n  const possbleValues: Array<string> = values.split(' ');\n  const preparedSuffix: string = suffix || '';\n  const cssPrefixesWithFirstEmpty = [''].concat(cssPrefixes);\n\n  each(possbleValues, (possibleValue: string) => {\n    each(cssPrefixesWithFirstEmpty, (prefix: string) => {\n      const prop = prefix + possibleValue;\n      dummyStyle.cssText = `${property}:${prop}${preparedSuffix}`;\n      if (dummyStyle.length) {\n        result = prop;\n        return false;\n      }\n    });\n    return !result;\n  });\n\n  // eslint-disable-next-line no-return-assign\n  return (cssCache[name] = result || '');\n};\n\n/**\n * Get the requested JS function, object or constructor with vendor prefix if it isn't supported without or undefined if unsupported.\n * @param name The name of the JS function, object or constructor.\n */\nexport const jsAPI = <T = any>(name: string): T | undefined => {\n  if (isClient()) {\n    let result: any = jsCache[name] || window[name];\n\n    if (hasOwnProperty(jsCache, name)) {\n      return result;\n    }\n\n    each(jsPrefixes, (prefix: string) => {\n      result = result || window[prefix + firstLetterToUpper(name)];\n      return !result;\n    });\n\n    jsCache[name] = result;\n    return result;\n  }\n};\n","import { isClient } from '~/support/compatibility/server';\nimport { jsAPI } from '~/support/compatibility/vendors';\n\nexport const MutationObserverConstructor = jsAPI<typeof MutationObserver>('MutationObserver');\nexport const IntersectionObserverConstructor =\n  jsAPI<typeof IntersectionObserver>('IntersectionObserver');\nexport const ResizeObserverConstructor = jsAPI<typeof ResizeObserver>('ResizeObserver');\nexport const cAF = jsAPI<typeof cancelAnimationFrame>('cancelAnimationFrame');\nexport const rAF = jsAPI<typeof requestAnimationFrame>('requestAnimationFrame');\nexport const setT = (isClient() && window.setTimeout) as (\n  handler: TimerHandler,\n  timeout?: number\n) => number;\nexport const clearT = (isClient() && window.clearTimeout) as (id?: number) => void;\n","import { each } from '~/support/utils/array';\nimport type { WH, XY, TRBL } from '~/support/dom';\nimport type { PlainObject } from '~/typings';\n\n/**\n * Compares two objects and returns true if all values of the passed prop names are identical, false otherwise or if one of the two object is falsy.\n * @param a Object a.\n * @param b Object b.\n * @param props The props which shall be compared.\n */\nexport const equal = <T extends PlainObject>(\n  a: T | undefined,\n  b: T | undefined,\n  props: Array<keyof T>,\n  propMutation?: ((value: any) => any) | null | false\n): boolean => {\n  if (a && b) {\n    let result = true;\n    each(props, (prop) => {\n      const compareA = propMutation ? propMutation(a[prop]) : a[prop];\n      const compareB = propMutation ? propMutation(b[prop]) : b[prop];\n      if (compareA !== compareB) {\n        result = false;\n      }\n    });\n    return result;\n  }\n  return false;\n};\n\n/**\n * Compares object a with object b and returns true if both have the same property values, false otherwise.\n * Also returns false if one of the objects is undefined or null.\n * @param a Object a.\n * @param b Object b.\n */\nexport const equalWH = <T>(a?: WH<T>, b?: WH<T>) => equal<WH<T>>(a, b, ['w', 'h']);\n\n/**\n * Compares object a with object b and returns true if both have the same property values, false otherwise.\n * Also returns false if one of the objects is undefined or null.\n * @param a Object a.\n * @param b Object b.\n */\nexport const equalXY = <T>(a?: XY<T>, b?: XY<T>) => equal<XY<T>>(a, b, ['x', 'y']);\n\n/**\n * Compares object a with object b and returns true if both have the same property values, false otherwise.\n * Also returns false if one of the objects is undefined or null.\n * @param a Object a.\n * @param b Object b.\n */\nexport const equalTRBL = (a?: TRBL, b?: TRBL) => equal<TRBL>(a, b, ['t', 'r', 'b', 'l']);\n\n/**\n * Compares two DOM Rects for their equality of their width and height properties\n * Also returns false if one of the DOM Rects is undefined or null.\n * @param a DOM Rect a.\n * @param b DOM Rect b.\n * @param round Whether the values should be rounded.\n */\nexport const equalBCRWH = (a?: DOMRect, b?: DOMRect, round?: boolean) =>\n  equal<DOMRect>(a, b, ['width', 'height'], round && ((value) => Math.round(value)));\n","import { isNumber, isFunction } from '~/support/utils/types';\nimport { from } from '~/support/utils/array';\nimport { rAF, cAF, setT, clearT } from '~/support/compatibility/apis';\n\ntype DebounceTiming = number | false | null | undefined;\n\nexport interface DebounceOptions<FunctionToDebounce extends (...args: any) => any> {\n  /**\n   * The timeout for debouncing. If null, no debounce is applied.\n   */\n  _timeout?: DebounceTiming | (() => DebounceTiming);\n  /**\n   * A maximum amount of ms. before the function will be called even with debounce.\n   */\n  _maxDelay?: DebounceTiming | (() => DebounceTiming);\n  /**\n   * Function which merges parameters for each canceled debounce.\n   * If parameters can't be merged the function will return null, otherwise it returns the merged parameters.\n   */\n  _mergeParams?: (\n    prev: Parameters<FunctionToDebounce>,\n    curr: Parameters<FunctionToDebounce>\n  ) => Parameters<FunctionToDebounce> | false | null | undefined;\n}\n\nexport interface Debounced<FunctionToDebounce extends (...args: any) => any> {\n  (...args: Parameters<FunctionToDebounce>): ReturnType<FunctionToDebounce>;\n  _flush(): void;\n}\n\nexport const noop = () => {}; // eslint-disable-line\n\n/**\n * Creates a timeout and cleartimeout tuple. The timeout function always clears the previously created timeout before it runs.\n * @param timeout The timeout in ms. If no timeout (or 0) is passed requestAnimationFrame is used instead of setTimeout.\n * @returns A tuple with the timeout function as the first value and the clearTimeout function as the second value.\n */\nexport const selfClearTimeout = (timeout?: number | (() => number)) => {\n  let id: number;\n  const setTFn = timeout ? setT : rAF!;\n  const clearTFn = timeout ? clearT : cAF!;\n  return [\n    (callback: () => any) => {\n      clearTFn(id);\n      // @ts-ignore\n      id = setTFn(callback, isFunction(timeout) ? timeout() : timeout);\n    },\n    () => clearTFn(id),\n  ] as [timeout: (callback: () => any) => void, clear: () => void];\n};\n\n/**\n * Debounces the given function either with a timeout or a animation frame.\n * @param functionToDebounce The function which shall be debounced.\n * @param options Options for debouncing.\n */\nexport const debounce = <FunctionToDebounce extends (...args: any) => any>(\n  functionToDebounce: FunctionToDebounce,\n  options?: DebounceOptions<FunctionToDebounce>\n): Debounced<FunctionToDebounce> => {\n  let maxTimeoutId: number | undefined;\n  let prevArguments: Parameters<FunctionToDebounce> | null | undefined;\n  let latestArguments: Parameters<FunctionToDebounce> | null | undefined;\n  let clear: () => void = noop;\n  const { _timeout, _maxDelay, _mergeParams } = options || {};\n\n  const invokeFunctionToDebounce = function (args: IArguments) {\n    clear();\n    clearT(maxTimeoutId);\n    maxTimeoutId = prevArguments = undefined;\n    clear = noop;\n    // eslint-disable-next-line\n    // @ts-ignore\n    functionToDebounce.apply(this, args);\n  };\n\n  const mergeParms = (\n    curr: Parameters<FunctionToDebounce>\n  ): Parameters<FunctionToDebounce> | false | null | undefined =>\n    _mergeParams && prevArguments ? _mergeParams(prevArguments, curr) : curr;\n\n  const flush = () => {\n    /* istanbul ignore next */\n    if (clear !== noop) {\n      invokeFunctionToDebounce(mergeParms(latestArguments!) || latestArguments!);\n    }\n  };\n\n  const debouncedFn = function () {\n    // eslint-disable-next-line prefer-rest-params\n    const args: Parameters<FunctionToDebounce> = from(arguments) as Parameters<FunctionToDebounce>;\n    const finalTimeout = isFunction(_timeout) ? _timeout() : _timeout;\n    const hasTimeout = isNumber(finalTimeout) && finalTimeout >= 0;\n\n    if (hasTimeout) {\n      const finalMaxWait = isFunction(_maxDelay) ? _maxDelay() : _maxDelay;\n      const hasMaxWait = isNumber(finalMaxWait) && finalMaxWait >= 0;\n      const setTimeoutFn = finalTimeout > 0 ? setT : rAF!;\n      const clearTimeoutFn = finalTimeout > 0 ? clearT : cAF!;\n      const mergeParamsResult = mergeParms(args);\n      const invokedArgs = mergeParamsResult || args;\n      const boundInvoke = invokeFunctionToDebounce.bind(0, invokedArgs);\n\n      // if (!mergeParamsResult) {\n      //   invokeFunctionToDebounce(prevArguments || args);\n      // }\n\n      clear();\n      // @ts-ignore\n      const timeoutId = setTimeoutFn(boundInvoke, finalTimeout);\n      clear = () => clearTimeoutFn(timeoutId);\n\n      if (hasMaxWait && !maxTimeoutId) {\n        maxTimeoutId = setT(flush, finalMaxWait as number);\n      }\n\n      prevArguments = latestArguments = invokedArgs;\n    } else {\n      invokeFunctionToDebounce(args);\n    }\n  };\n  debouncedFn._flush = flush;\n\n  return debouncedFn as Debounced<FunctionToDebounce>;\n};\n","import { rAF, cAF } from '~/support/compatibility';\nimport { isFunction } from '~/support/utils';\n\nconst { max } = Math;\nconst animationCurrentTime = () => performance.now();\n\n/**\n * percent: current percent (0 - 1),\n * time: current time (duration * percent),\n * min: start value\n * max: end value\n * duration: duration in ms\n */\nexport type EasingFn = (\n  percent: number,\n  time: number,\n  min: number,\n  max: number,\n  duration: number\n) => number;\n\nexport const animateNumber = (\n  from: number,\n  to: number,\n  duration: number,\n  onFrame: (progress: number, percent: number, completed: boolean) => any,\n  easing?: EasingFn | false\n): ((complete?: boolean) => void) => {\n  let animationFrameId = 0;\n  const timeStart = animationCurrentTime();\n  const finalDuration = Math.max(0, duration);\n  const frame = (complete?: boolean) => {\n    const timeNow = animationCurrentTime();\n    const timeElapsed = timeNow - timeStart;\n    const stopAnimation = timeElapsed >= finalDuration;\n    const percent = complete\n      ? 1\n      : 1 - (max(0, timeStart + finalDuration - timeNow) / finalDuration || 0);\n    const progress =\n      (to - from) *\n        (isFunction(easing)\n          ? easing(percent, percent * finalDuration, 0, 1, finalDuration)\n          : percent) +\n      from;\n    const animationCompleted = stopAnimation || percent === 1;\n\n    onFrame && onFrame(progress, percent, animationCompleted);\n\n    animationFrameId = animationCompleted ? 0 : rAF!(() => frame());\n  };\n  frame();\n  return (complete) => {\n    cAF!(animationFrameId);\n    complete && frame(complete);\n  };\n};\n","import { isString } from '~/support/utils/types';\nimport { each } from '~/support/utils/array';\nimport { keys } from '~/support/utils/object';\n\ntype ClassContainingElement = Node | Element | false | null | undefined;\ntype ClassName = string | false | null | undefined;\n\nconst rnothtmlwhite = /[^\\x20\\t\\r\\n\\f]+/g;\nconst classListAction = (\n  elm: ClassContainingElement,\n  className: ClassName,\n  action: (elmClassList: DOMTokenList, clazz: string) => boolean | void\n): boolean => {\n  const classList = elm && (elm as Element).classList;\n  let clazz: string;\n  let i = 0;\n  let result = false;\n\n  if (classList && className && isString(className)) {\n    const classes: Array<string> = className.match(rnothtmlwhite) || [];\n    result = classes.length > 0;\n    while ((clazz = classes[i++])) {\n      result = !!action(classList, clazz) && result;\n    }\n  }\n  return result;\n};\n\n/**\n * Check whether the given element has the given class name(s).\n * @param elm The element.\n * @param className The class name(s).\n */\nexport const hasClass = (elm: ClassContainingElement, className: ClassName): boolean =>\n  classListAction(elm, className, (classList, clazz) => classList.contains(clazz));\n\n/**\n * Removes the given class name(s) from the given element.\n * @param elm The element.\n * @param className The class name(s) which shall be removed. (separated by spaces)\n */\nexport const removeClass = (elm: ClassContainingElement, className: ClassName): void => {\n  classListAction(elm, className, (classList, clazz) => classList.remove(clazz));\n};\n\n/**\n * Adds the given class name(s) to the given element.\n * @param elm The element.\n * @param className The class name(s) which shall be added. (separated by spaces)\n * @returns A function which removes the added class name(s).\n */\nexport const addClass = (elm: ClassContainingElement, className: ClassName): (() => void) => {\n  classListAction(elm, className, (classList, clazz) => classList.add(clazz));\n  return removeClass.bind(0, elm, className);\n};\n\n/**\n * Takes two className strings, compares them and returns the difference as array.\n * @param classNameA ClassName A.\n * @param classNameB ClassName B.\n */\nexport const diffClass = (classNameA: ClassName, classNameB: ClassName) => {\n  const classNameASplit = classNameA && classNameA.split(' ');\n  const classNameBSplit = classNameB && classNameB.split(' ');\n  const tempObj = {};\n\n  each(classNameASplit, (className) => {\n    tempObj[className] = 1;\n  });\n  each(classNameBSplit, (className) => {\n    if (tempObj[className]) {\n      delete tempObj[className];\n    } else {\n      tempObj[className] = 1;\n    }\n  });\n\n  return keys(tempObj);\n};\n","import { style } from '~/support/dom/style';\n\nexport interface WH<T = number> {\n  w: T;\n  h: T;\n}\n\nconst { round } = Math;\nconst elementHasDimensions = (elm: HTMLElement): boolean =>\n  !!(elm.offsetWidth || elm.offsetHeight || elm.getClientRects().length);\nconst zeroObj: WH = {\n  w: 0,\n  h: 0,\n};\n\n/**\n * Returns the window inner- width and height.\n */\nexport const windowSize = (): WH => ({\n  w: window.innerWidth,\n  h: window.innerHeight,\n});\n\n/**\n * Returns the scroll- width and height of the passed element. If the element is null the width and height values are 0.\n * @param elm The element of which the scroll- width and height shall be returned.\n */\nexport const offsetSize = (elm: HTMLElement | null | undefined): WH =>\n  elm\n    ? {\n        w: elm.offsetWidth,\n        h: elm.offsetHeight,\n      }\n    : zeroObj;\n\n/**\n * Returns the client- width and height of the passed element. If the element is null the width and height values are 0.\n * @param elm The element of which the client- width and height shall be returned.\n */\nexport const clientSize = (elm: HTMLElement | false | null | undefined): WH =>\n  elm\n    ? {\n        w: elm.clientWidth,\n        h: elm.clientHeight,\n      }\n    : zeroObj;\n\n/**\n * Returns the client- width and height of the passed element. If the element is null the width and height values are 0.\n * @param elm The element of which the client- width and height shall be returned.\n */\nexport const scrollSize = (elm: HTMLElement | false | null | undefined): WH =>\n  elm\n    ? {\n        w: elm.scrollWidth,\n        h: elm.scrollHeight,\n      }\n    : zeroObj;\n\n/**\n * Returns the fractional- width and height of the passed element. If the element is null the width and height values are 0.\n * @param elm The element of which the fractional- width and height shall be returned.\n */\nexport const fractionalSize = (elm: HTMLElement | false | null | undefined): WH => {\n  const cssHeight = parseFloat(style(elm, 'height')) || 0;\n  const cssWidth = parseFloat(style(elm, 'width')) || 0;\n  return {\n    w: cssWidth - round(cssWidth),\n    h: cssHeight - round(cssHeight),\n  };\n};\n\n/**\n * Returns the BoundingClientRect of the passed element.\n * @param elm The element of which the BoundingClientRect shall be returned.\n */\nexport const getBoundingClientRect = (elm: HTMLElement): DOMRect => elm.getBoundingClientRect();\n\n/**\n * Determines whether the passed element has any dimensions.\n * @param elm The element.\n */\nexport const hasDimensions = (elm: HTMLElement | false | null | undefined): boolean =>\n  elm ? elementHasDimensions(elm as HTMLElement) : false;\n","import { isUndefined } from '~/support/utils/types';\nimport { each, push, runEachAndClear } from '~/support/utils/array';\n\nlet passiveEventsSupport: boolean;\nconst supportPassiveEvents = (): boolean => {\n  if (isUndefined(passiveEventsSupport)) {\n    passiveEventsSupport = false;\n    try {\n      /* eslint-disable */\n      // @ts-ignore\n      window.addEventListener(\n        'test',\n        null,\n        Object.defineProperty({}, 'passive', {\n          get() {\n            passiveEventsSupport = true;\n          },\n        })\n      );\n      /* eslint-enable */\n    } catch (e) {}\n  }\n  return passiveEventsSupport;\n};\nconst splitEventNames = (eventNames: string) => eventNames.split(' ');\n\nexport interface OnOptions {\n  _capture?: boolean;\n  _passive?: boolean;\n  _once?: boolean;\n}\n\n/**\n * Removes the passed event listener for the passed events with the passed options.\n * @param target The element from which the listener shall be removed.\n * @param eventNames The eventsnames for which the listener shall be removed.\n * @param listener The listener which shall be removed.\n * @param capture The options of the removed listener.\n */\nexport const off = <T extends Event = Event>(\n  target: EventTarget,\n  eventNames: string,\n  listener: (event: T) => any,\n  capture?: boolean\n): void => {\n  each(splitEventNames(eventNames), (eventName) => {\n    target.removeEventListener(eventName, listener as EventListener, capture);\n  });\n};\n\n/**\n * Adds the passed event listener for the passed eventnames with the passed options.\n * @param target The element to which the listener shall be added.\n * @param eventNames The eventsnames for which the listener shall be called.\n * @param listener The listener which is called on the eventnames.\n * @param options The options of the added listener.\n */\nexport const on = <T extends Event = Event>(\n  target: EventTarget,\n  eventNames: string,\n  listener: (event: T) => any,\n  options?: OnOptions\n): (() => void) => {\n  const doSupportPassiveEvents = supportPassiveEvents();\n  const passive = (doSupportPassiveEvents && options && options._passive) ?? doSupportPassiveEvents;\n  const capture = (options && options._capture) || false;\n  const once = (options && options._once) || false;\n  const offListeners: (() => void)[] = [];\n  const nativeOptions: AddEventListenerOptions | boolean = doSupportPassiveEvents\n    ? {\n        passive,\n        capture,\n      }\n    : capture;\n\n  each(splitEventNames(eventNames), (eventName) => {\n    const finalListener = (\n      once\n        ? (evt: T) => {\n            target.removeEventListener(eventName, finalListener, capture);\n            listener && listener(evt);\n          }\n        : listener\n    ) as EventListener;\n\n    push(offListeners, off.bind(null, target, eventName, finalListener, capture));\n    target.addEventListener(eventName, finalListener, nativeOptions);\n  });\n\n  return runEachAndClear.bind(0, offListeners);\n};\n\n/**\n * Shorthand for the stopPropagation event Method.\n * @param evt The event of which the stopPropagation method shall be called.\n */\nexport const stopPropagation = (evt: Event): void => evt.stopPropagation();\n\n/**\n * Shorthand for the preventDefault event Method.\n * @param evt The event of which the preventDefault method shall be called.\n */\nexport const preventDefault = (evt: Event): void => evt.preventDefault();\n\n/**\n * Shorthand for the stopPropagation and preventDefault event Method.\n * @param evt The event of which the stopPropagation and preventDefault methods shall be called.\n */\nexport const stopAndPrevent = (evt: Event): void =>\n  (stopPropagation(evt) as undefined) || (preventDefault(evt) as undefined);\n","import { getBoundingClientRect } from '~/support/dom/dimensions';\n\nexport interface XY<T = number> {\n  x: T;\n  y: T;\n}\n\nconst zeroObj: XY = {\n  x: 0,\n  y: 0,\n};\n\n/**\n * Returns the offset- left and top coordinates of the passed element relative to the document. If the element is null the top and left values are 0.\n * @param elm The element of which the offset- top and left coordinates shall be returned.\n */\nexport const absoluteCoordinates = (elm: HTMLElement | null | undefined): XY => {\n  const rect = elm ? getBoundingClientRect(elm) : 0;\n  return rect\n    ? {\n        x: rect.left + window.pageYOffset,\n        y: rect.top + window.pageXOffset,\n      }\n    : zeroObj;\n};\n\n/**\n * Returns the offset- left and top coordinates of the passed element. If the element is null the top and left values are 0.\n * @param elm The element of which the offset- top and left coordinates shall be returned.\n */\nexport const offsetCoordinates = (elm: HTMLElement | null | undefined): XY =>\n  elm\n    ? {\n        x: elm.offsetLeft,\n        y: elm.offsetTop,\n      }\n    : zeroObj;\n","import { isArray, isBoolean, isFunction, isString } from '~/support/utils/types';\r\nimport { keys } from '~/support/utils/object';\r\nimport { each, push, from, isEmptyArray, runEachAndClear } from '~/support/utils/array';\r\n\r\nexport type EventListener<EventArgs extends Record<string, any[]>, N extends keyof EventArgs> = (\r\n  ...args: EventArgs[N]\r\n) => void;\r\n\r\nexport type EventListeners<EventArgs extends Record<string, any[]>> = {\r\n  [K in keyof EventArgs]?: EventListener<EventArgs, K> | EventListener<EventArgs, K>[] | null;\r\n};\r\n\r\nexport type RemoveEvent<EventArgs extends Record<string, any[]>> = {\r\n  <N extends keyof EventArgs>(name?: N, listener?: EventListener<EventArgs, N>): void;\r\n  <N extends keyof EventArgs>(name?: N, listener?: EventListener<EventArgs, N>[]): void;\r\n  <N extends keyof EventArgs>(\r\n    name?: N,\r\n    listener?: EventListener<EventArgs, N> | EventListener<EventArgs, N>[]\r\n  ): void;\r\n};\r\n\r\nexport type AddEvent<EventArgs extends Record<string, any[]>> = {\r\n  (eventListeners: EventListeners<EventArgs>, pure?: boolean): () => void;\r\n  <N extends keyof EventArgs>(name: N, listener: EventListener<EventArgs, N>): () => void;\r\n  <N extends keyof EventArgs>(name: N, listener: EventListener<EventArgs, N>[]): () => void;\r\n  <N extends keyof EventArgs>(\r\n    nameOrEventListeners: N | EventListeners<EventArgs>,\r\n    listener?: EventListener<EventArgs, N> | EventListener<EventArgs, N>[] | boolean\r\n  ): () => void;\r\n};\r\n\r\nexport type TriggerEvent<EventArgs extends Record<string, any[]>> = {\r\n  <N extends keyof EventArgs>(name: N, args?: EventArgs[N]): void;\r\n};\r\n\r\nexport type EventListenerHub<EventArgs extends Record<string, any[]>> = [\r\n  AddEvent<EventArgs>,\r\n  RemoveEvent<EventArgs>,\r\n  TriggerEvent<EventArgs>\r\n];\r\n\r\nconst manageListener = <EventArgs extends Record<string, any[]>, N extends keyof EventArgs>(\r\n  callback: (listener?: EventListener<EventArgs, N>) => void,\r\n  listener?: EventListener<EventArgs, N> | EventListener<EventArgs, N>[]\r\n) => {\r\n  each(isArray(listener) ? listener : [listener], callback);\r\n};\r\n\r\nexport const createEventListenerHub = <EventArgs extends Record<string, any[]>>(\r\n  initialEventListeners?: EventListeners<EventArgs>\r\n): EventListenerHub<EventArgs> => {\r\n  const events = new Map<keyof EventArgs, Set<EventListener<EventArgs, keyof EventArgs>>>();\r\n\r\n  const removeEvent: RemoveEvent<EventArgs> = (name, listener) => {\r\n    if (name) {\r\n      const eventSet = events.get(name);\r\n      manageListener((currListener) => {\r\n        if (eventSet) {\r\n          eventSet[currListener ? 'delete' : 'clear'](currListener! as any);\r\n        }\r\n      }, listener);\r\n    } else {\r\n      events.forEach((eventSet) => {\r\n        eventSet.clear();\r\n      });\r\n      events.clear();\r\n    }\r\n  };\r\n\r\n  const addEvent: AddEvent<EventArgs> = ((\r\n    nameOrEventListeners: keyof EventArgs | EventListeners<EventArgs>,\r\n    listenerOrPure:\r\n      | EventListener<EventArgs, keyof EventArgs>\r\n      | EventListener<EventArgs, keyof EventArgs>[]\r\n      | boolean\r\n  ) => {\r\n    if (isString(nameOrEventListeners)) {\r\n      const eventSet = events.get(nameOrEventListeners) || new Set();\r\n      events.set(nameOrEventListeners, eventSet);\r\n\r\n      manageListener((currListener) => {\r\n        isFunction(currListener) && eventSet.add(currListener);\r\n      }, listenerOrPure as any);\r\n\r\n      return removeEvent.bind(0, nameOrEventListeners as any, listenerOrPure as any);\r\n    }\r\n    if (isBoolean(listenerOrPure) && listenerOrPure) {\r\n      removeEvent();\r\n    }\r\n\r\n    const eventListenerKeys = keys(nameOrEventListeners) as (keyof EventListeners<EventArgs>)[];\r\n    const offFns: (() => void)[] = [];\r\n    each(eventListenerKeys, (key) => {\r\n      const eventListener = (nameOrEventListeners as EventListeners<EventArgs>)[key];\r\n      eventListener && push(offFns, addEvent(key, eventListener));\r\n    });\r\n\r\n    return runEachAndClear.bind(0, offFns);\r\n  }) as AddEvent<EventArgs>; // sorry!\r\n\r\n  const triggerEvent: TriggerEvent<EventArgs> = (name, args) => {\r\n    const eventSet = events.get(name);\r\n\r\n    each(from(eventSet), (event) => {\r\n      if (args && !isEmptyArray(args)) {\r\n        (event as (...eventArgs: EventArgs[keyof EventArgs]) => void).apply(0, args as any);\r\n      } else {\r\n        (event as () => void)();\r\n      }\r\n    });\r\n  };\r\n\r\n  addEvent(initialEventListeners || {});\r\n\r\n  return [addEvent, removeEvent, triggerEvent];\r\n};\r\n","import {\n  assignDeep,\n  each,\n  isObject,\n  keys,\n  isArray,\n  hasOwnProperty,\n  isFunction,\n  isEmptyObject,\n} from '~/support';\nimport type { DeepPartial, DeepReadonly } from '~/typings';\n\nconst opsStringify = (value: any) =>\n  JSON.stringify(value, (_, val) => {\n    if (isFunction(val)) {\n      throw new Error();\n    }\n    return val;\n  });\n\n/**\n * The overflow behavior of an axis.\n */\nexport type OverflowBehavior =\n  /** No scrolling is possible and the content is clipped. */\n  | 'hidden'\n  /** No scrolling is possible and the content isn't clipped. */\n  | 'visible'\n  /** Scrolling is possible if there is an overflow. */\n  | 'scroll'\n  /**\n   * If the other axis has no overflow the behavior is similar to `visible`.\n   * If the other axis has overflow the behavior is similar to `hidden`.\n   */\n  | 'visible-hidden'\n  /**\n   * If the other axis has no overflow the behavior is similar to `visible`.\n   * If the other axis has overflow the behavior is similar to `scroll`.\n   */\n  | 'visible-scroll';\n\n/**\n * The scrollbars visibility behavior.\n */\nexport type ScrollbarsVisibilityBehavior =\n  /** The scrollbars are always visible. */\n  | 'visible'\n  /** The scrollbars are always hidden. */\n  | 'hidden'\n  /** The scrollbars are only visibile if there is overflow. */\n  | 'auto';\n\n/**\n * The scrollbars auto hide behavior\n */\nexport type ScrollbarsAutoHideBehavior =\n  /** The scrollbars are never hidden automatically. */\n  | 'never'\n  /** The scrollbars are hidden unless the user scrolls. */\n  | 'scroll'\n  /** The scrollbars are hidden unless the pointer moves in the host element or the user scrolls. */\n  | 'move'\n  /** The scrollbars are hidden if the pointer leaves the host element or unless the user scrolls. */\n  | 'leave';\n\n/**\n * Describes the options of a OverlayScrollbars instance.\n */\nexport interface Options {\n  /** Whether the padding shall be absolute. */\n  paddingAbsolute: boolean;\n  /** Whether to show the native scrollbars. Has only an effect it the native scrollbars are overlaid. */\n  showNativeOverlaidScrollbars: boolean;\n  /** Customizes the automatic update behavior. */\n  update: {\n    /**\n     * The given Event(s) from the elements with the given selector(s) will trigger an update.\n     * Useful for everything the MutationObserver and ResizeObserver can't detect\n     * e.g.: and Images `load` event or the `transitionend` / `animationend` events.\n     */\n    elementEvents: Array<[elementSelector: string, eventNames: string]> | null;\n    /**\n     * The debounce which is used to detect content changes.\n     * If a tuple is provided you can customize the `timeout` and the `maxWait` in milliseconds.\n     * If a single number customizes only the `timeout`.\n     *\n     * If the `timeout` is `0`, a debounce still exists. (its executed via `requestAnimationFrame`).\n     */\n    debounce: [timeout: number, maxWait: number] | number | null;\n    /**\n     * HTML attributes which will trigger an update if they're changed.\n     * Basic attributes like `id`, `class`, `style` etc. are always observed and doesn't have to be added explicitly.\n     */\n    attributes: string[] | null;\n    /**\n     * A function which makes it possible to ignore a content mutation or null if nothing shall be ignored.\n     * @param mutation The MutationRecord from the MutationObserver.\n     * @returns A Truthy value if the mutation shall be ignored, a falsy value otherwise.\n     */\n    ignoreMutation: ((mutation: MutationRecord) => any) | null;\n  };\n  /** Customizes the overflow behavior per axis. */\n  overflow: {\n    /** The overflow behavior of the horizontal (x) axis. */\n    x: OverflowBehavior;\n    /** The overflow behavior of the vertical (y) axis. */\n    y: OverflowBehavior;\n  };\n  /** Customizes appearance of the scrollbars. */\n  scrollbars: {\n    /**\n     * The scrollbars theme.\n     * The theme value will be added as `class` to all `scrollbar` elements of the instance.\n     */\n    theme: string | null;\n    /** The scrollbars visibility behavior. */\n    visibility: ScrollbarsVisibilityBehavior;\n    /** The scrollbars auto hide behavior. */\n    autoHide: ScrollbarsAutoHideBehavior;\n    /** The scrollbars auto hide delay in milliseconds. */\n    autoHideDelay: number;\n    /** Whether its possible to drag the handle of a scrollbar to scroll the viewport. */\n    dragScroll: boolean;\n    /** Whether its possible to click the track of a scrollbar to scroll the viewport. */\n    clickScroll: boolean;\n    /**\n     * An array of pointer types which shall be supported.\n     * Common pointer types are: `mouse`, `pen` and `touch`.\n     * https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pointerType\n     */\n    pointers: string[] | null;\n  };\n}\n\nexport type ReadonlyOptions = DeepReadonly<Options>;\n\nexport type PartialOptions = DeepPartial<Options>;\n\nexport const defaultOptions: Options = {\n  paddingAbsolute: false,\n  showNativeOverlaidScrollbars: false,\n  update: {\n    elementEvents: [['img', 'load']],\n    debounce: [0, 33],\n    attributes: null,\n    ignoreMutation: null,\n  },\n  overflow: {\n    x: 'scroll',\n    y: 'scroll',\n  },\n  scrollbars: {\n    theme: 'os-theme-dark',\n    visibility: 'auto',\n    autoHide: 'never',\n    autoHideDelay: 1300,\n    dragScroll: true,\n    clickScroll: false,\n    pointers: ['mouse', 'touch', 'pen'],\n  },\n};\n\nexport const getOptionsDiff = <T>(currOptions: T, newOptions: DeepPartial<T>): DeepPartial<T> => {\n  const diff: DeepPartial<T> = {};\n  const optionsKeys = keys(newOptions).concat(keys(currOptions));\n\n  each(optionsKeys, (optionKey) => {\n    const currOptionValue = currOptions[optionKey];\n    const newOptionValue = newOptions[optionKey];\n\n    if (isObject(currOptionValue) && isObject(newOptionValue)) {\n      assignDeep((diff[optionKey] = {}), getOptionsDiff(currOptionValue, newOptionValue));\n      // delete empty nested objects\n      if (isEmptyObject(diff[optionKey])) {\n        delete diff[optionKey];\n      }\n    } else if (hasOwnProperty(newOptions, optionKey) && newOptionValue !== currOptionValue) {\n      let isDiff = true;\n\n      if (isArray(currOptionValue) || isArray(newOptionValue)) {\n        try {\n          if (opsStringify(currOptionValue) === opsStringify(newOptionValue)) {\n            isDiff = false;\n          }\n        } catch {}\n      }\n\n      if (isDiff) {\n        diff[optionKey] = newOptionValue;\n      }\n    }\n  });\n\n  return diff;\n};\n","export const classNameEnvironment = 'os-environment';\nexport const classNameEnvironmentFlexboxGlue = `${classNameEnvironment}-flexbox-glue`;\nexport const classNameEnvironmentFlexboxGlueMax = `${classNameEnvironmentFlexboxGlue}-max`;\n\nexport const dataAttributeHost = 'data-overlayscrollbars';\nexport const dataAttributeInitialize = 'data-overlayscrollbars-initialize';\nexport const dataAttributeHostOverflowX = `${dataAttributeHost}-overflow-x`;\nexport const dataAttributeHostOverflowY = `${dataAttributeHost}-overflow-y`;\nexport const dataValueHostOverflowVisible = 'overflowVisible';\nexport const dataValueHostScrollbarHidden = 'scrollbarHidden';\nexport const dataValueHostUpdating = 'updating';\nexport const classNamePadding = 'os-padding';\nexport const classNameViewport = 'os-viewport';\nexport const classNameViewportArrange = `${classNameViewport}-arrange`;\nexport const classNameContent = 'os-content';\nexport const classNameViewportScrollbarHidden = `${classNameViewport}-scrollbar-hidden`;\nexport const classNameOverflowVisible = `os-overflow-visible`;\n\nexport const classNameSizeObserver = 'os-size-observer';\nexport const classNameSizeObserverAppear = `${classNameSizeObserver}-appear`;\nexport const classNameSizeObserverListener = `${classNameSizeObserver}-listener`;\nexport const classNameSizeObserverListenerScroll = `${classNameSizeObserverListener}-scroll`;\nexport const classNameSizeObserverListenerItem = `${classNameSizeObserverListener}-item`;\nexport const classNameSizeObserverListenerItemFinal = `${classNameSizeObserverListenerItem}-final`;\n\nexport const classNameTrinsicObserver = 'os-trinsic-observer';\n\nexport const classNameScrollbarThemeNone = 'os-theme-none';\nexport const classNameScrollbar = 'os-scrollbar';\nexport const classNameScrollbarRtl = `${classNameScrollbar}-rtl`;\nexport const classNameScrollbarHorizontal = `${classNameScrollbar}-horizontal`;\nexport const classNameScrollbarVertical = `${classNameScrollbar}-vertical`;\nexport const classNameScrollbarTrack = `${classNameScrollbar}-track`;\nexport const classNameScrollbarHandle = `${classNameScrollbar}-handle`;\nexport const classNameScrollbarVisible = `${classNameScrollbar}-visible`;\nexport const classNameScrollbarCornerless = `${classNameScrollbar}-cornerless`;\nexport const classNameScrollbarTransitionless = `${classNameScrollbar}-transitionless`;\nexport const classNameScrollbarInteraction = `${classNameScrollbar}-interaction`;\nexport const classNameScrollbarUnusable = `${classNameScrollbar}-unusable`;\nexport const classNameScrollbarAutoHidden = `${classNameScrollbar}-auto-hidden`;\nexport const classNameScrollbarWheel = `${classNameScrollbar}-wheel`;\nexport const classNameScrollbarTrackInteractive = `${classNameScrollbarTrack}-interactive`;\nexport const classNameScrollbarHandleInteractive = `${classNameScrollbarHandle}-interactive`;\n","import { each, isArray, keys, push } from '~/support';\nimport type { OverlayScrollbars, OverlayScrollbarsStatic } from '~/overlayscrollbars';\n\n/** Describes the instance of a OverlayScrollbars plugin. */\nexport type PluginInstance =\n  /** A `static` plugin. Its neither bound to a instance nor to the static object. */\n  | Record<string, unknown>\n  /**\n   * A plugin which is bound to either a instance or to the static object.\n   * The function will be called multiple times. Once with the static object and each time a new instance is created.\n   * The plugin then can add new methods or fields to thow objects.\n   * These plugins should be side-effect free and deterministic. (same input produces same output)\n   */\n  | ((staticObj?: OverlayScrollbarsStatic, instanceObj?: OverlayScrollbars) => void);\n\n/** Describes a OverlayScrollbars plugin. */\nexport type Plugin<T extends PluginInstance = PluginInstance> = {\n  [pluginName: string]: T;\n};\n\nconst pluginRegistry: Record<string, PluginInstance> = {};\n\nexport const getPlugins = () => pluginRegistry;\n\nexport const addPlugin = (addedPlugin: Plugin | Plugin[]): Plugin[] => {\n  const result: Plugin[] = [];\n  each((isArray(addedPlugin) ? addedPlugin : [addedPlugin]) as Plugin[], (plugin) => {\n    // multiple \"sub-plugins\" per plugin object possible to support \"static\", \"instanceObj\" and \"staticObj\" sub-plugins per plugin\n    const pluginNameKeys = keys(plugin);\n    each(pluginNameKeys, (key) => {\n      push(result, (pluginRegistry[key] = plugin[key]));\n    });\n  });\n  return result;\n};\n","import { each, hasOwnProperty, keys, push, isEmptyObject } from '~/support/utils';\nimport { type, isArray, isUndefined, isPlainObject, isString } from '~/support/utils/types';\nimport type { PlainObject, DeepPartial } from '~/typings';\n\nexport type OptionsObjectType = Record<string, unknown>;\nexport type OptionsFunctionType = (this: any, ...args: any[]) => any;\nexport type OptionsTemplateType<T extends OptionsTemplateNativeTypes> = ExtractPropsKey<\n  OptionsTemplateTypeMap,\n  T\n>;\nexport type OptionsTemplateTypes = keyof OptionsTemplateTypeMap;\nexport type OptionsTemplateNativeTypes = OptionsTemplateTypeMap[keyof OptionsTemplateTypeMap];\n\nexport type OptionsTemplateValue<T extends OptionsTemplateNativeTypes = string> = T extends string\n  ? string extends T\n    ? OptionsTemplateValueNonEnum<T>\n    : string\n  : OptionsTemplateValueNonEnum<T>;\n\nexport type OptionsTemplate<T> = {\n  [P in keyof T]: T[P] extends OptionsObjectType\n    ? OptionsTemplate<T[P]>\n    : T[P] extends OptionsTemplateNativeTypes\n    ? OptionsTemplateValue<T[P]>\n    : never;\n};\n\nexport type OptionsValidationResult<T> = [\n  DeepPartial<T>, // validated\n  Record<string, unknown> // foreign\n];\n\ntype OptionsTemplateTypeMap = {\n  __TPL_boolean_TYPE__: boolean;\n  __TPL_number_TYPE__: number;\n  __TPL_string_TYPE__: string;\n  __TPL_array_TYPE__: Array<any> | ReadonlyArray<any>;\n  __TPL_function_TYPE__: OptionsFunctionType;\n  __TPL_null_TYPE__: null;\n  __TPL_object_TYPE__: OptionsObjectType;\n};\n\ntype OptionsTemplateValueNonEnum<T extends OptionsTemplateNativeTypes> =\n  | OptionsTemplateType<T>\n  | [OptionsTemplateType<T>, ...Array<OptionsTemplateTypes>];\n\ntype ExtractPropsKey<T, TProps extends T[keyof T]> = {\n  [P in keyof T]: TProps extends T[P] ? P : never;\n}[keyof T];\n\ntype OptionsTemplateTypesDictionary = {\n  readonly boolean: OptionsTemplateType<boolean>;\n  readonly number: OptionsTemplateType<number>;\n  readonly string: OptionsTemplateType<string>;\n  readonly array: OptionsTemplateType<Array<any>>;\n  readonly object: OptionsTemplateType<OptionsObjectType>;\n  readonly function: OptionsTemplateType<OptionsFunctionType>;\n  readonly null: OptionsTemplateType<null>;\n};\n\nconst optionsTemplateTypes: OptionsTemplateTypesDictionary = {\n  boolean: '__TPL_boolean_TYPE__',\n  number: '__TPL_number_TYPE__',\n  string: '__TPL_string_TYPE__',\n  array: '__TPL_array_TYPE__',\n  object: '__TPL_object_TYPE__',\n  function: '__TPL_function_TYPE__',\n  null: '__TPL_null_TYPE__',\n};\n\n/**\n * Validates the given options object according to the given template object and returns a object which looks like:\n * {\n *  foreign   : a object which consists of properties which aren't defined inside the template. (foreign properties)\n *  validated : a object which consists only of valid properties. (property name is inside the template and value has a correct type)\n * }\n * @param template The template according to which the options object shall be validated.\n * @param options The options object which shall be validated.\n * @param optionsDiff When provided the returned validated object will only have properties which are different to this objects properties.\n * Example (assume all properties are valid to the template):\n * Options object            : { a: 'a', b: 'b', c: 'c' }\n * optionsDiff object        : { a: 'a', b: 'b', c: undefined }\n * Returned validated object : { c: 'c' }\n * Because the value of the properties a and b didn't change, they aren't included in the returned object.\n * Without the optionsDiff object the returned validated object would be: { a: 'a', b: 'b', c: 'c' }\n * @param doWriteErrors True if errors shall be logged into the console, false otherwise.\n * @param propPath The propertyPath which lead to this object. (used for error logging)\n */\nconst validateRecursive = <T extends PlainObject>(\n  template: OptionsTemplate<T>,\n  options: DeepPartial<T>,\n  doWriteErrors?: boolean,\n  propPath?: string\n): OptionsValidationResult<T> => {\n  const validatedOptions: DeepPartial<T> = {};\n  const optionsCopy: DeepPartial<T> = { ...options };\n  const props = keys(template).filter((prop) => hasOwnProperty(options, prop));\n\n  each(props, (prop: Extract<keyof T, string>) => {\n    const optionsValue: any = options[prop];\n    const templateValue: PlainObject | string | OptionsTemplateTypes | Array<OptionsTemplateTypes> =\n      template[prop];\n    const templateIsComplex = isPlainObject(templateValue);\n    const propPrefix = propPath ? `${propPath}.` : '';\n\n    // if the template has a object as value, it means that the options are complex (verschachtelt)\n    if (templateIsComplex && isPlainObject(optionsValue)) {\n      const [validated, foreign] = validateRecursive(\n        templateValue as T,\n        optionsValue,\n        doWriteErrors,\n        propPrefix + prop\n      );\n      validatedOptions[prop] = validated as any;\n      optionsCopy[prop] = foreign as any;\n\n      each([optionsCopy, validatedOptions], (value) => {\n        if (isEmptyObject(value[prop])) {\n          delete value[prop];\n        }\n      });\n    } else if (!templateIsComplex) {\n      let isValid = false;\n      const errorEnumStrings: Array<string> = [];\n      const errorPossibleTypes: Array<string> = [];\n      const optionsValueType = type(optionsValue);\n      const templateValueArr: Array<string | OptionsTemplateTypes> = !isArray(templateValue)\n        ? [templateValue as string | OptionsTemplateTypes]\n        : (templateValue as Array<OptionsTemplateTypes>);\n\n      each(templateValueArr, (currTemplateType) => {\n        // if currType value isn't inside possibleTemplateTypes we assume its a enum string value\n        let typeString: string | undefined;\n        each(optionsTemplateTypes, (value: string, key: string) => {\n          if (value === currTemplateType) {\n            typeString = key;\n          }\n        });\n        const isEnumString = isUndefined(typeString);\n        if (isEnumString && isString(optionsValue)) {\n          // split it into a array which contains all possible values for example: [\"yes\", \"no\", \"maybe\"]\n          const enumStringSplit = currTemplateType.split(' ');\n          isValid = !!enumStringSplit.find((possibility) => possibility === optionsValue);\n\n          // build error message\n          push(errorEnumStrings, enumStringSplit);\n        } else {\n          isValid = optionsTemplateTypes[optionsValueType] === currTemplateType;\n        }\n\n        // build error message\n        push(errorPossibleTypes, isEnumString ? optionsTemplateTypes.string : typeString!);\n\n        // continue if invalid, break if valid\n        return !isValid;\n      });\n\n      if (isValid) {\n        validatedOptions[prop] = optionsValue;\n      } else if (doWriteErrors) {\n        console.warn(\n          `${\n            `The option \"${propPrefix}${prop}\" wasn't set, because it doesn't accept the type [ ${optionsValueType.toUpperCase()} ] with the value of \"${optionsValue}\".\\r\\n` +\n            `Accepted types are: [ ${errorPossibleTypes.join(', ').toUpperCase()} ].\\r\\n`\n          }${\n            errorEnumStrings.length > 0\n              ? `\\r\\nValid strings are: [ ${errorEnumStrings.join(', ')} ].`\n              : ''\n          }`\n        );\n      }\n\n      delete optionsCopy[prop];\n    }\n  });\n\n  return [validatedOptions, optionsCopy]; // optionsCopy equals now to foreign options\n};\n\n/**\n * Validates the given options object according to the given template object and returns a tuple which looks like:\n * [\n *  validated : a object which consists only of valid properties. (property name is inside the template and value has a correct type)\n *  foreign   : a object which consists of properties which aren't defined inside the template. (foreign properties)\n * ]\n * @param template The template according to which the options object shall be validated.\n * @param options The options object which shall be validated.\n * @param doWriteErrors True if errors shall be logged into the console, false otherwise.\n */\nconst validateOptions = <T extends PlainObject>(\n  template: OptionsTemplate<T>,\n  options: DeepPartial<T>,\n  doWriteErrors?: boolean\n): OptionsValidationResult<T> => validateRecursive<T>(template, options, doWriteErrors);\n\nexport { validateOptions, optionsTemplateTypes };\n","import {\n  validateOptions,\n  optionsTemplateTypes as oTypes,\n} from '~/plugins/optionsValidationPlugin/validation';\nimport type {\n  Options,\n  PartialOptions,\n  OverflowBehavior,\n  ScrollbarsVisibilityBehavior,\n  ScrollbarsAutoHideBehavior,\n} from '~/options';\nimport type {\n  OptionsTemplate,\n  OptionsTemplateValue,\n} from '~/plugins/optionsValidationPlugin/validation';\nimport type { Plugin } from '~/plugins';\n\nconst numberAllowedValues: OptionsTemplateValue<number> = oTypes.number;\nconst booleanAllowedValues: OptionsTemplateValue<boolean> = oTypes.boolean;\nconst arrayNullValues: OptionsTemplateValue<Array<unknown> | null> = [oTypes.array, oTypes.null];\nconst overflowAllowedValues: OptionsTemplateValue<OverflowBehavior> =\n  'hidden scroll visible visible-hidden';\nconst scrollbarsVisibilityAllowedValues: OptionsTemplateValue<ScrollbarsVisibilityBehavior> =\n  'visible hidden auto';\nconst scrollbarsAutoHideAllowedValues: OptionsTemplateValue<ScrollbarsAutoHideBehavior> =\n  'never scroll leavemove';\n\nconst optionsTemplate: OptionsTemplate<Options> = {\n  // resize: resizeAllowedValues, // none || both  || horizontal || vertical || n || b ||\n  paddingAbsolute: booleanAllowedValues, // true || false\n  showNativeOverlaidScrollbars: booleanAllowedValues, // true || false\n  update: {\n    elementEvents: arrayNullValues, // array of tuples || null\n    attributes: arrayNullValues,\n    debounce: [oTypes.number, oTypes.array, oTypes.null], // number || number array || null\n    ignoreMutation: [oTypes.function, oTypes.null], // function || null\n  },\n  overflow: {\n    x: overflowAllowedValues, // visible-hidden  || visible-scroll || hidden || scrol\n    y: overflowAllowedValues, // visible-hidden  || visible-scroll || hidden || scrol\n  },\n  scrollbars: {\n    theme: [oTypes.string, oTypes.null], // string || null\n    visibility: scrollbarsVisibilityAllowedValues, // visible || hidden || auto || v ||\n    autoHide: scrollbarsAutoHideAllowedValues, // never || scroll || leave || move ||\n    autoHideDelay: numberAllowedValues, // number\n    dragScroll: booleanAllowedValues, // true || false\n    clickScroll: booleanAllowedValues, // true || false\n    pointers: [oTypes.array, oTypes.null], // string array\n  },\n  /*\n  textarea: {\n    dynWidth: booleanAllowedValues, // true || false\n    dynHeight: booleanAllowedValues, // true || false\n    inheritedAttrs: stringArrayNullAllowedValues, // string || array || nul\n  },\n  */\n};\n\nexport type OptionsValidationPluginInstance = {\n  _: (options: PartialOptions, doWriteErrors?: boolean) => PartialOptions;\n};\n\nexport const optionsValidationPluginName = '__osOptionsValidationPlugin';\n\nexport const OptionsValidationPlugin: Plugin<OptionsValidationPluginInstance> =\n  /* @__PURE__ */ (() => ({\n    [optionsValidationPluginName]: {\n      _: (options: PartialOptions, doWriteErrors?: boolean) => {\n        const [validated, foreign] = validateOptions(optionsTemplate, options, doWriteErrors);\n        return { ...foreign, ...validated };\n      },\n    },\n  }))();\n","import {\n  createDOM,\n  style,\n  appendChildren,\n  offsetSize,\n  scrollLeft,\n  scrollTop,\n  on,\n  addClass,\n  equalWH,\n  push,\n  cAF,\n  rAF,\n  stopPropagation,\n} from '~/support';\nimport {\n  classNameSizeObserverListenerScroll,\n  classNameSizeObserverListenerItem,\n  classNameSizeObserverListenerItemFinal,\n} from '~/classnames';\nimport type { Plugin } from '~/plugins';\n\nexport type SizeObserverPluginInstance = {\n  _: (\n    listenerElement: HTMLElement,\n    onSizeChangedCallback: (appear: boolean) => any,\n    observeAppearChange: boolean\n  ) => [appearCallback: () => any, offFns: (() => any)[]];\n};\n\nconst scrollAmount = 3333333;\nconst scrollEventName = 'scroll';\nexport const sizeObserverPluginName = '__osSizeObserverPlugin';\n\nexport const SizeObserverPlugin: Plugin<SizeObserverPluginInstance> = /* @__PURE__ */ (() => ({\n  [sizeObserverPluginName]: {\n    _: (listenerElement, onSizeChangedCallback, observeAppearChange) => {\n      const observerElementChildren = createDOM(\n        `<div class=\"${classNameSizeObserverListenerItem}\" dir=\"ltr\"><div class=\"${classNameSizeObserverListenerItem}\"><div class=\"${classNameSizeObserverListenerItemFinal}\"></div></div><div class=\"${classNameSizeObserverListenerItem}\"><div class=\"${classNameSizeObserverListenerItemFinal}\" style=\"width: 200%; height: 200%\"></div></div></div>`\n      );\n      appendChildren(listenerElement, observerElementChildren);\n      addClass(listenerElement, classNameSizeObserverListenerScroll);\n      const observerElementChildrenRoot = observerElementChildren[0] as HTMLElement;\n      const shrinkElement = observerElementChildrenRoot.lastChild as HTMLElement;\n      const expandElement = observerElementChildrenRoot.firstChild as HTMLElement;\n      const expandElementChild = expandElement?.firstChild as HTMLElement;\n\n      let cacheSize = offsetSize(observerElementChildrenRoot);\n      let currSize = cacheSize;\n      let isDirty = false;\n      let rAFId: number;\n\n      const reset = () => {\n        scrollLeft(expandElement, scrollAmount);\n        scrollTop(expandElement, scrollAmount);\n        scrollLeft(shrinkElement, scrollAmount);\n        scrollTop(shrinkElement, scrollAmount);\n      };\n      const onResized = (appear?: unknown) => {\n        rAFId = 0;\n        if (isDirty) {\n          cacheSize = currSize;\n          onSizeChangedCallback(appear === true);\n        }\n      };\n      const onScroll = (scrollEvent?: Event | false) => {\n        currSize = offsetSize(observerElementChildrenRoot);\n        isDirty = !scrollEvent || !equalWH(currSize, cacheSize);\n\n        if (scrollEvent) {\n          stopPropagation(scrollEvent);\n\n          if (isDirty && !rAFId) {\n            cAF!(rAFId);\n            rAFId = rAF!(onResized);\n          }\n        } else {\n          onResized(scrollEvent === false);\n        }\n\n        reset();\n      };\n      const offListeners = push(\n        [],\n        [on(expandElement, scrollEventName, onScroll), on(shrinkElement, scrollEventName, onScroll)]\n      );\n\n      // lets assume that the divs will never be that large and a constant value is enough\n      style(expandElementChild, {\n        width: scrollAmount,\n        height: scrollAmount,\n      });\n\n      rAF!(reset);\n\n      return [observeAppearChange ? onScroll.bind(0, false) : reset, offListeners];\n    },\n  },\n}))();\n","import {\n  keys,\n  attr,\n  style,\n  addClass,\n  removeClass,\n  noop,\n  each,\n  assignDeep,\n  windowSize,\n} from '~/support';\nimport { classNameViewportArrange } from '~/classnames';\nimport type { WH, UpdateCache, XY } from '~/support';\nimport type { StyleObject } from '~/typings';\nimport type { StructureSetupState } from '~/setups/structureSetup';\nimport type {\n  ViewportOverflowState,\n  GetViewportOverflowState,\n  HideNativeScrollbars,\n} from '~/setups/structureSetup/updateSegments/overflowUpdateSegment';\nimport type { InternalEnvironment } from '~/environment';\nimport type { Plugin } from '~/plugins';\n\nexport type ArrangeViewport = (\n  viewportOverflowState: ViewportOverflowState,\n  viewportScrollSize: WH<number>,\n  sizeFraction: WH<number>,\n  directionIsRTL: boolean\n) => boolean;\n\nexport type UndoViewportArrangeResult = [\n  redoViewportArrange: () => void,\n  overflowState?: ViewportOverflowState\n];\n\nexport type UndoArrangeViewport = (\n  showNativeOverlaidScrollbars: boolean,\n  directionIsRTL: boolean,\n  viewportOverflowState?: ViewportOverflowState\n) => UndoViewportArrangeResult;\n\nexport type ScrollbarsHidingPluginInstance = {\n  _createUniqueViewportArrangeElement(env: InternalEnvironment): HTMLStyleElement | false;\n  _overflowUpdateSegment(\n    doViewportArrange: boolean,\n    flexboxGlue: boolean,\n    viewport: HTMLElement,\n    viewportArrange: HTMLStyleElement | false | null | undefined,\n    getState: () => StructureSetupState,\n    getViewportOverflowState: GetViewportOverflowState,\n    hideNativeScrollbars: HideNativeScrollbars\n  ): [ArrangeViewport, UndoArrangeViewport];\n  _envWindowZoom(): (\n    envInstance: InternalEnvironment,\n    updateNativeScrollbarSizeCache: UpdateCache<XY<number>>,\n    triggerEvent: () => void\n  ) => void;\n};\n\nlet contentArrangeCounter = 0;\nconst { round, abs } = Math;\nconst getWindowDPR = (): number => {\n  // eslint-disable-next-line\n  // @ts-ignore\n  const dDPI = window.screen.deviceXDPI || 0;\n  // eslint-disable-next-line\n  // @ts-ignore\n  const sDPI = window.screen.logicalXDPI || 1;\n  return window.devicePixelRatio || dDPI / sDPI;\n};\n\nconst diffBiggerThanOne = (valOne: number, valTwo: number): boolean => {\n  const absValOne = abs(valOne);\n  const absValTwo = abs(valTwo);\n  return !(absValOne === absValTwo || absValOne + 1 === absValTwo || absValOne - 1 === absValTwo);\n};\n\nexport const scrollbarsHidingPluginName = '__osScrollbarsHidingPlugin';\n\nexport const ScrollbarsHidingPlugin: Plugin<ScrollbarsHidingPluginInstance> =\n  /* @__PURE__ */ (() => ({\n    [scrollbarsHidingPluginName]: {\n      _createUniqueViewportArrangeElement: (env: InternalEnvironment) => {\n        const { _nativeScrollbarsHiding, _nativeScrollbarsOverlaid, _cssCustomProperties } = env;\n        const create =\n          !_cssCustomProperties &&\n          !_nativeScrollbarsHiding &&\n          (_nativeScrollbarsOverlaid.x || _nativeScrollbarsOverlaid.y);\n        const result = create ? document.createElement('style') : false;\n\n        if (result) {\n          attr(result, 'id', `${classNameViewportArrange}-${contentArrangeCounter}`);\n          contentArrangeCounter++;\n        }\n\n        return result;\n      },\n      _overflowUpdateSegment: (\n        doViewportArrange,\n        flexboxGlue,\n        viewport,\n        viewportArrange,\n        getState,\n        getViewportOverflowState,\n        hideNativeScrollbars\n      ) => {\n        /**\n         * Sets the styles of the viewport arrange element.\n         * @param viewportOverflowState The viewport overflow state according to which the scrollbars shall be hidden.\n         * @param viewportScrollSize The content scroll size.\n         * @param directionIsRTL Whether the direction is RTL or not.\n         * @returns A boolean which indicates whether the viewport arrange element was adjusted.\n         */\n        const arrangeViewport: ArrangeViewport = (\n          viewportOverflowState,\n          viewportScrollSize,\n          sizeFraction,\n          directionIsRTL\n        ) => {\n          if (doViewportArrange) {\n            const { _viewportPaddingStyle } = getState();\n            const { _scrollbarsHideOffset, _scrollbarsHideOffsetArrange } = viewportOverflowState;\n            const { x: arrangeX, y: arrangeY } = _scrollbarsHideOffsetArrange;\n            const { x: hideOffsetX, y: hideOffsetY } = _scrollbarsHideOffset;\n            const viewportArrangeHorizontalPaddingKey: keyof StyleObject = directionIsRTL\n              ? 'paddingRight'\n              : 'paddingLeft';\n            const viewportArrangeHorizontalPaddingValue = _viewportPaddingStyle[\n              viewportArrangeHorizontalPaddingKey\n            ] as number;\n            const viewportArrangeVerticalPaddingValue = _viewportPaddingStyle.paddingTop as number;\n            const fractionalContentWidth = viewportScrollSize.w + sizeFraction.w;\n            const fractionalContenHeight = viewportScrollSize.h + sizeFraction.h;\n            const arrangeSize = {\n              w:\n                hideOffsetY && arrangeY\n                  ? `${\n                      hideOffsetY + fractionalContentWidth - viewportArrangeHorizontalPaddingValue\n                    }px`\n                  : '',\n              h:\n                hideOffsetX && arrangeX\n                  ? `${\n                      hideOffsetX + fractionalContenHeight - viewportArrangeVerticalPaddingValue\n                    }px`\n                  : '',\n            };\n\n            // adjust content arrange / before element\n            if (viewportArrange) {\n              const { sheet } = viewportArrange;\n              if (sheet) {\n                const { cssRules } = sheet;\n                if (cssRules) {\n                  if (!cssRules.length) {\n                    sheet.insertRule(\n                      `#${attr(viewportArrange, 'id')} + .${classNameViewportArrange}::before {}`,\n                      0\n                    );\n                  }\n\n                  // @ts-ignore\n                  const ruleStyle = cssRules[0].style;\n\n                  ruleStyle.width = arrangeSize.w;\n                  ruleStyle.height = arrangeSize.h;\n                }\n              }\n            } else {\n              style<'--os-vaw' | '--os-vah'>(viewport, {\n                '--os-vaw': arrangeSize.w,\n                '--os-vah': arrangeSize.h,\n              });\n            }\n          }\n\n          return doViewportArrange;\n        };\n\n        /**\n         * Removes all styles applied because of the viewport arrange strategy.\n         * @param showNativeOverlaidScrollbars Whether native overlaid scrollbars are shown instead of hidden.\n         * @param directionIsRTL Whether the direction is RTL or not.\n         * @param viewportOverflowState The currentviewport overflow state or undefined if it has to be determined.\n         * @returns A object with a function which applies all the removed styles and the determined viewport vverflow state.\n         */\n        const undoViewportArrange: UndoArrangeViewport = (\n          showNativeOverlaidScrollbars,\n          directionIsRTL,\n          viewportOverflowState?\n        ) => {\n          if (doViewportArrange) {\n            const finalViewportOverflowState =\n              viewportOverflowState || getViewportOverflowState(showNativeOverlaidScrollbars);\n            const { _viewportPaddingStyle: viewportPaddingStyle } = getState();\n            const { _scrollbarsHideOffsetArrange } = finalViewportOverflowState;\n            const { x: arrangeX, y: arrangeY } = _scrollbarsHideOffsetArrange;\n            const finalPaddingStyle: StyleObject = {};\n            const assignProps = (props: string) =>\n              each(props.split(' '), (prop) => {\n                finalPaddingStyle[prop] = viewportPaddingStyle[prop];\n              });\n\n            if (arrangeX) {\n              assignProps('marginBottom paddingTop paddingBottom');\n            }\n\n            if (arrangeY) {\n              assignProps('marginLeft marginRight paddingLeft paddingRight');\n            }\n\n            const prevStyle = style(viewport, keys(finalPaddingStyle));\n\n            removeClass(viewport, classNameViewportArrange);\n\n            if (!flexboxGlue) {\n              finalPaddingStyle.height = '';\n            }\n\n            style(viewport, finalPaddingStyle);\n\n            return [\n              () => {\n                hideNativeScrollbars(\n                  finalViewportOverflowState,\n                  directionIsRTL,\n                  doViewportArrange,\n                  prevStyle\n                );\n                style(viewport, prevStyle);\n                addClass(viewport, classNameViewportArrange);\n              },\n              finalViewportOverflowState,\n            ];\n          }\n          return [noop];\n        };\n\n        return [arrangeViewport, undoViewportArrange];\n      },\n      _envWindowZoom: () => {\n        let size = { w: 0, h: 0 };\n        let dpr = 0;\n\n        return (envInstance, updateNativeScrollbarSizeCache, triggerEvent) => {\n          const sizeNew = windowSize();\n          const deltaSize = {\n            w: sizeNew.w - size.w,\n            h: sizeNew.h - size.h,\n          };\n\n          if (deltaSize.w === 0 && deltaSize.h === 0) {\n            return;\n          }\n\n          const deltaAbsSize = {\n            w: abs(deltaSize.w),\n            h: abs(deltaSize.h),\n          };\n          const deltaAbsRatio = {\n            w: abs(round(sizeNew.w / (size.w / 100.0))),\n            h: abs(round(sizeNew.h / (size.h / 100.0))),\n          };\n          const dprNew = getWindowDPR();\n          const deltaIsBigger = deltaAbsSize.w > 2 && deltaAbsSize.h > 2;\n          const difference = !diffBiggerThanOne(deltaAbsRatio.w, deltaAbsRatio.h);\n          const dprChanged = dprNew !== dpr && dprNew > 0;\n          const isZoom = deltaIsBigger && difference && dprChanged;\n\n          if (isZoom) {\n            const [scrollbarSize, scrollbarSizeChanged] = updateNativeScrollbarSizeCache();\n\n            assignDeep(envInstance._nativeScrollbarsSize, scrollbarSize); // keep the object same!\n\n            if (scrollbarSizeChanged) {\n              triggerEvent();\n            }\n          }\n\n          size = sizeNew;\n          dpr = dprNew;\n        };\n      },\n    },\n  }))();\n","import { animateNumber, noop } from '~/support';\nimport type { Plugin } from '~/plugins';\n\nexport type ClickScrollPluginInstance = {\n  _: (\n    moveHandleRelative: (deltaMovement: number) => void,\n    getHandleOffset: (handleRect?: DOMRect, trackRect?: DOMRect) => number,\n    startOffset: number,\n    handleLength: number,\n    relativeTrackPointerOffset: number\n  ) => () => void;\n};\n\nexport const clickScrollPluginName = '__osClickScrollPlugin';\n\nexport const ClickScrollPlugin: Plugin<ClickScrollPluginInstance> = /* @__PURE__ */ (() => ({\n  [clickScrollPluginName]: {\n    _: (\n      moveHandleRelative,\n      getHandleOffset,\n      startOffset,\n      handleLength,\n      relativeTrackPointerOffset\n    ) => {\n      // click scroll animation\n      let iteration = 0;\n      let clear = noop;\n      const animateClickScroll = (clickScrollProgress: number) => {\n        clear = animateNumber(\n          clickScrollProgress,\n          clickScrollProgress + handleLength * Math.sign(startOffset),\n          133,\n          (animationProgress, _, animationCompleted) => {\n            moveHandleRelative(animationProgress);\n            const handleStartBound = getHandleOffset();\n            const handleEndBound = handleStartBound + handleLength;\n            const mouseBetweenHandleBounds =\n              relativeTrackPointerOffset >= handleStartBound &&\n              relativeTrackPointerOffset <= handleEndBound;\n\n            if (animationCompleted && !mouseBetweenHandleBounds) {\n              if (iteration) {\n                animateClickScroll(animationProgress);\n              } else {\n                const firstIterationPauseTimeout = setTimeout(() => {\n                  animateClickScroll(animationProgress);\n                }, 222);\n                clear = () => {\n                  clearTimeout(firstIterationPauseTimeout);\n                };\n              }\n              iteration++;\n            }\n          }\n        );\n      };\n\n      animateClickScroll(0);\n\n      return () => clear();\n    },\n  },\n}))();\n","import {\n  createDOM,\n  addClass,\n  style,\n  appendChildren,\n  fractionalSize,\n  clientSize,\n  absoluteCoordinates,\n  offsetSize,\n  scrollLeft,\n  removeAttr,\n  removeElements,\n  equalBCRWH,\n  getBoundingClientRect,\n  assignDeep,\n  cssProperty,\n  createCache,\n  equalXY,\n  createEventListenerHub,\n  debounce,\n} from '~/support';\nimport {\n  classNameEnvironment,\n  classNameEnvironmentFlexboxGlue,\n  classNameEnvironmentFlexboxGlueMax,\n  classNameViewportScrollbarHidden,\n} from '~/classnames';\nimport { defaultOptions } from '~/options';\nimport { getPlugins, scrollbarsHidingPluginName } from '~/plugins';\nimport type { XY, EventListener } from '~/support';\nimport type { Options, PartialOptions } from '~/options';\nimport type { ScrollbarsHidingPluginInstance } from '~/plugins';\nimport type { Initialization, PartialInitialization } from '~/initialization';\n\ntype EnvironmentEventArgs = {\n  z: [];\n  r: [];\n};\n\n/**\n * Describes the OverlayScrollbars environment.\n */\nexport interface Environment {\n  /** The native scrollbars size of the browser / system. */\n  scrollbarsSize: XY<number>;\n  /** Whether the native scrollbars are overlaid. */\n  scrollbarsOverlaid: XY<boolean>;\n  /** Whether the browser supports native scrollbars hiding. */\n  scrollbarsHiding: boolean;\n  /** The rtl scroll behavior of the browser. */\n  rtlScrollBehavior: { n: boolean; i: boolean };\n  /** Whether the browser supports all needed Flexbox features for OverlayScrollbars to work in a more performant way. */\n  flexboxGlue: boolean;\n  /** Whether the browser supports custom css properties. (also known as css variables) */\n  cssCustomProperties: boolean;\n  /** The default Initialization to use if nothing else is specified. */\n  staticDefaultInitialization: Initialization;\n  /** The default Options to use if nothing else is specified. */\n  staticDefaultOptions: Options;\n\n  /** Returns the current default Initialization. */\n  getDefaultInitialization(): Initialization;\n  /** Returns the current default Options. */\n  getDefaultOptions(): Options;\n\n  /**\n   * Sets a new default Initialization.\n   * If the new default Initialization is partially filled, its deeply merged with the current default Initialization.\n   * @param newDefaultInitialization The new default Initialization.\n   * @returns The current default Initialization.\n   */\n  setDefaultInitialization(newDefaultInitialization: PartialInitialization): Initialization;\n  /**\n   * Sets new default Options.\n   * If the new default Options are partially filled, they're deeply merged with the current default Options.\n   * @param newDefaultOptions The new default Options.\n   * @returns The current default options.\n   */\n  setDefaultOptions(newDefaultOptions: PartialOptions): Options;\n}\n\nexport interface InternalEnvironment {\n  readonly _nativeScrollbarsSize: XY;\n  readonly _nativeScrollbarsOverlaid: XY<boolean>;\n  readonly _nativeScrollbarsHiding: boolean;\n  readonly _rtlScrollBehavior: { n: boolean; i: boolean };\n  readonly _flexboxGlue: boolean;\n  readonly _cssCustomProperties: boolean;\n  readonly _staticDefaultInitialization: Initialization;\n  readonly _staticDefaultOptions: Options;\n  _addZoomListener(listener: EventListener<EnvironmentEventArgs, 'z'>): () => void;\n  _addResizeListener(listener: EventListener<EnvironmentEventArgs, 'r'>): () => void;\n  _getDefaultInitialization(): Initialization;\n  _setDefaultInitialization(newInitialization: PartialInitialization): Initialization;\n  _getDefaultOptions(): Options;\n  _setDefaultOptions(newDefaultOptions: PartialOptions): Options;\n}\n\nlet environmentInstance: InternalEnvironment;\n\nconst getNativeScrollbarSize = (\n  body: HTMLElement,\n  measureElm: HTMLElement,\n  measureElmChild: HTMLElement,\n  clear?: boolean\n): XY => {\n  appendChildren(body, measureElm);\n\n  const cSize = clientSize(measureElm);\n  const oSize = offsetSize(measureElm);\n  const fSize = fractionalSize(measureElmChild);\n\n  clear && removeElements(measureElm);\n\n  return {\n    x: oSize.h - cSize.h + fSize.h,\n    y: oSize.w - cSize.w + fSize.w,\n  };\n};\n\nconst getNativeScrollbarsHiding = (testElm: HTMLElement): boolean => {\n  let result = false;\n  const revertClass = addClass(testElm, classNameViewportScrollbarHidden);\n  try {\n    result =\n      style(testElm, cssProperty('scrollbar-width')) === 'none' ||\n      window.getComputedStyle(testElm, '::-webkit-scrollbar').getPropertyValue('display') ===\n        'none';\n  } catch (ex) {}\n  revertClass();\n  return result;\n};\n\nconst getRtlScrollBehavior = (\n  parentElm: HTMLElement,\n  childElm: HTMLElement\n): { i: boolean; n: boolean } => {\n  const strHidden = 'hidden';\n  style(parentElm, { overflowX: strHidden, overflowY: strHidden, direction: 'rtl' });\n  scrollLeft(parentElm, 0);\n\n  const parentOffset = absoluteCoordinates(parentElm);\n  const childOffset = absoluteCoordinates(childElm);\n  scrollLeft(parentElm, -999); // https://github.com/KingSora/OverlayScrollbars/issues/187\n  const childOffsetAfterScroll = absoluteCoordinates(childElm);\n  return {\n    /**\n     * origin direction = determines if the zero scroll position is on the left or right side\n     * 'i' means 'invert' (i === true means that the axis must be inverted to be correct)\n     * true = on the left side\n     * false = on the right side\n     */\n    i: parentOffset.x === childOffset.x,\n    /**\n     * negative = determines if the maximum scroll is positive or negative\n     * 'n' means 'negate' (n === true means that the axis must be negated to be correct)\n     * true = negative\n     * false = positive\n     */\n    n: childOffset.x !== childOffsetAfterScroll.x,\n  };\n};\n\nconst getFlexboxGlue = (parentElm: HTMLElement, childElm: HTMLElement): boolean => {\n  const revertFbxGlue = addClass(parentElm, classNameEnvironmentFlexboxGlue);\n  const minOffsetsizeParent = getBoundingClientRect(parentElm);\n  const minOffsetsize = getBoundingClientRect(childElm);\n  const supportsMin = equalBCRWH(minOffsetsize, minOffsetsizeParent, true);\n\n  const revertFbxGlueMax = addClass(parentElm, classNameEnvironmentFlexboxGlueMax);\n  const maxOffsetsizeParent = getBoundingClientRect(parentElm);\n  const maxOffsetsize = getBoundingClientRect(childElm);\n  const supportsMax = equalBCRWH(maxOffsetsize, maxOffsetsizeParent, true);\n\n  revertFbxGlue();\n  revertFbxGlueMax();\n\n  return supportsMin && supportsMax;\n};\n\nconst createEnvironment = (): InternalEnvironment => {\n  const { body } = document;\n  const envDOM = createDOM(`<div class=\"${classNameEnvironment}\"><div></div></div>`);\n  const envElm = envDOM[0] as HTMLElement;\n  const envChildElm = envElm.firstChild as HTMLElement;\n  const [addEvent, , triggerEvent] = createEventListenerHub<EnvironmentEventArgs>();\n  const [updateNativeScrollbarSizeCache, getNativeScrollbarSizeCache] = createCache(\n    {\n      _initialValue: getNativeScrollbarSize(body, envElm, envChildElm),\n      _equal: equalXY,\n    },\n    getNativeScrollbarSize.bind(0, body, envElm, envChildElm, true)\n  );\n  const [nativeScrollbarsSize] = getNativeScrollbarSizeCache();\n  const nativeScrollbarsHiding = getNativeScrollbarsHiding(envElm);\n  const nativeScrollbarsOverlaid = {\n    x: nativeScrollbarsSize.x === 0,\n    y: nativeScrollbarsSize.y === 0,\n  };\n  const staticDefaultInitialization: Initialization = {\n    elements: {\n      host: null,\n      padding: !nativeScrollbarsHiding,\n      viewport: (target) =>\n        nativeScrollbarsHiding && target === target.ownerDocument.body && target,\n      content: false,\n    },\n    scrollbars: {\n      slot: true,\n    },\n    cancel: {\n      nativeScrollbarsOverlaid: false,\n      body: null,\n    },\n  };\n  const staticDefaultOptions = assignDeep({}, defaultOptions);\n  const getDefaultOptions = (assignDeep as typeof assignDeep<Options, Options>).bind(\n    0,\n    {} as Options,\n    staticDefaultOptions\n  );\n  const getDefaultInitialization = (\n    assignDeep as typeof assignDeep<Initialization, Initialization>\n  ).bind(0, {} as Initialization, staticDefaultInitialization);\n\n  const env: InternalEnvironment = {\n    _nativeScrollbarsSize: nativeScrollbarsSize,\n    _nativeScrollbarsOverlaid: nativeScrollbarsOverlaid,\n    _nativeScrollbarsHiding: nativeScrollbarsHiding,\n    _cssCustomProperties: style(envElm, 'zIndex') === '-1',\n    _rtlScrollBehavior: getRtlScrollBehavior(envElm, envChildElm),\n    _flexboxGlue: getFlexboxGlue(envElm, envChildElm),\n    _addZoomListener: addEvent.bind(0, 'z'),\n    _addResizeListener: addEvent.bind(0, 'r'),\n    _getDefaultInitialization: getDefaultInitialization,\n    _setDefaultInitialization: (newInitializationStrategy) =>\n      assignDeep(staticDefaultInitialization, newInitializationStrategy) &&\n      getDefaultInitialization(),\n    _getDefaultOptions: getDefaultOptions,\n    _setDefaultOptions: (newDefaultOptions) =>\n      assignDeep(staticDefaultOptions, newDefaultOptions) && getDefaultOptions(),\n    _staticDefaultInitialization: assignDeep({}, staticDefaultInitialization),\n    _staticDefaultOptions: assignDeep({}, staticDefaultOptions),\n  };\n  const windowAddEventListener = window.addEventListener;\n  const debouncedWindowResize = debounce((zoom: boolean) => triggerEvent(zoom ? 'z' : 'r'), {\n    _timeout: 33,\n    _maxDelay: 99,\n  });\n\n  removeAttr(envElm, 'style');\n  removeElements(envElm);\n\n  // needed in case content has css viewport units\n  windowAddEventListener('resize', debouncedWindowResize.bind(0, false));\n\n  if (!nativeScrollbarsHiding && (!nativeScrollbarsOverlaid.x || !nativeScrollbarsOverlaid.y)) {\n    let resizeFn: undefined | ReturnType<ScrollbarsHidingPluginInstance['_envWindowZoom']>;\n    windowAddEventListener('resize', () => {\n      const scrollbarsHidingPlugin = getPlugins()[scrollbarsHidingPluginName] as\n        | ScrollbarsHidingPluginInstance\n        | undefined;\n\n      resizeFn = resizeFn || (scrollbarsHidingPlugin && scrollbarsHidingPlugin._envWindowZoom());\n      resizeFn &&\n        resizeFn(env, updateNativeScrollbarSizeCache, debouncedWindowResize.bind(0, true));\n    });\n  }\n\n  return env;\n};\n\nconst getEnvironment = (): InternalEnvironment => {\n  if (!environmentInstance) {\n    environmentInstance = createEnvironment();\n  }\n  return environmentInstance;\n};\n\nexport { getEnvironment };\n","import { isFunction, isHTMLElement, isNull, isUndefined } from '~/support';\nimport { getEnvironment } from '~/environment';\nimport type { DeepPartial } from '~/typings';\n\ntype StaticInitialization = HTMLElement | false | null;\ntype DynamicInitialization = HTMLElement | boolean | null;\ntype FallbackStaticInitializtationElement<Args extends any[]> = Extract<\n  StaticInitializationElement<Args>,\n  (...args: Args) => any\n> extends (...args: infer P) => any\n  ? (...args: P) => HTMLElement\n  : never;\ntype FallbackDynamicInitializtationElement<Args extends any[]> = Extract<\n  DynamicInitializationElement<Args>,\n  (...args: Args) => any\n> extends (...args: infer P) => any\n  ? (...args: P) => HTMLElement\n  : never;\n\n/**\n * Static elements are elements which MUST be present in the final DOM.\n * If an `HTMLElement` is passed the passed element will be taken as the repsective element.\n * With `false`, `null` or `undefined` an appropriate element is generated automatically.\n */\nexport type StaticInitializationElement<Args extends any[]> =\n  /** A function which returns the the StaticInitialization value. */\n  | ((...args: Args) => StaticInitialization)\n  /** The StaticInitialization value. */\n  | StaticInitialization;\n\n/**\n * Dynamic elements are elements which CAN be present in the final DOM.\n * If an `HTMLElement`is passed the passed element will be taken as the repsective element.\n * With `true` an appropriate element is generated automatically.\n * With `false`, `null` or `undefined` the element won't be in the DOM.\n */\nexport type DynamicInitializationElement<Args extends any[]> =\n  /** A function which returns the the DynamicInitialization value. */\n  | ((...args: Args) => DynamicInitialization)\n  /** The DynamicInitialization value. */\n  | DynamicInitialization;\n\n/**\n * Describes how a OverlayScrollbar instance should initialize.\n */\nexport type Initialization = {\n  /**\n   * Customizes which elements are generated and used.\n   * If a function is passed to any of the fields, it receives the `target` element as its argument.\n   * Any passed function should be a \"pure\" function. (same input produces same output)\n   */\n  elements: {\n    /**\n     * Assign a custom element as the host element.\n     * Only relevant if the target element is a Textarea.\n     */\n    host: StaticInitializationElement<[target: InitializationTargetElement]>;\n    /** Assign a custom element as the viewport element. */\n    viewport: StaticInitializationElement<[target: InitializationTargetElement]>;\n    /** Assign a custom element as the padding element or force the element not to be generated. */\n    padding: DynamicInitializationElement<[target: InitializationTargetElement]>;\n    /** Assign a custom element as the content element or force the element not to be generated. */\n    content: DynamicInitializationElement<[target: InitializationTargetElement]>;\n  };\n  /**\n   * Customizes elements related to the scrollbars.\n   * If a function is passed, it receives the `target`, `host` and `viewport` element as arguments.\n   */\n  scrollbars: {\n    slot: DynamicInitializationElement<\n      [target: InitializationTargetElement, host: HTMLElement, viewport: HTMLElement]\n    >;\n  };\n  /**\n   * Customizes the cancelation behavior.\n   */\n  cancel: {\n    /** Whether the initialization shall be canceled if the native scrollbars are overlaid. */\n    nativeScrollbarsOverlaid: boolean;\n    /**\n     * Whether the initialization shall be canceled if its applied to a body element.\n     * With `true` an initialization is always canceled, with `false` its never canceled.\n     * With `null` the initialization will only be canceled when the initialization would affect the browsers functionality. (window.scrollTo, mobile browser behavior etc.)\n     */\n    body: boolean | null;\n  };\n};\n\nexport type PartialInitialization = DeepPartial<Initialization>;\n\n/** The initialization target element. */\nexport type InitializationTargetElement = HTMLElement; // | HTMLTextAreaElement;\n\n/**\n * The initialization target object.\n * OverlayScrollbars({ target: myElement }) is equivalent to OverlayScrollbars(myElement).\n */\nexport type InitializationTargetObject = PartialInitialization & {\n  target: InitializationTargetElement;\n};\n\n/** The initialization target. */\nexport type InitializationTarget = InitializationTargetElement | InitializationTargetObject;\n\nexport const resolveInitialization = <T extends StaticInitialization | DynamicInitialization>(\n  args: any,\n  value: any\n): T => (isFunction(value) ? value.apply(0, args) : value);\n\nexport const staticInitializationElement = <Args extends any[]>(\n  args: Args,\n  fallbackStaticInitializationElement: FallbackStaticInitializtationElement<Args>,\n  defaultStaticInitializationElement: StaticInitializationElement<Args>,\n  staticInitializationElementValue?: StaticInitializationElement<Args>\n): HTMLElement => {\n  const staticInitialization = isUndefined(staticInitializationElementValue)\n    ? defaultStaticInitializationElement\n    : staticInitializationElementValue;\n  const resolvedInitialization = resolveInitialization<StaticInitialization>(\n    args,\n    staticInitialization\n  );\n  return resolvedInitialization || fallbackStaticInitializationElement.apply(0, args);\n};\n\nexport const dynamicInitializationElement = <Args extends any[]>(\n  args: Args,\n  fallbackDynamicInitializationElement: FallbackDynamicInitializtationElement<Args>,\n  defaultDynamicInitializationElement: DynamicInitializationElement<Args>,\n  dynamicInitializationElementValue?: DynamicInitializationElement<Args>\n): HTMLElement | false => {\n  const dynamicInitialization = isUndefined(dynamicInitializationElementValue)\n    ? defaultDynamicInitializationElement\n    : dynamicInitializationElementValue;\n  const resolvedInitialization = resolveInitialization<DynamicInitialization>(\n    args,\n    dynamicInitialization\n  );\n  return (\n    !!resolvedInitialization &&\n    (isHTMLElement(resolvedInitialization)\n      ? resolvedInitialization\n      : fallbackDynamicInitializationElement.apply(0, args))\n  );\n};\n\nexport const cancelInitialization = (\n  isBody: boolean,\n  defaultCancelInitialization: Initialization['cancel'],\n  cancelInitializationValue?: DeepPartial<Initialization['cancel']> | false | null | undefined\n): boolean => {\n  const { nativeScrollbarsOverlaid, body } = cancelInitializationValue || {};\n  const { _nativeScrollbarsOverlaid, _nativeScrollbarsHiding } = getEnvironment();\n  const { nativeScrollbarsOverlaid: defaultNativeScrollbarsOverlaid, body: defaultbody } =\n    defaultCancelInitialization;\n\n  const resolvedNativeScrollbarsOverlaid =\n    nativeScrollbarsOverlaid ?? defaultNativeScrollbarsOverlaid;\n  const resolvedDocumentScrollingElement = isUndefined(body) ? defaultbody : body;\n\n  const finalNativeScrollbarsOverlaid =\n    (_nativeScrollbarsOverlaid.x || _nativeScrollbarsOverlaid.y) &&\n    resolvedNativeScrollbarsOverlaid;\n  const finalDocumentScrollingElement =\n    isBody &&\n    (isNull(resolvedDocumentScrollingElement)\n      ? !_nativeScrollbarsHiding\n      : resolvedDocumentScrollingElement);\n\n  return !!finalNativeScrollbarsOverlaid || !!finalDocumentScrollingElement;\n};\n","import type { OverlayScrollbars } from '~/overlayscrollbars';\n\nconst targetInstanceMap: WeakMap<Element, OverlayScrollbars> = new WeakMap();\n\n/**\n * Adds the given OverlayScrollbars instance to the given element.\n * @param target The element which is the target of the OverlayScrollbars instance.\n * @param osInstance The OverlayScrollbars instance.\n */\nexport const addInstance = (target: Element, osInstance: OverlayScrollbars): void => {\n  targetInstanceMap.set(target, osInstance);\n};\n\n/**\n * Removes a OverlayScrollbars instance from the given element.\n * @param target The element from which its OverlayScrollbars instance shall be removed.\n */\nexport const removeInstance = (target: Element): void => {\n  targetInstanceMap.delete(target);\n};\n\n/**\n * Gets the OverlayScrollbars from the given element or undefined if it doesn't have one.\n * @param target The element of which its OverlayScrollbars instance shall be get.\n */\nexport const getInstance = (target: Element): OverlayScrollbars | undefined =>\n  targetInstanceMap.get(target);\n","import { assignDeep, hasOwnProperty } from '~/support';\nimport type { PartialOptions, ReadonlyOptions } from '~/options';\n\nexport type SetupElements<T extends Record<string, any>> = [elements: T, destroy: () => void];\n\nexport type SetupUpdate<Args extends any[], R> = (\n  changedOptions: PartialOptions,\n  force: boolean,\n  ...args: Args\n) => R;\n\nexport type SetupUpdateCheckOption = <T>(path: string) => [value: T, changed: boolean];\n\nexport type SetupUpdateSegment<Hints extends Record<string, any>> = (\n  updateHints: Hints,\n  checkOption: SetupUpdateCheckOption,\n  force: boolean\n) => Partial<Hints> | void;\n\nexport type SetupState<T extends Record<string, any>> = [\n  get: () => T,\n  set: (newState: Partial<T>) => void\n];\n\nexport type Setup<\n  DynamicState,\n  StaticState extends Record<string, any> = Record<string, any>,\n  Args extends any[] = [],\n  R = void\n> = [update: SetupUpdate<Args, R>, state: (() => DynamicState) & StaticState, destroy: () => void];\n\nconst getPropByPath = <T>(obj: any, path: string): T =>\n  obj\n    ? path.split('.').reduce((o, prop) => (o && hasOwnProperty(o, prop) ? o[prop] : undefined), obj)\n    : undefined;\n\nexport const createOptionCheck =\n  (\n    options: ReadonlyOptions,\n    changedOptions: PartialOptions,\n    force?: boolean\n  ): SetupUpdateCheckOption =>\n  (path: string) =>\n    [getPropByPath(options, path), force || getPropByPath(changedOptions, path) !== undefined];\n\nexport const createState = <S extends Record<string, any>>(initialState: S): SetupState<S> => {\n  let state: S = initialState;\n  return [\n    () => state,\n    (newState: Partial<S>) => {\n      state = assignDeep({}, state, newState);\n    },\n  ];\n};\n","import {\r\n  isHTMLElement,\r\n  appendChildren,\r\n  createDiv,\r\n  is,\r\n  contents,\r\n  insertAfter,\r\n  addClass,\r\n  parent,\r\n  indexOf,\r\n  removeElements,\r\n  removeClass,\r\n  hasClass,\r\n  push,\r\n  runEachAndClear,\r\n  insertBefore,\r\n  attr,\r\n  keys,\r\n  removeAttr,\r\n  attrClass,\r\n  hasAttrClass,\r\n  noop,\r\n  on,\r\n} from '~/support';\r\nimport {\r\n  dataAttributeHost,\r\n  dataAttributeInitialize,\r\n  dataAttributeHostOverflowX,\r\n  dataAttributeHostOverflowY,\r\n  classNamePadding,\r\n  classNameViewport,\r\n  classNameContent,\r\n  classNameViewportScrollbarHidden,\r\n} from '~/classnames';\r\nimport { getEnvironment } from '~/environment';\r\nimport { getPlugins, scrollbarsHidingPluginName } from '~/plugins';\r\nimport {\r\n  staticInitializationElement as generalStaticInitializationElement,\r\n  dynamicInitializationElement as generalDynamicInitializationElement,\r\n  resolveInitialization as generalResolveInitialization,\r\n} from '~/initialization';\r\nimport type { ScrollbarsHidingPluginInstance } from '~/plugins/scrollbarsHidingPlugin';\r\nimport type {\r\n  InitializationTarget,\r\n  InitializationTargetElement,\r\n  InitializationTargetObject,\r\n} from '~/initialization';\r\n\r\nexport type StructureSetupElements = [\r\n  elements: StructureSetupElementsObj,\r\n  appendElements: () => void,\r\n  destroy: () => void\r\n];\r\n\r\nexport interface StructureSetupElementsObj {\r\n  _target: InitializationTargetElement;\r\n  _host: HTMLElement;\r\n  _viewport: HTMLElement;\r\n  _padding: HTMLElement | false;\r\n  _content: HTMLElement | false;\r\n  _viewportArrange: HTMLStyleElement | false | null | undefined;\r\n  _scrollOffsetElement: HTMLElement;\r\n  _scrollEventElement: HTMLElement | Document;\r\n  // ctx ----\r\n  _isTextarea: boolean;\r\n  _isBody: boolean;\r\n  _windowElm: Window;\r\n  _documentElm: Document;\r\n  _targetIsElm: boolean;\r\n  _viewportIsTarget: boolean;\r\n  _viewportIsContent: boolean;\r\n  _viewportHasClass: (className: string, attributeClassName: string) => boolean;\r\n  _viewportAddRemoveClass: (className: string, attributeClassName: string, add?: boolean) => void;\r\n}\r\n\r\nconst tabIndexStr = 'tabindex';\r\nconst createNewDiv = createDiv.bind(0, '');\r\n\r\nconst unwrap = (elm: HTMLElement | false | null | undefined) => {\r\n  appendChildren(parent(elm), contents(elm));\r\n  removeElements(elm);\r\n};\r\n\r\nexport const createStructureSetupElements = (\r\n  target: InitializationTarget\r\n): StructureSetupElements => {\r\n  const env = getEnvironment();\r\n  const { _getDefaultInitialization, _nativeScrollbarsHiding } = env;\r\n  const scrollbarsHidingPlugin = getPlugins()[scrollbarsHidingPluginName] as\r\n    | ScrollbarsHidingPluginInstance\r\n    | undefined;\r\n  const createUniqueViewportArrangeElement =\r\n    scrollbarsHidingPlugin && scrollbarsHidingPlugin._createUniqueViewportArrangeElement;\r\n  const { elements: defaultInitElements } = _getDefaultInitialization();\r\n  const {\r\n    host: defaultHostInitialization,\r\n    padding: defaultPaddingInitialization,\r\n    viewport: defaultViewportInitialization,\r\n    content: defaultContentInitialization,\r\n  } = defaultInitElements;\r\n  const targetIsElm = isHTMLElement(target);\r\n  const targetStructureInitialization = (targetIsElm ? {} : target) as InitializationTargetObject;\r\n  const { elements: initElements } = targetStructureInitialization;\r\n  const {\r\n    host: hostInitialization,\r\n    padding: paddingInitialization,\r\n    viewport: viewportInitialization,\r\n    content: contentInitialization,\r\n  } = initElements || {};\r\n\r\n  const targetElement = targetIsElm ? target : targetStructureInitialization.target;\r\n  const isTextarea = is(targetElement, 'textarea');\r\n  const ownerDocument = targetElement.ownerDocument;\r\n  const docElement = ownerDocument.documentElement;\r\n  const isBody = targetElement === ownerDocument.body;\r\n  const wnd = ownerDocument.defaultView as Window;\r\n  const staticInitializationElement = generalStaticInitializationElement.bind(0, [targetElement]);\r\n  const dynamicInitializationElement = generalDynamicInitializationElement.bind(0, [targetElement]);\r\n  const resolveInitialization = generalResolveInitialization.bind(0, [targetElement]);\r\n  const generateViewportElement = staticInitializationElement.bind(\r\n    0,\r\n    createNewDiv,\r\n    defaultViewportInitialization\r\n  );\r\n  const generateContentElement = dynamicInitializationElement.bind(\r\n    0,\r\n    createNewDiv,\r\n    defaultContentInitialization\r\n  );\r\n  const possibleViewportElement = generateViewportElement(viewportInitialization);\r\n  const viewportIsTarget = possibleViewportElement === targetElement;\r\n  const viewportIsTargetBody = viewportIsTarget && isBody;\r\n  const possibleContentElement = !viewportIsTarget && generateContentElement(contentInitialization);\r\n  // edge case if passed viewportElement is contentElement:\r\n  // check the default contentElement\r\n  // if truthy (so the element would be present in the DOM) the passed element is the final content element and viewport is generated\r\n  // if falsy the passed element is the final viewport element and the content element is generated\r\n  const viewportIsContent =\r\n    !viewportIsTarget &&\r\n    isHTMLElement(possibleViewportElement) &&\r\n    possibleViewportElement === possibleContentElement;\r\n  const defaultContentElementPresent =\r\n    viewportIsContent && !!resolveInitialization(defaultContentInitialization);\r\n  const viewportIstContentViewport = defaultContentElementPresent\r\n    ? generateViewportElement()\r\n    : possibleViewportElement;\r\n  const viewportIsContentContent = defaultContentElementPresent\r\n    ? possibleContentElement\r\n    : generateContentElement();\r\n  const nonBodyViewportElement = viewportIsContent\r\n    ? viewportIstContentViewport\r\n    : possibleViewportElement;\r\n  const viewportElement = viewportIsTargetBody ? docElement : nonBodyViewportElement;\r\n  const nonBodyHostElement = isTextarea\r\n    ? staticInitializationElement(createNewDiv, defaultHostInitialization, hostInitialization)\r\n    : (targetElement as HTMLElement);\r\n  const hostElement = viewportIsTargetBody ? viewportElement : nonBodyHostElement;\r\n  const contentElement = viewportIsContent ? viewportIsContentContent : possibleContentElement;\r\n  const activeElm = ownerDocument.activeElement;\r\n  const setViewportFocus = !viewportIsTarget && wnd.top === wnd && activeElm === targetElement;\r\n  const evaluatedTargetObj: StructureSetupElementsObj = {\r\n    _target: targetElement,\r\n    _host: hostElement,\r\n    _viewport: viewportElement,\r\n    _padding:\r\n      !viewportIsTarget &&\r\n      dynamicInitializationElement(\r\n        createNewDiv,\r\n        defaultPaddingInitialization,\r\n        paddingInitialization\r\n      ),\r\n    _content: contentElement,\r\n    _viewportArrange:\r\n      !viewportIsTarget &&\r\n      !_nativeScrollbarsHiding &&\r\n      createUniqueViewportArrangeElement &&\r\n      createUniqueViewportArrangeElement(env),\r\n    _scrollOffsetElement: viewportIsTargetBody ? docElement : viewportElement,\r\n    _scrollEventElement: viewportIsTargetBody ? ownerDocument : viewportElement,\r\n    _windowElm: wnd,\r\n    _documentElm: ownerDocument,\r\n    _isTextarea: isTextarea,\r\n    _isBody: isBody,\r\n    _targetIsElm: targetIsElm,\r\n    _viewportIsTarget: viewportIsTarget,\r\n    _viewportIsContent: viewportIsContent,\r\n    _viewportHasClass: (className: string, attributeClassName: string) =>\r\n      viewportIsTarget\r\n        ? hasAttrClass(viewportElement, dataAttributeHost, attributeClassName)\r\n        : hasClass(viewportElement, className),\r\n    _viewportAddRemoveClass: (className: string, attributeClassName: string, add?: boolean) =>\r\n      viewportIsTarget\r\n        ? attrClass(viewportElement, dataAttributeHost, attributeClassName, add)\r\n        : (add ? addClass : removeClass)(viewportElement, className),\r\n  };\r\n  const generatedElements = keys(evaluatedTargetObj).reduce((arr, key: string) => {\r\n    const value = evaluatedTargetObj[key];\r\n    return push(arr, value && !parent(value) ? value : false);\r\n  }, [] as HTMLElement[]);\r\n  const elementIsGenerated = (elm: HTMLElement | false) =>\r\n    elm ? indexOf(generatedElements, elm) > -1 : null;\r\n  const { _target, _host, _padding, _viewport, _content, _viewportArrange } = evaluatedTargetObj;\r\n  const destroyFns: (() => any)[] = [\r\n    () => {\r\n      // always remove dataAttributeHost & dataAttributeInitialize from host and from <html> element if target is body\r\n      removeAttr(_host, dataAttributeHost);\r\n      removeAttr(_host, dataAttributeInitialize);\r\n      removeAttr(_target, dataAttributeInitialize);\r\n      if (isBody) {\r\n        removeAttr(docElement, dataAttributeHost);\r\n        removeAttr(docElement, dataAttributeInitialize);\r\n      }\r\n    },\r\n  ];\r\n  const isTextareaHostGenerated = isTextarea && elementIsGenerated(_host);\r\n  let targetContents = isTextarea\r\n    ? _target\r\n    : contents(\r\n        [_content, _viewport, _padding, _host, _target].find(\r\n          (elm) => elementIsGenerated(elm) === false\r\n        )\r\n      );\r\n  const contentSlot = viewportIsTargetBody ? _target : _content || _viewport;\r\n  const appendElements = () => {\r\n    attr(_host, dataAttributeHost, viewportIsTarget ? 'viewport' : 'host');\r\n\r\n    const removePaddingClass = addClass(_padding, classNamePadding);\r\n    const removeViewportClass = addClass(_viewport, !viewportIsTarget && classNameViewport);\r\n    const removeContentClass = addClass(_content, classNameContent);\r\n    const removeHtmlClass =\r\n      isBody && !viewportIsTarget\r\n        ? addClass(parent(targetElement), classNameViewportScrollbarHidden)\r\n        : noop;\r\n\r\n    // only insert host for textarea after target if it was generated\r\n    if (isTextareaHostGenerated) {\r\n      insertAfter(_target, _host);\r\n\r\n      push(destroyFns, () => {\r\n        insertAfter(_host, _target);\r\n        removeElements(_host);\r\n      });\r\n    }\r\n\r\n    appendChildren(contentSlot, targetContents);\r\n    appendChildren(_host, _padding);\r\n    appendChildren(_padding || _host, !viewportIsTarget && _viewport);\r\n    appendChildren(_viewport, _content);\r\n\r\n    push(destroyFns, () => {\r\n      removeHtmlClass();\r\n      removeAttr(_viewport, dataAttributeHostOverflowX);\r\n      removeAttr(_viewport, dataAttributeHostOverflowY);\r\n\r\n      if (elementIsGenerated(_content)) {\r\n        unwrap(_content);\r\n      }\r\n      if (elementIsGenerated(_viewport)) {\r\n        unwrap(_viewport);\r\n      }\r\n      if (elementIsGenerated(_padding)) {\r\n        unwrap(_padding);\r\n      }\r\n      removePaddingClass();\r\n      removeViewportClass();\r\n      removeContentClass();\r\n    });\r\n\r\n    if (_nativeScrollbarsHiding && !viewportIsTarget) {\r\n      push(destroyFns, removeClass.bind(0, _viewport, classNameViewportScrollbarHidden));\r\n    }\r\n    if (_viewportArrange) {\r\n      insertBefore(_viewport, _viewportArrange);\r\n      push(destroyFns, removeElements.bind(0, _viewportArrange));\r\n    }\r\n    if (setViewportFocus) {\r\n      const ogTabindex = attr(_viewport, tabIndexStr);\r\n\r\n      attr(_viewport, tabIndexStr, '-1');\r\n      _viewport.focus();\r\n\r\n      const revertViewportTabIndex = () =>\r\n        ogTabindex ? attr(_viewport, tabIndexStr, ogTabindex) : removeAttr(_viewport, tabIndexStr);\r\n      const off = on(ownerDocument, 'pointerdown keydown', () => {\r\n        revertViewportTabIndex();\r\n        off();\r\n      });\r\n\r\n      push(destroyFns, [revertViewportTabIndex, off]);\r\n    } else if (activeElm && (activeElm as HTMLElement).focus) {\r\n      (activeElm as HTMLElement).focus();\r\n    }\r\n\r\n    // @ts-ignore\r\n    targetContents = 0;\r\n  };\r\n\r\n  return [evaluatedTargetObj, appendElements, runEachAndClear.bind(0, destroyFns)];\r\n};\r\n","import { style } from '~/support';\nimport { getEnvironment } from '~/environment';\nimport type { CreateStructureUpdateSegment } from '~/setups/structureSetup/structureSetup.update';\n\n/**\n * Lifecycle with the responsibility to adjust the trinsic behavior of the content element.\n * @param structureUpdateHub\n * @returns\n */\nexport const createTrinsicUpdateSegment: CreateStructureUpdateSegment = (\n  structureSetupElements,\n  state\n) => {\n  const { _content } = structureSetupElements;\n  const [getState] = state;\n\n  return (updateHints) => {\n    const { _flexboxGlue } = getEnvironment();\n    const { _heightIntrinsic } = getState();\n    const { _heightIntrinsicChanged } = updateHints;\n    const heightIntrinsicChanged = (_content || !_flexboxGlue) && _heightIntrinsicChanged;\n\n    if (heightIntrinsicChanged) {\n      style(_content, {\n        height: _heightIntrinsic ? '' : '100%',\n      });\n    }\n\n    return {\n      _sizeChanged: heightIntrinsicChanged,\n      _contentMutation: heightIntrinsicChanged,\n    };\n  };\n};\n","import { createCache, topRightBottomLeft, equalTRBL, style, assignDeep } from '~/support';\nimport { getEnvironment } from '~/environment';\nimport type { StyleObject } from '~/typings';\nimport type { CreateStructureUpdateSegment } from '~/setups/structureSetup/structureSetup.update';\n\n/**\n * Lifecycle with the responsibility to adjust the padding styling of the padding and viewport element.\n * @param structureUpdateHub\n * @returns\n */\nexport const createPaddingUpdateSegment: CreateStructureUpdateSegment = (\n  structureSetupElements,\n  state\n) => {\n  const [getState, setState] = state;\n  const { _host, _padding, _viewport, _viewportIsTarget: _isSingleElm } = structureSetupElements;\n  const [updatePaddingCache, currentPaddingCache] = createCache(\n    {\n      _equal: equalTRBL,\n      _initialValue: topRightBottomLeft(),\n    },\n    topRightBottomLeft.bind(0, _host, 'padding', '')\n  );\n\n  return (updateHints, checkOption, force) => {\n    let [padding, paddingChanged] = currentPaddingCache(force);\n    const { _nativeScrollbarsHiding: _nativeScrollbarStyling, _flexboxGlue } = getEnvironment();\n    const { _directionIsRTL } = getState();\n    const { _sizeChanged, _contentMutation, _directionChanged } = updateHints;\n    const [paddingAbsolute, paddingAbsoluteChanged] = checkOption('paddingAbsolute');\n    const contentMutation = !_flexboxGlue && _contentMutation;\n\n    if (_sizeChanged || paddingChanged || contentMutation) {\n      [padding, paddingChanged] = updatePaddingCache(force);\n    }\n\n    const paddingStyleChanged =\n      !_isSingleElm && (paddingAbsoluteChanged || _directionChanged || paddingChanged);\n\n    if (paddingStyleChanged) {\n      // if there is no padding element and no scrollbar styling, paddingAbsolute isn't supported\n      const paddingRelative = !paddingAbsolute || (!_padding && !_nativeScrollbarStyling);\n      const paddingHorizontal = padding.r + padding.l;\n      const paddingVertical = padding.t + padding.b;\n\n      const paddingStyle: StyleObject = {\n        marginRight: paddingRelative && !_directionIsRTL ? -paddingHorizontal : 0,\n        marginBottom: paddingRelative ? -paddingVertical : 0,\n        marginLeft: paddingRelative && _directionIsRTL ? -paddingHorizontal : 0,\n        top: paddingRelative ? -padding.t : 0,\n        right: paddingRelative ? (_directionIsRTL ? -padding.r : 'auto') : 0,\n        left: paddingRelative ? (_directionIsRTL ? 'auto' : -padding.l) : 0,\n        width: paddingRelative ? `calc(100% + ${paddingHorizontal}px)` : '',\n      };\n      const viewportStyle: StyleObject = {\n        paddingTop: paddingRelative ? padding.t : 0,\n        paddingRight: paddingRelative ? padding.r : 0,\n        paddingBottom: paddingRelative ? padding.b : 0,\n        paddingLeft: paddingRelative ? padding.l : 0,\n      };\n\n      // if there is no padding element apply the style to the viewport element instead\n      style(_padding || _viewport, paddingStyle);\n      style(_viewport, viewportStyle);\n\n      setState({\n        _padding: padding,\n        _paddingAbsolute: !paddingRelative,\n        _viewportPaddingStyle: _padding\n          ? viewportStyle\n          : assignDeep({}, paddingStyle, viewportStyle),\n      });\n    }\n\n    return {\n      _paddingStyleChanged: paddingStyleChanged,\n    };\n  };\n};\n","import {\n  createCache,\n  attr,\n  style,\n  scrollSize,\n  fractionalSize,\n  equalWH,\n  addClass,\n  removeClass,\n  clientSize,\n  equalXY,\n  attrClass,\n  noop,\n} from '~/support';\nimport { getEnvironment } from '~/environment';\nimport {\n  classNameViewportScrollbarHidden,\n  classNameOverflowVisible,\n  dataAttributeHost,\n  dataAttributeHostOverflowX,\n  dataAttributeHostOverflowY,\n  dataValueHostScrollbarHidden,\n  dataValueHostOverflowVisible,\n} from '~/classnames';\nimport { getPlugins, scrollbarsHidingPluginName } from '~/plugins';\nimport type { WH, XY } from '~/support';\nimport type {\n  ScrollbarsHidingPluginInstance,\n  ArrangeViewport,\n  UndoArrangeViewport,\n} from '~/plugins/scrollbarsHidingPlugin';\nimport type { StyleObject, OverflowStyle } from '~/typings';\nimport type { OverflowBehavior } from '~/options';\nimport type { CreateStructureUpdateSegment } from '~/setups/structureSetup/structureSetup.update';\n\nexport interface ViewportOverflowState {\n  _scrollbarsHideOffset: XY<number>;\n  _scrollbarsHideOffsetArrange: XY<boolean>;\n  _overflowScroll: XY<boolean>;\n  _overflowStyle: XY<OverflowStyle>;\n}\n\nexport type GetViewportOverflowState = (\n  showNativeOverlaidScrollbars: boolean,\n  viewportStyleObj?: StyleObject\n) => ViewportOverflowState;\n\nexport type HideNativeScrollbars = (\n  viewportOverflowState: ViewportOverflowState,\n  directionIsRTL: boolean,\n  viewportArrange: boolean,\n  viewportStyleObj: StyleObject\n) => void;\n\nconst { max } = Math;\nconst max0 = max.bind(0, 0);\nconst strVisible = 'visible';\nconst strHidden = 'hidden';\nconst overlaidScrollbarsHideOffset = 42;\nconst whCacheOptions = {\n  _equal: equalWH,\n  _initialValue: { w: 0, h: 0 },\n};\nconst xyCacheOptions = {\n  _equal: equalXY,\n  _initialValue: { x: strHidden, y: strHidden } as XY<OverflowStyle>,\n};\n\nconst getOverflowAmount = (viewportScrollSize: WH<number>, viewportClientSize: WH<number>) => {\n  const tollerance = window.devicePixelRatio % 1 !== 0 ? 1 : 0;\n  const amount = {\n    w: max0(viewportScrollSize.w - viewportClientSize.w),\n    h: max0(viewportScrollSize.h - viewportClientSize.h),\n  };\n\n  return {\n    w: amount.w > tollerance ? amount.w : 0,\n    h: amount.h > tollerance ? amount.h : 0,\n  };\n};\n\nconst conditionalClass = (\n  elm: Element | false | null | undefined,\n  classNames: string,\n  add: boolean\n) => (add ? addClass(elm, classNames) : removeClass(elm, classNames));\n\nconst overflowIsVisible = (overflowBehavior: string) => overflowBehavior.indexOf(strVisible) === 0;\n\n/**\n * Lifecycle with the responsibility to set the correct overflow and scrollbar hiding styles of the viewport element.\n * @param structureUpdateHub\n * @returns\n */\nexport const createOverflowUpdateSegment: CreateStructureUpdateSegment = (\n  structureSetupElements,\n  state\n) => {\n  const [getState, setState] = state;\n  const {\n    _host,\n    _padding,\n    _viewport,\n    _viewportArrange,\n    _viewportIsTarget,\n    _viewportAddRemoveClass,\n    _isBody,\n    _windowElm,\n  } = structureSetupElements;\n  const {\n    _nativeScrollbarsSize,\n    _flexboxGlue,\n    _nativeScrollbarsHiding,\n    _nativeScrollbarsOverlaid,\n  } = getEnvironment();\n  const scrollbarsHidingPlugin = getPlugins()[scrollbarsHidingPluginName] as\n    | ScrollbarsHidingPluginInstance\n    | undefined;\n  const doViewportArrange =\n    !_viewportIsTarget &&\n    !_nativeScrollbarsHiding &&\n    (_nativeScrollbarsOverlaid.x || _nativeScrollbarsOverlaid.y);\n  const viewportIsTargetBody = _isBody && _viewportIsTarget;\n\n  const [updateSizeFraction, getCurrentSizeFraction] = createCache<WH<number>>(\n    whCacheOptions,\n    fractionalSize.bind(0, _viewport)\n  );\n\n  const [updateViewportScrollSizeCache, getCurrentViewportScrollSizeCache] = createCache<\n    WH<number>\n  >(whCacheOptions, scrollSize.bind(0, _viewport));\n\n  const [updateOverflowAmountCache, getCurrentOverflowAmountCache] =\n    createCache<WH<number>>(whCacheOptions);\n\n  const [updateOverflowEdge, getCurrentOverflowEdgeCache] = createCache<WH<number>>(whCacheOptions);\n\n  const [updateOverflowStyleCache] = createCache<XY<OverflowStyle>>(xyCacheOptions);\n\n  /**\n   * Applies a fixed height to the viewport so it can't overflow or underflow the host element.\n   * @param viewportOverflowState The current overflow state.\n   * @param heightIntrinsic Whether the host height is intrinsic or not.\n   */\n  const fixFlexboxGlue = (\n    viewportOverflowState: ViewportOverflowState,\n    heightIntrinsic: boolean\n  ) => {\n    style(_viewport, {\n      height: '',\n    });\n\n    if (heightIntrinsic) {\n      const { _paddingAbsolute, _padding: padding } = getState();\n      const { _overflowScroll, _scrollbarsHideOffset } = viewportOverflowState;\n      const fSize = fractionalSize(_host);\n      const hostClientSize = clientSize(_host);\n\n      // padding subtraction is only needed if padding is absolute or if viewport is content-box\n      const isContentBox = style(_viewport, 'boxSizing') === 'content-box';\n      const paddingVertical = _paddingAbsolute || isContentBox ? padding.b + padding.t : 0;\n      const subtractXScrollbar = !(_nativeScrollbarsOverlaid.x && isContentBox);\n\n      style(_viewport, {\n        height:\n          hostClientSize.h +\n          fSize.h +\n          (_overflowScroll.x && subtractXScrollbar ? _scrollbarsHideOffset.x : 0) -\n          paddingVertical,\n      });\n    }\n  };\n\n  /**\n   * Gets the current overflow state of the viewport.\n   * @param showNativeOverlaidScrollbars Whether native overlaid scrollbars are shown instead of hidden.\n   * @param viewportStyleObj The viewport style object where the overflow scroll property can be read of, or undefined if shall be determined.\n   * @returns A object which contains informations about the current overflow state.\n   */\n  const getViewportOverflowState: GetViewportOverflowState = (\n    showNativeOverlaidScrollbars,\n    viewportStyleObj?\n  ) => {\n    const arrangeHideOffset =\n      !_nativeScrollbarsHiding && !showNativeOverlaidScrollbars ? overlaidScrollbarsHideOffset : 0;\n    const getStatePerAxis = (\n      styleKey: string,\n      isOverlaid: boolean,\n      nativeScrollbarSize: number\n    ) => {\n      const overflowStyle = style(_viewport, styleKey);\n      // can't do something like \"viewportStyleObj && viewportStyleObj[styleKey] || overflowStyle\" here!\n      const objectPrefferedOverflowStyle = viewportStyleObj\n        ? viewportStyleObj[styleKey]\n        : overflowStyle;\n      const overflowScroll = objectPrefferedOverflowStyle === 'scroll';\n      const nonScrollbarStylingHideOffset = isOverlaid ? arrangeHideOffset : nativeScrollbarSize;\n      const scrollbarsHideOffset =\n        overflowScroll && !_nativeScrollbarsHiding ? nonScrollbarStylingHideOffset : 0;\n      const scrollbarsHideOffsetArrange = isOverlaid && !!arrangeHideOffset;\n\n      return [overflowStyle, overflowScroll, scrollbarsHideOffset, scrollbarsHideOffsetArrange] as [\n        overflowStyle: OverflowStyle,\n        overflowScroll: boolean,\n        scrollbarsHideOffset: number,\n        scrollbarsHideOffsetArrange: boolean\n      ];\n    };\n\n    const [xOverflowStyle, xOverflowScroll, xScrollbarsHideOffset, xScrollbarsHideOffsetArrange] =\n      getStatePerAxis('overflowX', _nativeScrollbarsOverlaid.x, _nativeScrollbarsSize.x);\n    const [yOverflowStyle, yOverflowScroll, yScrollbarsHideOffset, yScrollbarsHideOffsetArrange] =\n      getStatePerAxis('overflowY', _nativeScrollbarsOverlaid.y, _nativeScrollbarsSize.y);\n\n    return {\n      _overflowStyle: {\n        x: xOverflowStyle,\n        y: yOverflowStyle,\n      },\n      _overflowScroll: {\n        x: xOverflowScroll,\n        y: yOverflowScroll,\n      },\n      _scrollbarsHideOffset: {\n        x: xScrollbarsHideOffset,\n        y: yScrollbarsHideOffset,\n      },\n      _scrollbarsHideOffsetArrange: {\n        x: xScrollbarsHideOffsetArrange,\n        y: yScrollbarsHideOffsetArrange,\n      },\n    };\n  };\n\n  /**\n   * Sets the overflow property of the viewport and calculates the a overflow state according to the new parameters.\n   * @param showNativeOverlaidScrollbars Whether to show natively overlaid scrollbars.\n   * @param overflowAmount The overflow amount.\n   * @param overflow The overflow behavior according to the options.\n   * @param viewportStyleObj The viewport style object to which the overflow style shall be applied.\n   * @returns A object which represents the newly set overflow state.\n   */\n  const setViewportOverflowState = (\n    showNativeOverlaidScrollbars: boolean,\n    hasOverflow: XY<boolean>,\n    overflowOption: XY<OverflowBehavior>,\n    viewportStyleObj: StyleObject\n  ): ViewportOverflowState => {\n    const setAxisOverflowStyle = (behavior: OverflowBehavior, hasOverflowAxis: boolean) => {\n      const overflowVisible = overflowIsVisible(behavior);\n      const overflowVisibleBehavior =\n        (hasOverflowAxis && overflowVisible && behavior.replace(`${strVisible}-`, '')) || '';\n      return [\n        hasOverflowAxis && !overflowVisible ? behavior : '',\n        overflowIsVisible(overflowVisibleBehavior) ? 'hidden' : overflowVisibleBehavior,\n      ];\n    };\n\n    const [overflowX, visibleBehaviorX] = setAxisOverflowStyle(overflowOption.x, hasOverflow.x);\n    const [overflowY, visibleBehaviorY] = setAxisOverflowStyle(overflowOption.y, hasOverflow.y);\n\n    viewportStyleObj.overflowX = visibleBehaviorX && overflowY ? visibleBehaviorX : overflowX;\n    viewportStyleObj.overflowY = visibleBehaviorY && overflowX ? visibleBehaviorY : overflowY;\n\n    return getViewportOverflowState(showNativeOverlaidScrollbars, viewportStyleObj);\n  };\n\n  /**\n   * Hides the native scrollbars according to the passed parameters.\n   * @param viewportOverflowState The viewport overflow state.\n   * @param directionIsRTL Whether the direction is RTL or not.\n   * @param viewportArrange Whether special styles related to the viewport arrange strategy shall be applied.\n   * @param viewportStyleObj The viewport style object to which the needed styles shall be applied.\n   */\n  const hideNativeScrollbars: HideNativeScrollbars = (\n    viewportOverflowState,\n    directionIsRTL,\n    viewportArrange,\n    viewportStyleObj\n  ) => {\n    const { _scrollbarsHideOffset, _scrollbarsHideOffsetArrange } = viewportOverflowState;\n    const { x: arrangeX, y: arrangeY } = _scrollbarsHideOffsetArrange;\n    const { x: hideOffsetX, y: hideOffsetY } = _scrollbarsHideOffset;\n    const { _viewportPaddingStyle: viewportPaddingStyle } = getState();\n    const horizontalMarginKey: keyof StyleObject = directionIsRTL ? 'marginLeft' : 'marginRight';\n    const viewportHorizontalPaddingKey: keyof StyleObject = directionIsRTL\n      ? 'paddingLeft'\n      : 'paddingRight';\n    const horizontalMarginValue = viewportPaddingStyle[horizontalMarginKey] as number;\n    const verticalMarginValue = viewportPaddingStyle.marginBottom as number;\n    const horizontalPaddingValue = viewportPaddingStyle[viewportHorizontalPaddingKey] as number;\n    const verticalPaddingValue = viewportPaddingStyle.paddingBottom as number;\n\n    // horizontal\n    viewportStyleObj.width = `calc(100% + ${hideOffsetY + horizontalMarginValue * -1}px)`;\n    viewportStyleObj[horizontalMarginKey] = -hideOffsetY + horizontalMarginValue;\n\n    // vertical\n    viewportStyleObj.marginBottom = -hideOffsetX + verticalMarginValue;\n\n    // viewport arrange additional styles\n    if (viewportArrange) {\n      viewportStyleObj[viewportHorizontalPaddingKey] =\n        horizontalPaddingValue + (arrangeY ? hideOffsetY : 0);\n      viewportStyleObj.paddingBottom = verticalPaddingValue + (arrangeX ? hideOffsetX : 0);\n    }\n  };\n\n  const [arrangeViewport, undoViewportArrange] = scrollbarsHidingPlugin\n    ? scrollbarsHidingPlugin._overflowUpdateSegment(\n        doViewportArrange,\n        _flexboxGlue,\n        _viewport,\n        _viewportArrange,\n        getState,\n        getViewportOverflowState,\n        hideNativeScrollbars\n      )\n    : [(() => doViewportArrange) as ArrangeViewport, (() => [noop]) as UndoArrangeViewport];\n\n  return (updateHints, checkOption, force) => {\n    const {\n      _sizeChanged,\n      _hostMutation,\n      _contentMutation,\n      _paddingStyleChanged,\n      _heightIntrinsicChanged,\n      _directionChanged,\n    } = updateHints;\n    const { _heightIntrinsic, _directionIsRTL } = getState();\n    const [showNativeOverlaidScrollbarsOption, showNativeOverlaidScrollbarsChanged] =\n      checkOption<boolean>('showNativeOverlaidScrollbars');\n    const [overflow, overflowChanged] = checkOption<XY<OverflowBehavior>>('overflow');\n\n    const showNativeOverlaidScrollbars =\n      showNativeOverlaidScrollbarsOption &&\n      _nativeScrollbarsOverlaid.x &&\n      _nativeScrollbarsOverlaid.y;\n    const adjustFlexboxGlue =\n      !_viewportIsTarget &&\n      !_flexboxGlue &&\n      (_sizeChanged ||\n        _contentMutation ||\n        _hostMutation ||\n        showNativeOverlaidScrollbarsChanged ||\n        _heightIntrinsicChanged);\n    const overflowXVisible = overflowIsVisible(overflow.x);\n    const overflowYVisible = overflowIsVisible(overflow.y);\n    const overflowVisible = overflowXVisible || overflowYVisible;\n\n    let sizeFractionCache = getCurrentSizeFraction(force);\n    let viewportScrollSizeCache = getCurrentViewportScrollSizeCache(force);\n    let overflowAmuntCache = getCurrentOverflowAmountCache(force);\n    let overflowEdgeCache = getCurrentOverflowEdgeCache(force);\n\n    let preMeasureViewportOverflowState: ViewportOverflowState | undefined;\n\n    if (showNativeOverlaidScrollbarsChanged && _nativeScrollbarsHiding) {\n      _viewportAddRemoveClass(\n        classNameViewportScrollbarHidden,\n        dataValueHostScrollbarHidden,\n        !showNativeOverlaidScrollbars\n      );\n    }\n\n    if (adjustFlexboxGlue) {\n      preMeasureViewportOverflowState = getViewportOverflowState(showNativeOverlaidScrollbars);\n      fixFlexboxGlue(preMeasureViewportOverflowState, _heightIntrinsic);\n    }\n\n    if (\n      _sizeChanged ||\n      _paddingStyleChanged ||\n      _contentMutation ||\n      _directionChanged ||\n      showNativeOverlaidScrollbarsChanged\n    ) {\n      if (overflowVisible) {\n        _viewportAddRemoveClass(classNameOverflowVisible, dataValueHostOverflowVisible, false);\n      }\n\n      const [redoViewportArrange, undoViewportArrangeOverflowState] = undoViewportArrange(\n        showNativeOverlaidScrollbars,\n        _directionIsRTL,\n        preMeasureViewportOverflowState\n      );\n      const [sizeFraction, sizeFractionChanged] = (sizeFractionCache = updateSizeFraction(force));\n      const [viewportScrollSize, viewportScrollSizeChanged] = (viewportScrollSizeCache =\n        updateViewportScrollSizeCache(force));\n      const viewportclientSize = clientSize(_viewport);\n      let arrangedViewportScrollSize = viewportScrollSize;\n      let arrangedViewportClientSize = viewportclientSize;\n\n      redoViewportArrange();\n\n      // if re measure is required (only required if content arrange strategy is used)\n      if (\n        (viewportScrollSizeChanged || sizeFractionChanged || showNativeOverlaidScrollbarsChanged) &&\n        undoViewportArrangeOverflowState &&\n        !showNativeOverlaidScrollbars &&\n        arrangeViewport(\n          undoViewportArrangeOverflowState,\n          viewportScrollSize,\n          sizeFraction,\n          _directionIsRTL\n        )\n      ) {\n        arrangedViewportClientSize = clientSize(_viewport);\n        arrangedViewportScrollSize = scrollSize(_viewport);\n      }\n\n      const overflowAmountScrollSize = {\n        w: max0(max(viewportScrollSize.w, arrangedViewportScrollSize.w) + sizeFraction.w),\n        h: max0(max(viewportScrollSize.h, arrangedViewportScrollSize.h) + sizeFraction.h),\n      };\n      const overflowAmountClientSize = {\n        w: max0(\n          (viewportIsTargetBody\n            ? _windowElm.innerWidth\n            : arrangedViewportClientSize.w + max0(viewportclientSize.w - viewportScrollSize.w)) +\n            sizeFraction.w\n        ),\n        h: max0(\n          (viewportIsTargetBody\n            ? _windowElm.innerHeight + sizeFraction.h\n            : arrangedViewportClientSize.h + max0(viewportclientSize.h - viewportScrollSize.h)) +\n            sizeFraction.h\n        ),\n      };\n\n      overflowEdgeCache = updateOverflowEdge(overflowAmountClientSize);\n      overflowAmuntCache = updateOverflowAmountCache(\n        getOverflowAmount(overflowAmountScrollSize, overflowAmountClientSize),\n        force\n      );\n    }\n\n    const [overflowEdge, overflowEdgeChanged] = overflowEdgeCache;\n    const [overflowAmount, overflowAmountChanged] = overflowAmuntCache;\n    const [viewportScrollSize, viewportScrollSizeChanged] = viewportScrollSizeCache;\n    const [sizeFraction, sizeFractionChanged] = sizeFractionCache;\n    const hasOverflow = {\n      x: overflowAmount.w > 0,\n      y: overflowAmount.h > 0,\n    };\n    const removeClipping =\n      (overflowXVisible && overflowYVisible && (hasOverflow.x || hasOverflow.y)) ||\n      (overflowXVisible && hasOverflow.x && !hasOverflow.y) ||\n      (overflowYVisible && hasOverflow.y && !hasOverflow.x);\n\n    if (\n      _paddingStyleChanged ||\n      _directionChanged ||\n      sizeFractionChanged ||\n      viewportScrollSizeChanged ||\n      overflowEdgeChanged ||\n      overflowAmountChanged ||\n      overflowChanged ||\n      showNativeOverlaidScrollbarsChanged ||\n      adjustFlexboxGlue\n    ) {\n      const viewportStyle: StyleObject = {\n        marginRight: 0,\n        marginBottom: 0,\n        marginLeft: 0,\n        width: '',\n        overflowY: '',\n        overflowX: '',\n      };\n      const viewportOverflowState = setViewportOverflowState(\n        showNativeOverlaidScrollbars,\n        hasOverflow,\n        overflow,\n        viewportStyle\n      );\n      const viewportArranged = arrangeViewport(\n        viewportOverflowState,\n        viewportScrollSize,\n        sizeFraction,\n        _directionIsRTL\n      );\n\n      if (!_viewportIsTarget) {\n        hideNativeScrollbars(\n          viewportOverflowState,\n          _directionIsRTL,\n          viewportArranged,\n          viewportStyle\n        );\n      }\n\n      if (adjustFlexboxGlue) {\n        fixFlexboxGlue(viewportOverflowState, _heightIntrinsic);\n      }\n\n      if (_viewportIsTarget) {\n        attr(_host, dataAttributeHostOverflowX, viewportStyle.overflowX as string);\n        attr(_host, dataAttributeHostOverflowY, viewportStyle.overflowY as string);\n      } else {\n        style(_viewport, viewportStyle);\n      }\n    }\n\n    attrClass(_host, dataAttributeHost, dataValueHostOverflowVisible, removeClipping);\n    conditionalClass(_padding, classNameOverflowVisible, removeClipping);\n    !_viewportIsTarget && conditionalClass(_viewport, classNameOverflowVisible, overflowVisible);\n\n    const [overflowStyle, overflowStyleChanged] = updateOverflowStyleCache(\n      getViewportOverflowState(showNativeOverlaidScrollbars)._overflowStyle\n    );\n\n    setState({\n      _overflowStyle: overflowStyle,\n      _overflowEdge: {\n        x: overflowEdge.w,\n        y: overflowEdge.h,\n      },\n      _overflowAmount: {\n        x: overflowAmount.w,\n        y: overflowAmount.h,\n      },\n      _hasOverflow: hasOverflow,\n    });\n\n    return {\n      _overflowStyleChanged: overflowStyleChanged,\n      _overflowEdgeChanged: overflowEdgeChanged,\n      _overflowAmountChanged: overflowAmountChanged,\n    };\n  };\n};\n","import { each, scrollLeft, scrollTop, assignDeep, keys } from '~/support';\nimport { getEnvironment } from '~/environment';\nimport { dataValueHostUpdating } from '~/classnames';\nimport {\n  createTrinsicUpdateSegment,\n  createPaddingUpdateSegment,\n  createOverflowUpdateSegment,\n} from '~/setups/structureSetup/updateSegments';\nimport type { SetupState, SetupUpdateSegment, SetupUpdateCheckOption } from '~/setups';\nimport type { StructureSetupState } from '~/setups/structureSetup';\nimport type { StructureSetupElementsObj } from '~/setups/structureSetup/structureSetup.elements';\n\nexport type CreateStructureUpdateSegment = (\n  structureSetupElements: StructureSetupElementsObj,\n  state: SetupState<StructureSetupState>\n) => StructureSetupUpdateSegment;\n\nexport type StructureSetupUpdateSegment = SetupUpdateSegment<StructureSetupUpdateHints>;\n\nexport type StructureSetupUpdate = (\n  checkOption: SetupUpdateCheckOption,\n  updateHints: Partial<StructureSetupUpdateHints>,\n  force?: boolean\n) => StructureSetupUpdateHints;\n\nexport interface StructureSetupUpdateHints {\n  _sizeChanged: boolean;\n  _directionChanged: boolean;\n  _heightIntrinsicChanged: boolean;\n  _overflowEdgeChanged: boolean;\n  _overflowAmountChanged: boolean;\n  _overflowStyleChanged: boolean;\n  _paddingStyleChanged: boolean;\n  _hostMutation: boolean;\n  _contentMutation: boolean;\n}\n\nconst prepareUpdateHints = <T extends StructureSetupUpdateHints>(\n  leading: Required<T>,\n  adaptive?: Partial<T>,\n  force?: boolean\n): Required<T> => {\n  const result = {};\n  const finalAdaptive = adaptive || {};\n  const objKeys = keys(leading).concat(keys(finalAdaptive));\n\n  each(objKeys, (key) => {\n    const leadingValue = leading[key];\n    const adaptiveValue = finalAdaptive[key];\n    result[key] = !!(force || leadingValue || adaptiveValue);\n  });\n\n  return result as Required<T>;\n};\n\nexport const createStructureSetupUpdate = (\n  structureSetupElements: StructureSetupElementsObj,\n  state: SetupState<StructureSetupState>\n): StructureSetupUpdate => {\n  const { _target, _viewport, _viewportAddRemoveClass, _viewportIsTarget } = structureSetupElements;\n  const { _nativeScrollbarsHiding, _nativeScrollbarsOverlaid, _flexboxGlue } = getEnvironment();\n  const doViewportArrange =\n    !_nativeScrollbarsHiding && (_nativeScrollbarsOverlaid.x || _nativeScrollbarsOverlaid.y);\n\n  const updateSegments: StructureSetupUpdateSegment[] = [\n    createTrinsicUpdateSegment(structureSetupElements, state),\n    createPaddingUpdateSegment(structureSetupElements, state),\n    createOverflowUpdateSegment(structureSetupElements, state),\n  ];\n\n  return (\n    checkOption: SetupUpdateCheckOption,\n    updateHints: Partial<StructureSetupUpdateHints>,\n    force?: boolean\n  ) => {\n    const initialUpdateHints = prepareUpdateHints(\n      assignDeep(\n        {\n          _sizeChanged: false,\n          _paddingStyleChanged: false,\n          _directionChanged: false,\n          _heightIntrinsicChanged: false,\n          _overflowEdgeChanged: false,\n          _overflowAmountChanged: false,\n          _overflowStyleChanged: false,\n          _hostMutation: false,\n          _contentMutation: false,\n        },\n        updateHints\n      ),\n      {},\n      force\n    );\n    const adjustScrollOffset = doViewportArrange || !_flexboxGlue;\n    const scrollOffsetX = adjustScrollOffset && scrollLeft(_viewport);\n    const scrollOffsetY = adjustScrollOffset && scrollTop(_viewport);\n    _viewportAddRemoveClass('', dataValueHostUpdating, true);\n\n    let adaptivedUpdateHints: Required<StructureSetupUpdateHints> = initialUpdateHints;\n    each(updateSegments, (updateSegment) => {\n      adaptivedUpdateHints = prepareUpdateHints<StructureSetupUpdateHints>(\n        adaptivedUpdateHints,\n        updateSegment(adaptivedUpdateHints, checkOption, !!force) || {},\n        force\n      );\n    });\n\n    scrollLeft(_viewport, scrollOffsetX);\n    scrollTop(_viewport, scrollOffsetY);\n    _viewportAddRemoveClass('', dataValueHostUpdating);\n\n    if (!_viewportIsTarget) {\n      scrollLeft(_target, 0);\n      scrollTop(_target, 0);\n    }\n\n    return adaptivedUpdateHints;\n  };\n};\n","import {\n  each,\n  noop,\n  debounce,\n  indexOf,\n  isString,\n  MutationObserverConstructor,\n  isEmptyArray,\n  on,\n  attr,\n  is,\n  find,\n  push,\n  from,\n  runEachAndClear,\n} from '~/support';\n\ntype DOMContentObserverCallback = (contentChangedThroughEvent: boolean) => any;\n\ntype DOMTargetObserverCallback = (targetChangedAttrs: string[], targetStyleChanged: boolean) => any;\n\ninterface DOMObserverOptionsBase {\n  _attributes?: string[];\n  /**\n   * A function which can ignore a changed attribute if it returns true.\n   * for DOMTargetObserver this applies to the changes to the observed target\n   * for DOMContentObserver this applies to changes to nested targets -> nested targets are elements which match the \"_nestedTargetSelector\" selector\n   */\n  _ignoreTargetChange?: DOMObserverIgnoreTargetChange;\n}\n\ninterface DOMContentObserverOptions extends DOMObserverOptionsBase {\n  _eventContentChange?: DOMObserverEventContentChange; // [selector, eventname(s) | function returning eventname(s)] -> eventnames divided by whitespaces\n  _nestedTargetSelector?: string;\n  _ignoreContentChange?: DOMObserverIgnoreContentChange; // function which will prevent marking certain dom changes as content change if it returns true\n}\n\ninterface DOMTargetObserverOptions extends DOMObserverOptionsBase {\n  /**\n   * Marks certain attributes as style changing, should be a subset of the _attributes prop.\n   * Used to set the \"targetStyleChanged\" param in the DOMTargetObserverCallback.\n   */\n  _styleChangingAttributes?: string[];\n}\n\ntype ContentChangeArrayItem = [selector?: string, eventNames?: string] | null | undefined;\n\nexport type DOMObserverEventContentChange =\n  | Array<ContentChangeArrayItem>\n  | false\n  | null\n  | undefined;\n\nexport type DOMObserverIgnoreContentChange = (\n  mutation: MutationRecord,\n  isNestedTarget: boolean,\n  domObserverTarget: HTMLElement,\n  domObserverOptions?: DOMContentObserverOptions\n) => boolean;\n\nexport type DOMObserverIgnoreTargetChange = (\n  target: Node,\n  attributeName: string,\n  oldAttributeValue: string | null,\n  newAttributeValue: string | null\n) => boolean;\n\nexport type DOMObserverCallback<ContentObserver extends boolean> = ContentObserver extends true\n  ? DOMContentObserverCallback\n  : DOMTargetObserverCallback;\n\nexport type DOMObserverOptions<ContentObserver extends boolean> = ContentObserver extends true\n  ? DOMContentObserverOptions\n  : DOMTargetObserverOptions;\n\nexport type DOMObserver<ContentObserver extends boolean> = [\n  destroy: () => void,\n  update: () => void | false | Parameters<DOMObserverCallback<ContentObserver>>\n];\n\ntype EventContentChangeUpdateElement = (\n  getElements?: (selector: string) => Node[],\n  removed?: boolean\n) => void;\ntype EventContentChange = [destroy: () => void, updateElements: EventContentChangeUpdateElement];\n\n/**\n * Creates a set of helper functions to observe events of elements inside the target element.\n * @param target The target element of which the children elements shall be observed. (not only direct children but also nested ones)\n * @param eventContentChange The event content change array. (array of tuples: selector and eventname(s))\n * @param callback Callback which is called if one of the elements emits the corresponding event.\n * @returns A object which contains a set of helper functions to destroy and update the observation of elements.\n */\nconst createEventContentChange = (\n  target: HTMLElement,\n  callback: (...args: any) => any,\n  eventContentChange?: DOMObserverEventContentChange\n): EventContentChange => {\n  let map: WeakMap<Node, (() => any)[]> | undefined; // weak map to prevent memory leak for detached elements\n  let destroyed = false;\n  const destroy = () => {\n    destroyed = true;\n  };\n  const updateElements: EventContentChangeUpdateElement = (getElements) => {\n    if (eventContentChange) {\n      const eventElmList = eventContentChange.reduce<Array<[Node[], string]>>((arr, item) => {\n        if (item) {\n          const [selector, eventNames] = item;\n          const elements =\n            eventNames &&\n            selector &&\n            (getElements ? getElements(selector) : find(selector, target));\n\n          if (elements && elements.length && eventNames && isString(eventNames)) {\n            push(arr, [elements, eventNames.trim()], true);\n          }\n        }\n        return arr;\n      }, []);\n\n      each(eventElmList, (item) =>\n        each(item[0], (elm) => {\n          const eventNames = item[1];\n          const entries = map!.get(elm) || [];\n          const isTargetChild = target.contains(elm);\n\n          if (isTargetChild) {\n            const off = on(elm, eventNames, (event: Event) => {\n              if (destroyed) {\n                off();\n                map!.delete(elm);\n              } else {\n                callback(event);\n              }\n            });\n            map!.set(elm, push(entries, off));\n          } else {\n            runEachAndClear(entries);\n            map!.delete(elm);\n          }\n        })\n      );\n    }\n  };\n\n  if (eventContentChange) {\n    map = new WeakMap();\n    updateElements();\n  }\n\n  return [destroy, updateElements];\n};\n\n/**\n * Creates a DOM observer which observes DOM changes to either the target element or its children.\n * @param target The element which shall be observed.\n * @param isContentObserver Whether this observer is just observing the target or just the targets children. (not only direct children but also nested ones)\n * @param callback The callback which gets called if a change was detected.\n * @param options The options for DOM change detection.\n * @returns A object which represents the instance of the DOM observer.\n */\nexport const createDOMObserver = <ContentObserver extends boolean>(\n  target: HTMLElement,\n  isContentObserver: ContentObserver,\n  callback: DOMObserverCallback<ContentObserver>,\n  options?: DOMObserverOptions<ContentObserver>\n): DOMObserver<ContentObserver> => {\n  let isConnected = false;\n  const {\n    _attributes,\n    _styleChangingAttributes,\n    _eventContentChange,\n    _nestedTargetSelector,\n    _ignoreTargetChange,\n    _ignoreContentChange,\n  } = (options as DOMContentObserverOptions & DOMTargetObserverOptions) || {};\n  const debouncedEventContentChange = debounce(\n    () => {\n      if (isConnected) {\n        (callback as DOMContentObserverCallback)(true);\n      }\n    },\n    { _timeout: 33, _maxDelay: 99 }\n  );\n  const [destroyEventContentChange, updateEventContentChangeElements] = createEventContentChange(\n    target,\n    debouncedEventContentChange,\n    _eventContentChange\n  );\n\n  // MutationObserver\n  const finalAttributes = _attributes || [];\n  const finalStyleChangingAttributes = _styleChangingAttributes || [];\n  const observedAttributes = finalAttributes.concat(finalStyleChangingAttributes);\n  const observerCallback = (\n    mutations: MutationRecord[],\n    fromRecords?: true\n  ): void | Parameters<DOMObserverCallback<ContentObserver>> => {\n    const ignoreTargetChange = _ignoreTargetChange || noop;\n    const ignoreContentChange = _ignoreContentChange || noop;\n    const totalChangedNodes: Set<Node> = new Set();\n    const targetChangedAttrs: Set<string> = new Set();\n    let targetStyleChanged = false;\n    let contentChanged = false;\n    let childListChanged = false;\n\n    each(mutations, (mutation) => {\n      const {\n        attributeName,\n        target: mutationTarget,\n        type,\n        oldValue,\n        addedNodes,\n        removedNodes,\n      } = mutation;\n      const isAttributesType = type === 'attributes';\n      const isChildListType = type === 'childList';\n      const targetIsMutationTarget = target === mutationTarget;\n      const attributeValue =\n        isAttributesType && isString(attributeName)\n          ? attr(mutationTarget as HTMLElement, attributeName!)\n          : 0;\n      const attributeChanged = attributeValue !== 0 && oldValue !== attributeValue;\n      const styleChangingAttrChanged =\n        indexOf(finalStyleChangingAttributes, attributeName) > -1 && attributeChanged;\n\n      // if is content observer and something changed in children\n      if (isContentObserver && (isChildListType || !targetIsMutationTarget)) {\n        const notOnlyAttrChanged = !isAttributesType;\n        const contentAttrChanged = isAttributesType && attributeChanged;\n        const isNestedTarget =\n          contentAttrChanged && _nestedTargetSelector && is(mutationTarget, _nestedTargetSelector);\n        const baseAssertion = isNestedTarget\n          ? !ignoreTargetChange(mutationTarget, attributeName!, oldValue, attributeValue)\n          : notOnlyAttrChanged || contentAttrChanged;\n        const contentFinalChanged =\n          baseAssertion && !ignoreContentChange(mutation, !!isNestedTarget, target, options);\n\n        each(addedNodes, (node) => totalChangedNodes.add(node));\n        each(removedNodes, (node) => totalChangedNodes.add(node));\n\n        contentChanged = contentChanged || contentFinalChanged;\n        childListChanged = childListChanged || isChildListType;\n      }\n      // if is target observer and target attr changed\n      if (\n        !isContentObserver &&\n        targetIsMutationTarget &&\n        attributeChanged &&\n        !ignoreTargetChange(mutationTarget, attributeName!, oldValue, attributeValue)\n      ) {\n        targetChangedAttrs.add(attributeName!);\n        targetStyleChanged = targetStyleChanged || styleChangingAttrChanged;\n      }\n    });\n\n    // adds / removes the new elements from the event content change\n    if (totalChangedNodes.size > 0) {\n      updateEventContentChangeElements((selector: string) =>\n        from(totalChangedNodes).reduce<Node[]>((arr, node) => {\n          push(arr, find(selector, node));\n          return is(node, selector) ? push(arr, node) : arr;\n        }, [])\n      );\n    }\n\n    if (isContentObserver) {\n      !fromRecords && contentChanged && (callback as DOMContentObserverCallback)(false);\n      return [false] as Parameters<DOMObserverCallback<ContentObserver>>;\n    }\n\n    if (targetChangedAttrs.size > 0 || targetStyleChanged) {\n      const args: Parameters<DOMTargetObserverCallback> = [\n        from(targetChangedAttrs),\n        targetStyleChanged,\n      ];\n      !fromRecords && (callback as DOMTargetObserverCallback).apply(0, args);\n\n      return args as Parameters<DOMObserverCallback<ContentObserver>>;\n    }\n  };\n  const mutationObserver: MutationObserver = new MutationObserverConstructor!((mutations) =>\n    observerCallback(mutations)\n  );\n\n  // Connect\n  mutationObserver.observe(target, {\n    attributes: true,\n    attributeOldValue: true,\n    attributeFilter: observedAttributes,\n    subtree: isContentObserver,\n    childList: isContentObserver,\n    characterData: isContentObserver,\n  });\n  isConnected = true;\n\n  return [\n    () => {\n      if (isConnected) {\n        destroyEventContentChange();\n        mutationObserver.disconnect();\n        isConnected = false;\n      }\n    },\n    () => {\n      if (isConnected) {\n        debouncedEventContentChange._flush();\n\n        const records = mutationObserver.takeRecords();\n        return !isEmptyArray(records) && observerCallback(records, true);\n      }\n    },\n  ];\n};\n","import {\r\n  createCache,\r\n  createDOM,\r\n  scrollLeft,\r\n  scrollTop,\r\n  runEachAndClear,\r\n  removeElements,\r\n  on,\r\n  addClass,\r\n  push,\r\n  ResizeObserverConstructor,\r\n  isArray,\r\n  isBoolean,\r\n  removeClass,\r\n  isObject,\r\n  stopPropagation,\r\n  appendChildren,\r\n  directionIsRTL,\r\n} from '~/support';\r\nimport { getEnvironment } from '~/environment';\r\nimport {\r\n  classNameSizeObserver,\r\n  classNameSizeObserverAppear,\r\n  classNameSizeObserverListener,\r\n} from '~/classnames';\r\nimport { getPlugins, sizeObserverPluginName } from '~/plugins';\r\nimport type { CacheValues } from '~/support';\r\nimport type { SizeObserverPluginInstance } from '~/plugins';\r\n\r\nexport interface SizeObserverOptions {\r\n  _direction?: boolean;\r\n  _appear?: boolean;\r\n}\r\n\r\nexport interface SizeObserverCallbackParams {\r\n  _sizeChanged: boolean;\r\n  _directionIsRTLCache?: CacheValues<boolean>;\r\n  _appear?: boolean;\r\n}\r\n\r\nexport type SizeObserver = [destroy: () => void, append: () => void];\r\n\r\nconst scrollAmount = 3333333;\r\nconst domRectHasDimensions = (rect?: DOMRectReadOnly) => rect && (rect.height || rect.width);\r\n\r\n/**\r\n * Creates a size observer which observes any size, padding, border, margin and box-sizing changes of the target element. Depending on the options also direction and appear can be observed.\r\n * @param target The target element which shall be observed.\r\n * @param onSizeChangedCallback The callback which gets called after a size change was detected.\r\n * @param options The options for size detection, whether to observe also direction and appear.\r\n * @returns A object which represents the instance of the size observer.\r\n */\r\nexport const createSizeObserver = (\r\n  target: HTMLElement,\r\n  onSizeChangedCallback: (params: SizeObserverCallbackParams) => any,\r\n  options?: SizeObserverOptions\r\n): SizeObserver => {\r\n  const { _direction: observeDirectionChange = false, _appear: observeAppearChange = false } =\r\n    options || {};\r\n  const sizeObserverPlugin = getPlugins()[sizeObserverPluginName] as\r\n    | SizeObserverPluginInstance\r\n    | undefined;\r\n  const { _rtlScrollBehavior: rtlScrollBehavior } = getEnvironment();\r\n  const baseElements = createDOM(\r\n    `<div class=\"${classNameSizeObserver}\"><div class=\"${classNameSizeObserverListener}\"></div></div>`\r\n  );\r\n  const sizeObserver = baseElements[0] as HTMLElement;\r\n  const listenerElement = sizeObserver.firstChild as HTMLElement;\r\n  const getIsDirectionRTL = directionIsRTL.bind(0, target);\r\n  const [updateResizeObserverContentRectCache] = createCache<DOMRectReadOnly | undefined>({\r\n    _initialValue: undefined,\r\n    _alwaysUpdateValues: true,\r\n    _equal: (currVal, newVal) =>\r\n      !(\r\n        !currVal || // if no initial value\r\n        // if from display: none to display: block\r\n        (!domRectHasDimensions(currVal) && domRectHasDimensions(newVal))\r\n      ),\r\n  });\r\n  const onSizeChangedCallbackProxy = (\r\n    sizeChangedContext?: CacheValues<boolean> | ResizeObserverEntry[] | Event | boolean\r\n  ) => {\r\n    const isResizeObserverCall =\r\n      isArray(sizeChangedContext) &&\r\n      sizeChangedContext.length > 0 &&\r\n      isObject(sizeChangedContext[0]);\r\n\r\n    const hasDirectionCache =\r\n      !isResizeObserverCall && isBoolean((sizeChangedContext as CacheValues<boolean>)[0]);\r\n\r\n    let skip = false;\r\n    let appear: boolean | number | undefined = false;\r\n    let doDirectionScroll = true; // always true if sizeChangedContext is Event (appear callback or RO. Polyfill)\r\n\r\n    // if triggered from RO.\r\n    if (isResizeObserverCall) {\r\n      const [currRContentRect, , prevContentRect] = updateResizeObserverContentRectCache(\r\n        (sizeChangedContext as ResizeObserverEntry[]).pop()!.contentRect\r\n      );\r\n      const hasDimensions = domRectHasDimensions(currRContentRect);\r\n      const hadDimensions = domRectHasDimensions(prevContentRect);\r\n      skip = !prevContentRect || !hasDimensions; // skip on initial RO. call or if display is none\r\n      appear = !hadDimensions && hasDimensions;\r\n\r\n      doDirectionScroll = !skip; // direction scroll when not skipping\r\n    }\r\n    // else if its triggered with DirectionCache\r\n    else if (hasDirectionCache) {\r\n      [, doDirectionScroll] = sizeChangedContext as CacheValues<boolean>; // direction scroll when DirectionCache changed, false otherwise\r\n    }\r\n    // else if it triggered with appear from polyfill\r\n    else {\r\n      appear = sizeChangedContext === true;\r\n    }\r\n\r\n    if (observeDirectionChange && doDirectionScroll) {\r\n      const rtl = hasDirectionCache\r\n        ? (sizeChangedContext as CacheValues<boolean>)[0]\r\n        : directionIsRTL(sizeObserver);\r\n      scrollLeft(\r\n        sizeObserver,\r\n        rtl\r\n          ? rtlScrollBehavior.n\r\n            ? -scrollAmount\r\n            : rtlScrollBehavior.i\r\n            ? 0\r\n            : scrollAmount\r\n          : scrollAmount\r\n      );\r\n      scrollTop(sizeObserver, scrollAmount);\r\n    }\r\n\r\n    if (!skip) {\r\n      onSizeChangedCallback({\r\n        _sizeChanged: !hasDirectionCache,\r\n        _directionIsRTLCache: hasDirectionCache\r\n          ? (sizeChangedContext as CacheValues<boolean>)\r\n          : undefined,\r\n        _appear: !!appear,\r\n      });\r\n    }\r\n  };\r\n  const offListeners: (() => void)[] = [];\r\n  let appearCallback: ((...args: any) => any) | false = observeAppearChange\r\n    ? onSizeChangedCallbackProxy\r\n    : false;\r\n\r\n  return [\r\n    () => {\r\n      runEachAndClear(offListeners);\r\n      removeElements(sizeObserver);\r\n    },\r\n    () => {\r\n      if (ResizeObserverConstructor) {\r\n        const resizeObserverInstance = new ResizeObserverConstructor(onSizeChangedCallbackProxy);\r\n        resizeObserverInstance.observe(listenerElement);\r\n        push(offListeners, () => {\r\n          resizeObserverInstance.disconnect();\r\n        });\r\n      } else if (sizeObserverPlugin) {\r\n        const [pluginAppearCallback, pluginOffListeners] = sizeObserverPlugin._(\r\n          listenerElement,\r\n          onSizeChangedCallbackProxy,\r\n          observeAppearChange\r\n        );\r\n        appearCallback = pluginAppearCallback;\r\n        push(offListeners, pluginOffListeners);\r\n      }\r\n\r\n      if (observeDirectionChange) {\r\n        const [updateDirectionIsRTLCache] = createCache(\r\n          {\r\n            _initialValue: !getIsDirectionRTL(), // invert current value to trigger initial change\r\n          },\r\n          getIsDirectionRTL\r\n        );\r\n\r\n        push(\r\n          offListeners,\r\n          on(sizeObserver, 'scroll', (event: Event) => {\r\n            const directionIsRTLCacheValues = updateDirectionIsRTLCache();\r\n            const [directionIsRTLCache, directionIsRTLCacheChanged] = directionIsRTLCacheValues;\r\n\r\n            if (directionIsRTLCacheChanged) {\r\n              removeClass(listenerElement, 'ltr rtl');\r\n              if (directionIsRTLCache) {\r\n                addClass(listenerElement, 'rtl');\r\n              } else {\r\n                addClass(listenerElement, 'ltr');\r\n              }\r\n              onSizeChangedCallbackProxy(directionIsRTLCacheValues);\r\n            }\r\n\r\n            stopPropagation(event);\r\n          })\r\n        );\r\n      }\r\n\r\n      // appearCallback is always needed on scroll-observer strategy to reset it\r\n      if (appearCallback) {\r\n        addClass(sizeObserver, classNameSizeObserverAppear);\r\n        push(\r\n          offListeners,\r\n          on(sizeObserver, 'animationstart', appearCallback, {\r\n            // Fire only once for \"CSS is ready\" event if ResizeObserver strategy is used\r\n            _once: !!ResizeObserverConstructor,\r\n          })\r\n        );\r\n      }\r\n\r\n      if (ResizeObserverConstructor || sizeObserverPlugin) {\r\n        appendChildren(target, sizeObserver);\r\n      }\r\n    },\r\n  ];\r\n};\r\n","import {\r\n  createDiv,\r\n  offsetSize,\r\n  runEachAndClear,\r\n  removeElements,\r\n  createCache,\r\n  push,\r\n  IntersectionObserverConstructor,\r\n  appendChildren,\r\n} from '~/support';\r\nimport { createSizeObserver } from '~/observers/sizeObserver';\r\nimport { classNameTrinsicObserver } from '~/classnames';\r\nimport type { WH, CacheValues } from '~/support';\r\n\r\nexport type TrinsicObserverCallback = (heightIntrinsic: CacheValues<boolean>) => any;\r\nexport type TrinsicObserver = [\r\n  destroy: () => void,\r\n  append: () => void,\r\n  update: () => void | Parameters<TrinsicObserverCallback>\r\n];\r\n\r\nconst isHeightIntrinsic = (ioEntryOrSize: IntersectionObserverEntry | WH<number>): boolean =>\r\n  (ioEntryOrSize as WH<number>).h === 0 ||\r\n  (ioEntryOrSize as IntersectionObserverEntry).isIntersecting ||\r\n  (ioEntryOrSize as IntersectionObserverEntry).intersectionRatio > 0;\r\n\r\n/**\r\n * Creates a trinsic observer which observes changes to intrinsic or extrinsic sizing for the height of the target element.\r\n * @param target The element which shall be observed.\r\n * @param onTrinsicChangedCallback The callback which gets called after a change was detected.\r\n * @returns A object which represents the instance of the trinsic observer.\r\n */\r\nexport const createTrinsicObserver = (\r\n  target: HTMLElement,\r\n  onTrinsicChangedCallback: TrinsicObserverCallback\r\n): TrinsicObserver => {\r\n  let intersectionObserverInstance: undefined | IntersectionObserver;\r\n  const trinsicObserver = createDiv(classNameTrinsicObserver);\r\n  const offListeners: (() => void)[] = [];\r\n  const [updateHeightIntrinsicCache] = createCache({\r\n    _initialValue: false,\r\n  });\r\n  const triggerOnTrinsicChangedCallback = (\r\n    updateValue?: IntersectionObserverEntry | WH<number>,\r\n    fromRecords?: true\r\n  ): void | Parameters<TrinsicObserverCallback> => {\r\n    if (updateValue) {\r\n      const heightIntrinsic = updateHeightIntrinsicCache(isHeightIntrinsic(updateValue));\r\n      const [, heightIntrinsicChanged] = heightIntrinsic;\r\n\r\n      if (heightIntrinsicChanged) {\r\n        !fromRecords && onTrinsicChangedCallback(heightIntrinsic);\r\n        return [heightIntrinsic];\r\n      }\r\n    }\r\n  };\r\n  const intersectionObserverCallback = (\r\n    entries: IntersectionObserverEntry[],\r\n    fromRecords?: true\r\n  ) => {\r\n    if (entries && entries.length > 0) {\r\n      return triggerOnTrinsicChangedCallback(entries.pop(), fromRecords);\r\n    }\r\n  };\r\n\r\n  return [\r\n    () => {\r\n      runEachAndClear(offListeners);\r\n      removeElements(trinsicObserver);\r\n    },\r\n    () => {\r\n      if (IntersectionObserverConstructor) {\r\n        intersectionObserverInstance = new IntersectionObserverConstructor(\r\n          (entries) => intersectionObserverCallback(entries),\r\n          { root: target }\r\n        );\r\n        intersectionObserverInstance.observe(trinsicObserver);\r\n        push(offListeners, () => {\r\n          intersectionObserverInstance!.disconnect();\r\n        });\r\n      } else {\r\n        const onSizeChanged = () => {\r\n          const newSize = offsetSize(trinsicObserver);\r\n          triggerOnTrinsicChangedCallback(newSize);\r\n        };\r\n        const [destroySizeObserver, appendSizeObserver] = createSizeObserver(\r\n          trinsicObserver,\r\n          onSizeChanged\r\n        );\r\n        push(offListeners, destroySizeObserver);\r\n        appendSizeObserver();\r\n        onSizeChanged();\r\n      }\r\n\r\n      appendChildren(target, trinsicObserver);\r\n    },\r\n    () => {\r\n      if (intersectionObserverInstance) {\r\n        return intersectionObserverCallback(intersectionObserverInstance.takeRecords(), true);\r\n      }\r\n    },\r\n  ];\r\n};\r\n","import {\r\n  debounce,\r\n  isArray,\r\n  isNumber,\r\n  each,\r\n  indexOf,\r\n  isString,\r\n  attr,\r\n  removeAttr,\r\n  keys,\r\n  liesBetween,\r\n  scrollSize,\r\n  equalWH,\r\n  createCache,\r\n  fractionalSize,\r\n  isFunction,\r\n  ResizeObserverConstructor,\r\n  closest,\r\n  assignDeep,\r\n  push,\r\n  scrollLeft,\r\n  scrollTop,\r\n  noop,\r\n} from '~/support';\r\nimport { getEnvironment } from '~/environment';\r\nimport {\r\n  dataAttributeHost,\r\n  dataValueHostOverflowVisible,\r\n  dataValueHostUpdating,\r\n  classNameViewport,\r\n  classNameOverflowVisible,\r\n  classNameScrollbar,\r\n  classNameViewportArrange,\r\n} from '~/classnames';\r\nimport { createSizeObserver, createTrinsicObserver, createDOMObserver } from '~/observers';\r\nimport type { DOMObserver, SizeObserverCallbackParams } from '~/observers';\r\nimport type { CacheValues, WH } from '~/support';\r\nimport type { SetupState, SetupUpdateCheckOption } from '~/setups';\r\nimport type { StructureSetupState } from '~/setups/structureSetup';\r\nimport type { StructureSetupElementsObj } from '~/setups/structureSetup/structureSetup.elements';\r\nimport type {\r\n  StructureSetupUpdate,\r\n  StructureSetupUpdateHints,\r\n} from '~/setups/structureSetup/structureSetup.update';\r\n\r\nexport type StructureSetupObserversUpdate = (checkOption: SetupUpdateCheckOption) => void;\r\n\r\nexport type StructureSetupObservers = [\r\n  destroy: () => void,\r\n  appendElements: () => void,\r\n  updateObservers: () => Partial<StructureSetupUpdateHints>,\r\n  updateObserversOptions: StructureSetupObserversUpdate\r\n];\r\n\r\ntype ExcludeFromTuple<T extends readonly any[], E> = T extends [infer F, ...infer R]\r\n  ? [F] extends [E]\r\n    ? ExcludeFromTuple<R, E>\r\n    : [F, ...ExcludeFromTuple<R, E>]\r\n  : [];\r\n\r\nconst hostSelector = `[${dataAttributeHost}]`;\r\n\r\n// TODO: observer textarea attrs if textarea\r\n\r\nconst viewportSelector = `.${classNameViewport}`;\r\nconst viewportAttrsFromTarget = ['tabindex'];\r\nconst baseStyleChangingAttrsTextarea = ['wrap', 'cols', 'rows'];\r\nconst baseStyleChangingAttrs = ['id', 'class', 'style', 'open'];\r\n\r\nexport const createStructureSetupObservers = (\r\n  structureSetupElements: StructureSetupElementsObj,\r\n  setState: SetupState<StructureSetupState>[1],\r\n  structureSetupUpdate: (\r\n    ...args: ExcludeFromTuple<Parameters<StructureSetupUpdate>, Parameters<StructureSetupUpdate>[0]>\r\n  ) => any\r\n): StructureSetupObservers => {\r\n  let debounceTimeout: number | false | undefined;\r\n  let debounceMaxDelay: number | false | undefined;\r\n  let contentMutationObserver: DOMObserver<true> | undefined;\r\n  const {\r\n    _host,\r\n    _viewport,\r\n    _content,\r\n    _isTextarea,\r\n    _viewportIsTarget,\r\n    _viewportHasClass,\r\n    _viewportAddRemoveClass,\r\n  } = structureSetupElements;\r\n  const { _flexboxGlue } = getEnvironment();\r\n\r\n  const [updateContentSizeCache] = createCache<WH<number>>(\r\n    {\r\n      _equal: equalWH,\r\n      _initialValue: { w: 0, h: 0 },\r\n    },\r\n    () => {\r\n      const hasOver = _viewportHasClass(classNameOverflowVisible, dataValueHostOverflowVisible);\r\n      const hasVpStyle = _viewportHasClass(classNameViewportArrange, '');\r\n      const scrollOffsetX = hasVpStyle && scrollLeft(_viewport);\r\n      const scrollOffsetY = hasVpStyle && scrollTop(_viewport);\r\n      _viewportAddRemoveClass(classNameOverflowVisible, dataValueHostOverflowVisible);\r\n      _viewportAddRemoveClass(classNameViewportArrange, '');\r\n      _viewportAddRemoveClass('', dataValueHostUpdating, true);\r\n\r\n      const contentScroll = scrollSize(_content);\r\n      const viewportScroll = scrollSize(_viewport);\r\n      const fractional = fractionalSize(_viewport);\r\n\r\n      _viewportAddRemoveClass(classNameOverflowVisible, dataValueHostOverflowVisible, hasOver);\r\n      _viewportAddRemoveClass(classNameViewportArrange, '', hasVpStyle);\r\n      _viewportAddRemoveClass('', dataValueHostUpdating);\r\n      scrollLeft(_viewport, scrollOffsetX);\r\n      scrollTop(_viewport, scrollOffsetY);\r\n      return {\r\n        w: viewportScroll.w + contentScroll.w + fractional.w,\r\n        h: viewportScroll.h + contentScroll.h + fractional.h,\r\n      };\r\n    }\r\n  );\r\n  const contentMutationObserverAttr = _isTextarea\r\n    ? baseStyleChangingAttrsTextarea\r\n    : baseStyleChangingAttrs.concat(baseStyleChangingAttrsTextarea);\r\n  const structureSetupUpdateWithDebouncedAdaptiveUpdateHints = debounce(structureSetupUpdate, {\r\n    _timeout: () => debounceTimeout,\r\n    _maxDelay: () => debounceMaxDelay,\r\n    _mergeParams(prev, curr) {\r\n      const [prevObj] = prev;\r\n      const [currObj] = curr;\r\n      return [\r\n        keys(prevObj)\r\n          .concat(keys(currObj))\r\n          .reduce((obj, key) => {\r\n            obj[key] = prevObj[key] || currObj[key];\r\n            return obj;\r\n          }, {}),\r\n      ] as [Partial<StructureSetupUpdateHints>];\r\n    },\r\n  });\r\n\r\n  const updateViewportAttrsFromHost = (attributes?: string[]) => {\r\n    each(attributes || viewportAttrsFromTarget, (attribute) => {\r\n      if (indexOf(viewportAttrsFromTarget, attribute) > -1) {\r\n        const hostAttr = attr(_host, attribute);\r\n        if (isString(hostAttr)) {\r\n          attr(_viewport, attribute, hostAttr);\r\n        } else {\r\n          removeAttr(_viewport, attribute);\r\n        }\r\n      }\r\n    });\r\n  };\r\n  const onTrinsicChanged = (heightIntrinsicCache: CacheValues<boolean>, fromRecords?: true) => {\r\n    const [heightIntrinsic, heightIntrinsicChanged] = heightIntrinsicCache;\r\n    const updateHints: Partial<StructureSetupUpdateHints> = {\r\n      _heightIntrinsicChanged: heightIntrinsicChanged,\r\n    };\r\n    setState({ _heightIntrinsic: heightIntrinsic });\r\n\r\n    !fromRecords && structureSetupUpdate(updateHints);\r\n    return updateHints;\r\n  };\r\n  const onSizeChanged = ({\r\n    _sizeChanged,\r\n    _directionIsRTLCache,\r\n    _appear,\r\n  }: SizeObserverCallbackParams) => {\r\n    const updateFn =\r\n      !_sizeChanged || _appear\r\n        ? structureSetupUpdate\r\n        : structureSetupUpdateWithDebouncedAdaptiveUpdateHints;\r\n\r\n    let directionChanged = false;\r\n    if (_directionIsRTLCache) {\r\n      const [directionIsRTL, directionIsRTLChanged] = _directionIsRTLCache;\r\n      directionChanged = directionIsRTLChanged;\r\n\r\n      setState({ _directionIsRTL: directionIsRTL });\r\n    }\r\n\r\n    updateFn({ _sizeChanged, _directionChanged: directionChanged });\r\n  };\r\n  const onContentMutation = (contentChangedThroughEvent: boolean, fromRecords?: true) => {\r\n    const [, contentSizeChanged] = updateContentSizeCache();\r\n    const updateHints: Partial<StructureSetupUpdateHints> = {\r\n      _contentMutation: contentSizeChanged,\r\n    };\r\n    // if contentChangedThroughEvent is true its already debounced\r\n    const updateFn = contentChangedThroughEvent\r\n      ? structureSetupUpdate\r\n      : structureSetupUpdateWithDebouncedAdaptiveUpdateHints;\r\n\r\n    if (contentSizeChanged) {\r\n      !fromRecords && updateFn(updateHints);\r\n    }\r\n    return updateHints;\r\n  };\r\n  const onHostMutation = (\r\n    targetChangedAttrs: string[],\r\n    targetStyleChanged: boolean,\r\n    fromRecords?: true\r\n  ) => {\r\n    const updateHints: Partial<StructureSetupUpdateHints> = { _hostMutation: targetStyleChanged };\r\n    if (targetStyleChanged) {\r\n      !fromRecords && structureSetupUpdateWithDebouncedAdaptiveUpdateHints(updateHints);\r\n    } else if (!_viewportIsTarget) {\r\n      updateViewportAttrsFromHost(targetChangedAttrs);\r\n    }\r\n    return updateHints;\r\n  };\r\n\r\n  const [destroyTrinsicObserver, appendTrinsicObserver, updateTrinsicObserver] =\r\n    _content || !_flexboxGlue ? createTrinsicObserver(_host, onTrinsicChanged) : [noop, noop, noop];\r\n  const [destroySizeObserver, appendSizeObserver] = !_viewportIsTarget\r\n    ? createSizeObserver(_host, onSizeChanged, {\r\n        _appear: true,\r\n        _direction: true,\r\n      })\r\n    : [noop, noop];\r\n  const [destroyHostMutationObserver, updateHostMutationObserver] = createDOMObserver(\r\n    _host,\r\n    false,\r\n    onHostMutation,\r\n    {\r\n      _styleChangingAttributes: baseStyleChangingAttrs,\r\n      _attributes: baseStyleChangingAttrs.concat(viewportAttrsFromTarget),\r\n    }\r\n  );\r\n\r\n  const viewportIsTargetResizeObserver =\r\n    _viewportIsTarget &&\r\n    ResizeObserverConstructor &&\r\n    new ResizeObserverConstructor(onSizeChanged.bind(0, { _sizeChanged: true }));\r\n\r\n  viewportIsTargetResizeObserver && viewportIsTargetResizeObserver.observe(_host);\r\n  updateViewportAttrsFromHost();\r\n\r\n  return [\r\n    () => {\r\n      destroyTrinsicObserver();\r\n      destroySizeObserver();\r\n      contentMutationObserver && contentMutationObserver[0](); // destroy\r\n      viewportIsTargetResizeObserver && viewportIsTargetResizeObserver.disconnect();\r\n      destroyHostMutationObserver();\r\n    },\r\n    () => {\r\n      // order is matter!\r\n      appendSizeObserver();\r\n      appendTrinsicObserver();\r\n    },\r\n    () => {\r\n      const updateHints: Partial<StructureSetupUpdateHints> = {};\r\n      const hostUpdateResult = updateHostMutationObserver();\r\n      const trinsicUpdateResult = updateTrinsicObserver();\r\n      const contentUpdateResult = contentMutationObserver && contentMutationObserver[1](); // update\r\n\r\n      if (hostUpdateResult) {\r\n        assignDeep(\r\n          updateHints,\r\n          onHostMutation.apply(\r\n            0,\r\n            push(hostUpdateResult, true) as [\r\n              ...updateResult: typeof hostUpdateResult,\r\n              fromRecords: true\r\n            ]\r\n          )\r\n        );\r\n      }\r\n      if (trinsicUpdateResult) {\r\n        assignDeep(\r\n          updateHints,\r\n          onTrinsicChanged.apply(\r\n            0,\r\n            push(trinsicUpdateResult as any[], true) as [\r\n              ...updateResult: typeof trinsicUpdateResult,\r\n              fromRecords: true\r\n            ]\r\n          )\r\n        );\r\n      }\r\n      if (contentUpdateResult) {\r\n        assignDeep(\r\n          updateHints,\r\n          onContentMutation.apply(\r\n            0,\r\n            push(contentUpdateResult, true) as [\r\n              ...updateResult: typeof contentUpdateResult,\r\n              fromRecords: true\r\n            ]\r\n          )\r\n        );\r\n      }\r\n\r\n      return updateHints;\r\n    },\r\n    (checkOption) => {\r\n      const [ignoreMutation] = checkOption<string[] | null>('update.ignoreMutation');\r\n      const [attributes, attributesChanged] = checkOption<string[] | null>('update.attributes');\r\n      const [elementEvents, elementEventsChanged] = checkOption<Array<[string, string]> | null>(\r\n        'update.elementEvents'\r\n      );\r\n      const [debounceValue, debounceChanged] = checkOption<Array<number> | number | null>(\r\n        'update.debounce'\r\n      );\r\n      const updateContentMutationObserver = elementEventsChanged || attributesChanged;\r\n      const ignoreMutationFromOptions = (mutation: MutationRecord) =>\r\n        isFunction(ignoreMutation) && ignoreMutation(mutation);\r\n\r\n      if (updateContentMutationObserver) {\r\n        if (contentMutationObserver) {\r\n          contentMutationObserver[1](); // update\r\n          contentMutationObserver[0](); // destroy\r\n        }\r\n        contentMutationObserver = createDOMObserver(\r\n          _content || _viewport,\r\n          true,\r\n          onContentMutation,\r\n          {\r\n            _attributes: contentMutationObserverAttr.concat(attributes || []),\r\n            _eventContentChange: elementEvents,\r\n            _nestedTargetSelector: hostSelector,\r\n            _ignoreContentChange: (mutation, isNestedTarget) => {\r\n              const { target, attributeName } = mutation;\r\n              const ignore =\r\n                !isNestedTarget && attributeName && !_viewportIsTarget\r\n                  ? liesBetween(target, hostSelector, viewportSelector)\r\n                  : false;\r\n              return (\r\n                ignore ||\r\n                !!closest(target, `.${classNameScrollbar}`) || // ignore explicitely all scrollbar elements\r\n                !!ignoreMutationFromOptions(mutation)\r\n              );\r\n            },\r\n          }\r\n        );\r\n      }\r\n\r\n      if (debounceChanged) {\r\n        structureSetupUpdateWithDebouncedAdaptiveUpdateHints._flush();\r\n        if (isArray(debounceValue)) {\r\n          const timeout = debounceValue[0];\r\n          const maxWait = debounceValue[1];\r\n          debounceTimeout = isNumber(timeout) && timeout;\r\n          debounceMaxDelay = isNumber(maxWait) && maxWait;\r\n        } else if (isNumber(debounceValue)) {\r\n          debounceTimeout = debounceValue;\r\n          debounceMaxDelay = false;\r\n        } else {\r\n          debounceTimeout = false;\r\n          debounceMaxDelay = false;\r\n        }\r\n      }\r\n    },\r\n  ];\r\n};\r\n","import { createEventListenerHub, isEmptyObject, keys, scrollLeft, scrollTop } from '~/support';\r\nimport { createState, createOptionCheck } from '~/setups/setups';\r\nimport { createStructureSetupElements } from '~/setups/structureSetup/structureSetup.elements';\r\nimport { createStructureSetupUpdate } from '~/setups/structureSetup/structureSetup.update';\r\nimport { createStructureSetupObservers } from '~/setups/structureSetup/structureSetup.observers';\r\nimport type { StructureSetupUpdateHints } from '~/setups/structureSetup/structureSetup.update';\r\nimport type { StructureSetupElementsObj } from '~/setups/structureSetup/structureSetup.elements';\r\nimport type { TRBL, XY, EventListener } from '~/support';\r\nimport type { PartialOptions, ReadonlyOptions } from '~/options';\r\nimport type { Setup } from '~/setups';\r\nimport type { InitializationTarget } from '~/initialization';\r\nimport type { StyleObject, OverflowStyle } from '~/typings';\r\n\r\nexport interface StructureSetupState {\r\n  _padding: TRBL;\r\n  _paddingAbsolute: boolean;\r\n  _viewportPaddingStyle: StyleObject;\r\n  _overflowEdge: XY<number>;\r\n  _overflowAmount: XY<number>;\r\n  _overflowStyle: XY<OverflowStyle>;\r\n  _hasOverflow: XY<boolean>;\r\n  _heightIntrinsic: boolean;\r\n  _directionIsRTL: boolean;\r\n}\r\n\r\nexport interface StructureSetupStaticState {\r\n  _elements: StructureSetupElementsObj;\r\n  _appendElements: () => void;\r\n  _addOnUpdatedListener: (listener: EventListener<StructureSetupEventMap, 'u'>) => void;\r\n}\r\n\r\ntype StructureSetupEventMap = {\r\n  u: [updateHints: StructureSetupUpdateHints, changedOptions: PartialOptions, force: boolean];\r\n};\r\n\r\nconst initialXYNumber = { x: 0, y: 0 };\r\nconst initialStructureSetupUpdateState: StructureSetupState = {\r\n  _padding: {\r\n    t: 0,\r\n    r: 0,\r\n    b: 0,\r\n    l: 0,\r\n  },\r\n  _paddingAbsolute: false,\r\n  _viewportPaddingStyle: {\r\n    marginRight: 0,\r\n    marginBottom: 0,\r\n    marginLeft: 0,\r\n    paddingTop: 0,\r\n    paddingRight: 0,\r\n    paddingBottom: 0,\r\n    paddingLeft: 0,\r\n  },\r\n  _overflowEdge: initialXYNumber,\r\n  _overflowAmount: initialXYNumber,\r\n  _overflowStyle: {\r\n    x: 'hidden',\r\n    y: 'hidden',\r\n  },\r\n  _hasOverflow: {\r\n    x: false,\r\n    y: false,\r\n  },\r\n  _heightIntrinsic: false,\r\n  _directionIsRTL: false,\r\n};\r\n\r\nexport const createStructureSetup = (\r\n  target: InitializationTarget,\r\n  options: ReadonlyOptions\r\n): Setup<StructureSetupState, StructureSetupStaticState, [], boolean> => {\r\n  const checkOptionsFallback = createOptionCheck(options, {});\r\n  const state = createState(initialStructureSetupUpdateState);\r\n  const [addEvent, removeEvent, triggerEvent] = createEventListenerHub<StructureSetupEventMap>();\r\n  const [getState, setState] = state;\r\n  const [elements, appendStructureElements, destroyElements] = createStructureSetupElements(target);\r\n  const updateStructure = createStructureSetupUpdate(elements, state);\r\n  const triggerUpdateEvent: (...args: StructureSetupEventMap['u']) => boolean = (\r\n    updateHints,\r\n    changedOptions,\r\n    force\r\n  ) => {\r\n    const truthyUpdateHints = keys(updateHints).some((key) => updateHints[key]);\r\n    const changed = truthyUpdateHints || !isEmptyObject(changedOptions) || force;\r\n    if (changed) {\r\n      triggerEvent('u', [updateHints, changedOptions, force]);\r\n    }\r\n    return changed;\r\n  };\r\n  const [destroyObservers, appendObserverElements, updateObservers, updateObserversOptions] =\r\n    createStructureSetupObservers(elements, setState, (updateHints) =>\r\n      triggerUpdateEvent(updateStructure(checkOptionsFallback, updateHints), {}, false)\r\n    );\r\n\r\n  const structureSetupState = getState.bind(0) as (() => StructureSetupState) &\r\n    StructureSetupStaticState;\r\n  structureSetupState._addOnUpdatedListener = (listener) => addEvent('u', listener);\r\n  structureSetupState._appendElements = () => {\r\n    const { _target, _viewport } = elements;\r\n    const initialScrollLeft = scrollLeft(_target);\r\n    const initialScrollTop = scrollTop(_target);\r\n\r\n    appendObserverElements();\r\n    appendStructureElements();\r\n\r\n    scrollLeft(_viewport, initialScrollLeft);\r\n    scrollTop(_viewport, initialScrollTop);\r\n  };\r\n  structureSetupState._elements = elements;\r\n\r\n  return [\r\n    (changedOptions, force?) => {\r\n      const checkOption = createOptionCheck(options, changedOptions, force);\r\n      updateObserversOptions(checkOption);\r\n      return triggerUpdateEvent(\r\n        updateStructure(checkOption, updateObservers(), force),\r\n        changedOptions,\r\n        !!force\r\n      );\r\n    },\r\n    structureSetupState,\r\n    () => {\r\n      removeEvent();\r\n      destroyObservers();\r\n      destroyElements();\r\n    },\r\n  ];\r\n};\r\n","import {\n  directionIsRTL,\n  getBoundingClientRect,\n  offsetSize,\n  on,\n  preventDefault,\n  runEachAndClear,\n  stopPropagation,\n  selfClearTimeout,\n  parent,\n  closest,\n  push,\n} from '~/support';\nimport { getPlugins, clickScrollPluginName } from '~/plugins';\nimport { getEnvironment } from '~/environment';\nimport {\n  classNameScrollbarHandle,\n  classNameScrollbarInteraction,\n  classNameScrollbarWheel,\n} from '~/classnames';\nimport type { XY } from '~/support';\nimport type { ClickScrollPluginInstance } from '~/plugins';\nimport type { ReadonlyOptions } from '~/options';\nimport type { StructureSetupState } from '~/setups';\nimport type {\n  ScrollbarsSetupElementsObj,\n  ScrollbarStructure,\n} from '~/setups/scrollbarsSetup/scrollbarsSetup.elements';\n\nexport type ScrollbarsSetupEvents = (\n  scrollbarStructure: ScrollbarStructure,\n  scrollbarsAddRemoveClass: ScrollbarsSetupElementsObj['_scrollbarsAddRemoveClass'],\n  documentElm: Document,\n  hostElm: HTMLElement,\n  scrollOffsetElm: HTMLElement,\n  isHorizontal?: boolean\n) => () => void;\n\nconst { round } = Math;\nconst getScale = (element: HTMLElement): XY<number> => {\n  const { width, height } = getBoundingClientRect(element);\n  const { w, h } = offsetSize(element);\n  return {\n    x: round(width) / w || 1,\n    y: round(height) / h || 1,\n  };\n};\nconst continuePointerDown = (\n  event: PointerEvent,\n  options: ReadonlyOptions,\n  isDragScroll: boolean\n) => {\n  const scrollbarOptions = options.scrollbars;\n  const { button, isPrimary, pointerType } = event;\n  const { pointers } = scrollbarOptions;\n  return (\n    button === 0 &&\n    isPrimary &&\n    scrollbarOptions[isDragScroll ? 'dragScroll' : 'clickScroll'] &&\n    (pointers || []).includes(pointerType)\n  );\n};\nconst createRootClickStopPropagationEvents = (scrollbar: HTMLElement, documentElm: Document) =>\n  on(\n    scrollbar,\n    'mousedown',\n    on.bind(0, documentElm, 'click', stopPropagation, { _once: true, _capture: true }),\n    { _capture: true }\n  );\nconst createInteractiveScrollEvents = (\n  options: ReadonlyOptions,\n  doc: Document,\n  scrollbarStructure: ScrollbarStructure,\n  scrollOffsetElement: HTMLElement,\n  structureSetupState: () => StructureSetupState,\n  isHorizontal?: boolean\n) => {\n  const { _rtlScrollBehavior } = getEnvironment();\n  const { _handle, _track, _scrollbar } = scrollbarStructure;\n  const scrollLeftTopKey = `scroll${isHorizontal ? 'Left' : 'Top'}`;\n  const clientXYKey = `client${isHorizontal ? 'X' : 'Y'}`; // for pointer event (can't use xy because of IE11)\n  const widthHeightKey = isHorizontal ? 'width' : 'height';\n  const leftTopKey = isHorizontal ? 'left' : 'top'; // for BCR (can't use xy because of IE11)\n  const whKey = isHorizontal ? 'w' : 'h';\n  const xyKey = isHorizontal ? 'x' : 'y';\n\n  const createRelativeHandleMove =\n    (mouseDownScroll: number, invertedScale: number) => (deltaMovement: number) => {\n      const { _overflowAmount } = structureSetupState();\n      const handleTrackDiff = offsetSize(_track)[whKey] - offsetSize(_handle)[whKey];\n      const scrollDeltaPercent = (invertedScale * deltaMovement) / handleTrackDiff;\n      const scrollDelta = scrollDeltaPercent * _overflowAmount[xyKey];\n      const isRTL = directionIsRTL(_scrollbar);\n      const negateMultiplactor =\n        isRTL && isHorizontal ? (_rtlScrollBehavior.n || _rtlScrollBehavior.i ? 1 : -1) : 1;\n\n      scrollOffsetElement[scrollLeftTopKey] = mouseDownScroll + scrollDelta * negateMultiplactor;\n    };\n\n  return on(_track, 'pointerdown', (pointerDownEvent: PointerEvent) => {\n    const isDragScroll =\n      closest(pointerDownEvent.target as Node, `.${classNameScrollbarHandle}`) === _handle;\n\n    if (continuePointerDown(pointerDownEvent, options, isDragScroll)) {\n      const instantClickScroll = !isDragScroll && pointerDownEvent.shiftKey;\n      const getHandleRect = () => getBoundingClientRect(_handle);\n      const getTrackRect = () => getBoundingClientRect(_track);\n      const getHandleOffset = (handleRect?: DOMRect, trackRect?: DOMRect) =>\n        (handleRect || getHandleRect())[leftTopKey] - (trackRect || getTrackRect())[leftTopKey];\n      const moveHandleRelative = createRelativeHandleMove(\n        scrollOffsetElement[scrollLeftTopKey] || 0,\n        1 / getScale(scrollOffsetElement)[xyKey]\n      );\n      const pointerDownOffset = pointerDownEvent[clientXYKey];\n      const handleRect = getHandleRect();\n      const trackRect = getTrackRect();\n      const handleLength = handleRect[widthHeightKey];\n      const handleCenter = getHandleOffset(handleRect, trackRect) + handleLength / 2;\n      const relativeTrackPointerOffset = pointerDownOffset - trackRect[leftTopKey];\n      const startOffset = isDragScroll ? 0 : relativeTrackPointerOffset - handleCenter;\n\n      const offFns = [\n        on(doc, 'selectstart', (event: Event) => preventDefault(event), {\n          _passive: false,\n        }),\n        on(_track, 'pointermove', (pointerMoveEvent: PointerEvent) => {\n          const relativeMovement = pointerMoveEvent[clientXYKey] - pointerDownOffset;\n\n          if (isDragScroll || instantClickScroll) {\n            moveHandleRelative(startOffset + relativeMovement);\n          }\n        }),\n      ];\n\n      if (instantClickScroll) {\n        moveHandleRelative(startOffset);\n      } else if (!isDragScroll) {\n        const sizeObserverPlugin = getPlugins()[clickScrollPluginName] as\n          | ClickScrollPluginInstance\n          | undefined;\n\n        if (sizeObserverPlugin) {\n          push(\n            offFns,\n            sizeObserverPlugin._(\n              moveHandleRelative,\n              getHandleOffset,\n              startOffset,\n              handleLength,\n              relativeTrackPointerOffset\n            )\n          );\n        }\n      }\n\n      on(\n        _track,\n        'pointerup',\n        (pointerUpEvent: PointerEvent) => {\n          runEachAndClear(offFns);\n          _track.releasePointerCapture(pointerUpEvent.pointerId);\n        },\n        { _once: true }\n      );\n      _track.setPointerCapture(pointerDownEvent.pointerId);\n    }\n  });\n};\n\nexport const createScrollbarsSetupEvents =\n  (\n    options: ReadonlyOptions,\n    structureSetupState: () => StructureSetupState\n  ): ScrollbarsSetupEvents =>\n  (\n    scrollbarStructure,\n    scrollbarsAddRemoveClass,\n    documentElm,\n    hostElm,\n    scrollOffsetElm,\n    isHorizontal\n  ) => {\n    const { _scrollbar } = scrollbarStructure;\n    const [wheelTimeout, clearScrollTimeout] = selfClearTimeout(333);\n    const scrollByFn = !!scrollOffsetElm.scrollBy;\n    let wheelScrollBy = true;\n\n    return runEachAndClear.bind(0, [\n      on(_scrollbar, 'pointerenter', () => {\n        scrollbarsAddRemoveClass(classNameScrollbarInteraction, true);\n      }),\n      on(_scrollbar, 'pointerleave pointercancel', () => {\n        scrollbarsAddRemoveClass(classNameScrollbarInteraction);\n      }),\n      on(\n        _scrollbar,\n        'wheel',\n        (wheelEvent: WheelEvent) => {\n          const { deltaX, deltaY, deltaMode } = wheelEvent;\n\n          // the first wheel event is swallowed, simulate scroll to compensate for it\n          if (scrollByFn && wheelScrollBy && deltaMode === 0 && parent(_scrollbar) === hostElm) {\n            scrollOffsetElm.scrollBy({\n              left: deltaX,\n              top: deltaY,\n              behavior: 'smooth',\n            });\n          }\n\n          wheelScrollBy = false;\n          scrollbarsAddRemoveClass(classNameScrollbarWheel, true);\n          wheelTimeout(() => {\n            wheelScrollBy = true;\n            scrollbarsAddRemoveClass(classNameScrollbarWheel);\n          });\n\n          preventDefault(wheelEvent);\n        },\n        { _passive: false, _capture: true }\n      ),\n      createRootClickStopPropagationEvents(_scrollbar, documentElm),\n      createInteractiveScrollEvents(\n        options,\n        documentElm,\n        scrollbarStructure,\n        scrollOffsetElm,\n        structureSetupState,\n        isHorizontal\n      ),\n      clearScrollTimeout,\n    ]);\n  };\n","import { offsetSize } from '~/support';\nimport { getEnvironment } from '~/environment';\nimport type { StructureSetupState } from '~/setups';\n\nconst { min, max, abs, round } = Math;\n\nexport const getScrollbarHandleLengthRatio = (\n  scrollbarHandle: HTMLElement,\n  scrollbarTrack: HTMLElement,\n  isHorizontal?: boolean,\n  structureSetupState?: StructureSetupState\n) => {\n  if (structureSetupState) {\n    const axis = isHorizontal ? 'x' : 'y';\n    const { _overflowAmount, _overflowEdge } = structureSetupState;\n\n    const viewportSize = _overflowEdge[axis];\n    const overflowAmount = _overflowAmount[axis];\n    return max(0, min(1, viewportSize / (viewportSize + overflowAmount)));\n  }\n  const axis = isHorizontal ? 'w' : 'h';\n  const handleSize = offsetSize(scrollbarHandle)[axis];\n  const trackSize = offsetSize(scrollbarTrack)[axis];\n  return max(0, min(1, handleSize / trackSize));\n};\n\nexport const getScrollbarHandleOffsetRatio = (\n  scrollbarHandle: HTMLElement,\n  scrollbarTrack: HTMLElement,\n  scrollOffsetElement: HTMLElement,\n  structureSetupState: StructureSetupState,\n  isRTL: boolean,\n  isHorizontal?: boolean\n) => {\n  const { _rtlScrollBehavior } = getEnvironment();\n  const axis = isHorizontal ? 'x' : 'y';\n  const scrollLeftTop = isHorizontal ? 'Left' : 'Top';\n  const { _overflowAmount } = structureSetupState;\n  const scrollPositionMax = round(_overflowAmount[axis]);\n  const scrollPosition = abs(scrollOffsetElement[`scroll${scrollLeftTop}`]);\n  const handleRTL = isHorizontal && isRTL;\n  const rtlNormalizedScrollPosition = _rtlScrollBehavior.i\n    ? scrollPosition\n    : scrollPositionMax - scrollPosition;\n  const finalScrollPosition = handleRTL ? rtlNormalizedScrollPosition : scrollPosition;\n  const scrollPercent = min(1, finalScrollPosition / scrollPositionMax);\n  const lengthRatio = getScrollbarHandleLengthRatio(scrollbarHandle, scrollbarTrack, isHorizontal);\n\n  return (1 / lengthRatio) * (1 - lengthRatio) * scrollPercent;\n};\n","import {\r\n  addClass,\r\n  appendChildren,\r\n  createDiv,\r\n  directionIsRTL,\r\n  each,\r\n  isBoolean,\r\n  isEmptyArray,\r\n  push,\r\n  removeClass,\r\n  removeElements,\r\n  runEachAndClear,\r\n  setT,\r\n  style,\r\n} from '~/support';\r\nimport {\r\n  classNameScrollbar,\r\n  classNameScrollbarHorizontal,\r\n  classNameScrollbarVertical,\r\n  classNameScrollbarTrack,\r\n  classNameScrollbarHandle,\r\n  classNameScrollbarTransitionless,\r\n} from '~/classnames';\r\nimport { getEnvironment } from '~/environment';\r\nimport { dynamicInitializationElement as generalDynamicInitializationElement } from '~/initialization';\r\nimport {\r\n  getScrollbarHandleLengthRatio,\r\n  getScrollbarHandleOffsetRatio,\r\n} from '~/setups/scrollbarsSetup/scrollbarsSetup.calculations';\r\nimport type {\r\n  InitializationTarget,\r\n  InitializationTargetElement,\r\n  InitializationTargetObject,\r\n} from '~/initialization';\r\nimport type { StructureSetupElementsObj } from '~/setups/structureSetup/structureSetup.elements';\r\nimport type { ScrollbarsSetupEvents } from '~/setups/scrollbarsSetup/scrollbarsSetup.events';\r\nimport type { StyleObject } from '~/typings';\r\nimport type { StructureSetupState } from '~/setups';\r\n\r\nexport interface ScrollbarStructure {\r\n  _scrollbar: HTMLElement;\r\n  _track: HTMLElement;\r\n  _handle: HTMLElement;\r\n}\r\n\r\nexport interface ScrollbarsSetupElement {\r\n  _scrollbarStructures: ScrollbarStructure[];\r\n  _clone: () => ScrollbarStructure;\r\n  _handleStyle: (\r\n    elmStyle: (\r\n      scrollbarStructure: ScrollbarStructure\r\n    ) => [HTMLElement | false | null | undefined, StyleObject]\r\n  ) => void;\r\n}\r\n\r\nexport interface ScrollbarsSetupElementsObj {\r\n  _scrollbarsAddRemoveClass: (\r\n    classNames: string | false | null | undefined,\r\n    add?: boolean,\r\n    isHorizontal?: boolean\r\n  ) => void;\r\n  _refreshScrollbarsHandleLength: (structureSetupState: StructureSetupState) => void;\r\n  _refreshScrollbarsHandleOffset: (structureSetupState: StructureSetupState) => void;\r\n  _horizontal: ScrollbarsSetupElement;\r\n  _vertical: ScrollbarsSetupElement;\r\n}\r\n\r\nexport type ScrollbarsSetupElements = [\r\n  elements: ScrollbarsSetupElementsObj,\r\n  appendElements: () => void,\r\n  destroy: () => void\r\n];\r\n\r\nexport const createScrollbarsSetupElements = (\r\n  target: InitializationTarget,\r\n  structureSetupElements: StructureSetupElementsObj,\r\n  scrollbarsSetupEvents: ScrollbarsSetupEvents\r\n): ScrollbarsSetupElements => {\r\n  const { _getDefaultInitialization } = getEnvironment();\r\n  const { scrollbars: defaultInitScrollbars } = _getDefaultInitialization();\r\n  const { slot: defaultInitScrollbarsSlot } = defaultInitScrollbars;\r\n  const {\r\n    _documentElm,\r\n    _target,\r\n    _host,\r\n    _viewport,\r\n    _targetIsElm,\r\n    _scrollOffsetElement,\r\n    _isBody,\r\n    _viewportIsTarget,\r\n  } = structureSetupElements;\r\n  const { scrollbars: scrollbarsInit } = (_targetIsElm ? {} : target) as InitializationTargetObject;\r\n  const { slot: initScrollbarsSlot } = scrollbarsInit || {};\r\n  const evaluatedScrollbarSlot = generalDynamicInitializationElement<\r\n    [InitializationTargetElement, HTMLElement, HTMLElement]\r\n  >(\r\n    [_target, _host, _viewport],\r\n    () => (_viewportIsTarget && _isBody ? _target : _host),\r\n    defaultInitScrollbarsSlot,\r\n    initScrollbarsSlot\r\n  );\r\n  const scrollbarStructureAddRemoveClass = (\r\n    scrollbarStructures: ScrollbarStructure[],\r\n    classNames: string | false | null | undefined,\r\n    add?: boolean\r\n  ) => {\r\n    const action = add ? addClass : removeClass;\r\n    each(scrollbarStructures, (scrollbarStructure) => {\r\n      action(scrollbarStructure._scrollbar, classNames);\r\n    });\r\n  };\r\n  const scrollbarsHandleStyle = (\r\n    scrollbarStructures: ScrollbarStructure[],\r\n    elmStyle: (\r\n      scrollbarStructure: ScrollbarStructure\r\n    ) => [HTMLElement | false | null | undefined, StyleObject]\r\n  ) => {\r\n    each(scrollbarStructures, (scrollbarStructure) => {\r\n      const [elm, styles] = elmStyle(scrollbarStructure);\r\n      style(elm, styles);\r\n    });\r\n  };\r\n  const scrollbarStructureRefreshHandleLength = (\r\n    scrollbarStructures: ScrollbarStructure[],\r\n    structureSetupState: StructureSetupState,\r\n    isHorizontal?: boolean\r\n  ) => {\r\n    scrollbarsHandleStyle(scrollbarStructures, (structure) => {\r\n      const { _handle, _track } = structure;\r\n      return [\r\n        _handle,\r\n        {\r\n          [isHorizontal ? 'width' : 'height']: `${(\r\n            getScrollbarHandleLengthRatio(_handle, _track, isHorizontal, structureSetupState) * 100\r\n          ).toFixed(3)}%`,\r\n        },\r\n      ];\r\n    });\r\n  };\r\n  const scrollbarStructureRefreshHandleOffset = (\r\n    scrollbarStructures: ScrollbarStructure[],\r\n    structureSetupState: StructureSetupState,\r\n    isHorizontal?: boolean\r\n  ) => {\r\n    const translateAxis = isHorizontal ? 'X' : 'Y';\r\n    scrollbarsHandleStyle(scrollbarStructures, (structure) => {\r\n      const { _handle, _track, _scrollbar } = structure;\r\n      const offsetRatio = getScrollbarHandleOffsetRatio(\r\n        _handle,\r\n        _track,\r\n        _scrollOffsetElement,\r\n        structureSetupState,\r\n        directionIsRTL(_scrollbar),\r\n        isHorizontal\r\n      );\r\n      // eslint-disable-next-line no-self-compare\r\n      const validOffsetRatio = offsetRatio === offsetRatio; // is false when offset is NaN\r\n      return [\r\n        _handle,\r\n        {\r\n          transform: validOffsetRatio\r\n            ? `translate${translateAxis}(${(offsetRatio * 100).toFixed(3)}%)`\r\n            : '',\r\n        },\r\n      ];\r\n    });\r\n  };\r\n\r\n  const destroyFns: (() => void)[] = [];\r\n  const horizontalScrollbars: ScrollbarStructure[] = [];\r\n  const verticalScrollbars: ScrollbarStructure[] = [];\r\n\r\n  const scrollbarsAddRemoveClass = (\r\n    className: string | false | null | undefined,\r\n    add?: boolean,\r\n    onlyHorizontal?: boolean\r\n  ) => {\r\n    const singleAxis = isBoolean(onlyHorizontal);\r\n    const runHorizontal = singleAxis ? onlyHorizontal : true;\r\n    const runVertical = singleAxis ? !onlyHorizontal : true;\r\n    runHorizontal && scrollbarStructureAddRemoveClass(horizontalScrollbars, className, add);\r\n    runVertical && scrollbarStructureAddRemoveClass(verticalScrollbars, className, add);\r\n  };\r\n  const refreshScrollbarsHandleLength = (structureSetupState: StructureSetupState) => {\r\n    scrollbarStructureRefreshHandleLength(horizontalScrollbars, structureSetupState, true);\r\n    scrollbarStructureRefreshHandleLength(verticalScrollbars, structureSetupState);\r\n  };\r\n  const refreshScrollbarsHandleOffset = (structureSetupState: StructureSetupState) => {\r\n    scrollbarStructureRefreshHandleOffset(horizontalScrollbars, structureSetupState, true);\r\n    scrollbarStructureRefreshHandleOffset(verticalScrollbars, structureSetupState);\r\n  };\r\n  const generateScrollbarDOM = (isHorizontal?: boolean): ScrollbarStructure => {\r\n    const scrollbarClassName = isHorizontal\r\n      ? classNameScrollbarHorizontal\r\n      : classNameScrollbarVertical;\r\n    const arrToPush = isHorizontal ? horizontalScrollbars : verticalScrollbars;\r\n    const transitionlessClass = isEmptyArray(arrToPush) ? classNameScrollbarTransitionless : '';\r\n    const scrollbar = createDiv(\r\n      `${classNameScrollbar} ${scrollbarClassName} ${transitionlessClass}`\r\n    );\r\n    const track = createDiv(classNameScrollbarTrack);\r\n    const handle = createDiv(classNameScrollbarHandle);\r\n    const result = {\r\n      _scrollbar: scrollbar,\r\n      _track: track,\r\n      _handle: handle,\r\n    };\r\n\r\n    appendChildren(scrollbar, track);\r\n    appendChildren(track, handle);\r\n\r\n    push(arrToPush, result);\r\n    push(destroyFns, [\r\n      removeElements.bind(0, scrollbar),\r\n      scrollbarsSetupEvents(\r\n        result,\r\n        scrollbarsAddRemoveClass,\r\n        _documentElm,\r\n        _host,\r\n        _scrollOffsetElement,\r\n        isHorizontal\r\n      ),\r\n    ]);\r\n\r\n    return result;\r\n  };\r\n  const generateHorizontalScrollbarStructure = generateScrollbarDOM.bind(0, true);\r\n  const generateVerticalScrollbarStructure = generateScrollbarDOM.bind(0, false);\r\n  const appendElements = () => {\r\n    appendChildren(evaluatedScrollbarSlot, horizontalScrollbars[0]._scrollbar);\r\n    appendChildren(evaluatedScrollbarSlot, verticalScrollbars[0]._scrollbar);\r\n\r\n    setT(() => {\r\n      scrollbarsAddRemoveClass(classNameScrollbarTransitionless);\r\n    }, 300);\r\n  };\r\n\r\n  generateHorizontalScrollbarStructure();\r\n  generateVerticalScrollbarStructure();\r\n\r\n  return [\r\n    {\r\n      _refreshScrollbarsHandleLength: refreshScrollbarsHandleLength,\r\n      _refreshScrollbarsHandleOffset: refreshScrollbarsHandleOffset,\r\n      _scrollbarsAddRemoveClass: scrollbarsAddRemoveClass,\r\n      _horizontal: {\r\n        _scrollbarStructures: horizontalScrollbars,\r\n        _clone: generateHorizontalScrollbarStructure,\r\n        _handleStyle: scrollbarsHandleStyle.bind(0, horizontalScrollbars),\r\n      },\r\n      _vertical: {\r\n        _scrollbarStructures: verticalScrollbars,\r\n        _clone: generateVerticalScrollbarStructure,\r\n        _handleStyle: scrollbarsHandleStyle.bind(0, verticalScrollbars),\r\n      },\r\n    },\r\n    appendElements,\r\n    runEachAndClear.bind(0, destroyFns),\r\n  ];\r\n};\r\n","import { on, runEachAndClear, parent, scrollLeft, scrollTop, selfClearTimeout } from '~/support';\r\nimport { getEnvironment } from '~/environment';\r\nimport { createState, createOptionCheck } from '~/setups/setups';\r\nimport { createScrollbarsSetupEvents } from '~/setups/scrollbarsSetup/scrollbarsSetup.events';\r\nimport { createScrollbarsSetupElements } from '~/setups/scrollbarsSetup/scrollbarsSetup.elements';\r\nimport {\r\n  classNameScrollbarThemeNone,\r\n  classNameScrollbarVisible,\r\n  classNameScrollbarUnusable,\r\n  classNameScrollbarCornerless,\r\n  classNameScrollbarAutoHidden,\r\n  classNameScrollbarHandleInteractive,\r\n  classNameScrollbarTrackInteractive,\r\n  classNameScrollbarRtl,\r\n} from '~/classnames';\r\nimport type {\r\n  ScrollbarsSetupElementsObj,\r\n  ScrollbarStructure,\r\n} from '~/setups/scrollbarsSetup/scrollbarsSetup.elements';\r\nimport type { StructureSetupUpdateHints } from '~/setups/structureSetup/structureSetup.update';\r\nimport type {\r\n  ReadonlyOptions,\r\n  ScrollbarsVisibilityBehavior,\r\n  ScrollbarsAutoHideBehavior,\r\n} from '~/options';\r\nimport type { Setup, StructureSetupState, StructureSetupStaticState } from '~/setups';\r\nimport type { InitializationTarget } from '~/initialization';\r\nimport type { DeepPartial, OverflowStyle, StyleObject } from '~/typings';\r\n\r\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\r\nexport interface ScrollbarsSetupState {}\r\n\r\nexport interface ScrollbarsSetupStaticState {\r\n  _elements: ScrollbarsSetupElementsObj;\r\n  _appendElements: () => void;\r\n}\r\n\r\nexport const createScrollbarsSetup = (\r\n  target: InitializationTarget,\r\n  options: ReadonlyOptions,\r\n  structureSetupState: (() => StructureSetupState) & StructureSetupStaticState,\r\n  onScroll: (event: Event) => void\r\n): Setup<\r\n  ScrollbarsSetupState,\r\n  ScrollbarsSetupStaticState,\r\n  [DeepPartial<StructureSetupUpdateHints>]\r\n> => {\r\n  let autoHideIsMove: boolean;\r\n  let autoHideIsLeave: boolean;\r\n  let autoHideNotNever: boolean;\r\n  let mouseInHost: boolean | undefined;\r\n  let prevTheme: string | null | undefined;\r\n  let globalAutoHideDelay = 0;\r\n\r\n  const state = createState({});\r\n  const [getState] = state;\r\n  const [requestMouseMoveAnimationFrame, cancelMouseMoveAnimationFrame] = selfClearTimeout();\r\n  const [requestScrollAnimationFrame, cancelScrollAnimationFrame] = selfClearTimeout();\r\n  const [scrollTimeout, clearScrollTimeout] = selfClearTimeout(100);\r\n  const [auotHideMoveTimeout, clearAutoHideTimeout] = selfClearTimeout(100);\r\n  const [auotHideTimeout, clearAutoTimeout] = selfClearTimeout(() => globalAutoHideDelay);\r\n  const [elements, appendElements, destroyElements] = createScrollbarsSetupElements(\r\n    target,\r\n    structureSetupState._elements,\r\n    createScrollbarsSetupEvents(options, structureSetupState)\r\n  );\r\n  const {\r\n    _host,\r\n    _viewport,\r\n    _scrollOffsetElement,\r\n    _scrollEventElement,\r\n    _viewportIsTarget,\r\n    _isBody,\r\n  } = structureSetupState._elements;\r\n  const {\r\n    _horizontal,\r\n    _vertical,\r\n    _scrollbarsAddRemoveClass,\r\n    _refreshScrollbarsHandleLength,\r\n    _refreshScrollbarsHandleOffset,\r\n  } = elements;\r\n  const { _handleStyle: styleHorizontal } = _horizontal;\r\n  const { _handleStyle: styleVertical } = _vertical;\r\n  const styleScrollbarPosition = (structure: ScrollbarStructure) => {\r\n    const { _scrollbar } = structure;\r\n    const elm = _viewportIsTarget && !_isBody && parent(_scrollbar) === _viewport && _scrollbar;\r\n    return [\r\n      elm,\r\n      {\r\n        transform: elm\r\n          ? `translate(${scrollLeft(_scrollOffsetElement)}px, ${scrollTop(_scrollOffsetElement)}px)`\r\n          : '',\r\n      },\r\n    ] as [HTMLElement | false, StyleObject];\r\n  };\r\n  const manageScrollbarsAutoHide = (removeAutoHide: boolean, delayless?: boolean) => {\r\n    clearAutoTimeout();\r\n    if (removeAutoHide) {\r\n      _scrollbarsAddRemoveClass(classNameScrollbarAutoHidden);\r\n    } else {\r\n      const hide = () => _scrollbarsAddRemoveClass(classNameScrollbarAutoHidden, true);\r\n      if (globalAutoHideDelay > 0 && !delayless) {\r\n        auotHideTimeout(hide);\r\n      } else {\r\n        hide();\r\n      }\r\n    }\r\n  };\r\n  const onHostMouseEnter = () => {\r\n    mouseInHost = autoHideIsLeave;\r\n    mouseInHost && manageScrollbarsAutoHide(true);\r\n  };\r\n\r\n  const destroyFns: (() => void)[] = [\r\n    clearScrollTimeout,\r\n    clearAutoTimeout,\r\n    clearAutoHideTimeout,\r\n    cancelScrollAnimationFrame,\r\n    cancelMouseMoveAnimationFrame,\r\n    destroyElements,\r\n\r\n    on(_host, 'pointerover', onHostMouseEnter, { _once: true }),\r\n    on(_host, 'pointerenter', onHostMouseEnter),\r\n    on(_host, 'pointerleave', () => {\r\n      mouseInHost = false;\r\n      autoHideIsLeave && manageScrollbarsAutoHide(false);\r\n    }),\r\n    on(_host, 'pointermove', () => {\r\n      autoHideIsMove &&\r\n        requestMouseMoveAnimationFrame(() => {\r\n          clearScrollTimeout();\r\n          manageScrollbarsAutoHide(true);\r\n          auotHideMoveTimeout(() => {\r\n            autoHideIsMove && manageScrollbarsAutoHide(false);\r\n          });\r\n        });\r\n    }),\r\n    on(_scrollEventElement, 'scroll', (event) => {\r\n      requestScrollAnimationFrame(() => {\r\n        _refreshScrollbarsHandleOffset(structureSetupState());\r\n\r\n        autoHideNotNever && manageScrollbarsAutoHide(true);\r\n        scrollTimeout(() => {\r\n          autoHideNotNever && !mouseInHost && manageScrollbarsAutoHide(false);\r\n        });\r\n      });\r\n\r\n      onScroll(event);\r\n\r\n      _viewportIsTarget && styleHorizontal(styleScrollbarPosition);\r\n      _viewportIsTarget && styleVertical(styleScrollbarPosition);\r\n    }),\r\n  ];\r\n  const scrollbarsSetupState = getState.bind(0) as (() => ScrollbarsSetupState) &\r\n    ScrollbarsSetupStaticState;\r\n  scrollbarsSetupState._elements = elements;\r\n  scrollbarsSetupState._appendElements = appendElements;\r\n\r\n  return [\r\n    (changedOptions, force, structureUpdateHints) => {\r\n      const {\r\n        _overflowEdgeChanged,\r\n        _overflowAmountChanged,\r\n        _overflowStyleChanged,\r\n        _directionChanged,\r\n      } = structureUpdateHints;\r\n      const { _nativeScrollbarsOverlaid } = getEnvironment();\r\n      const checkOption = createOptionCheck(options, changedOptions, force);\r\n      const currStructureSetupState = structureSetupState();\r\n      const { _overflowAmount, _overflowStyle, _directionIsRTL } = currStructureSetupState;\r\n      const [showNativeOverlaidScrollbarsOption, showNativeOverlaidScrollbarsChanged] =\r\n        checkOption<boolean>('showNativeOverlaidScrollbars');\r\n      const [theme, themeChanged] = checkOption<string | null>('scrollbars.theme');\r\n      const [visibility, visibilityChanged] =\r\n        checkOption<ScrollbarsVisibilityBehavior>('scrollbars.visibility');\r\n      const [autoHide, autoHideChanged] =\r\n        checkOption<ScrollbarsAutoHideBehavior>('scrollbars.autoHide');\r\n      const [autoHideDelay] = checkOption<number>('scrollbars.autoHideDelay');\r\n      const [dragScroll, dragScrollChanged] = checkOption<boolean>('scrollbars.dragScroll');\r\n      const [clickScroll, clickScrollChanged] = checkOption<boolean>('scrollbars.clickScroll');\r\n\r\n      const updateHandle = _overflowEdgeChanged || _overflowAmountChanged || _directionChanged;\r\n      const updateVisibility = _overflowStyleChanged || visibilityChanged;\r\n      const showNativeOverlaidScrollbars =\r\n        showNativeOverlaidScrollbarsOption &&\r\n        _nativeScrollbarsOverlaid.x &&\r\n        _nativeScrollbarsOverlaid.y;\r\n\r\n      const setScrollbarVisibility = (overflowStyle: OverflowStyle, isHorizontal: boolean) => {\r\n        const isVisible =\r\n          visibility === 'visible' || (visibility === 'auto' && overflowStyle === 'scroll');\r\n        _scrollbarsAddRemoveClass(classNameScrollbarVisible, isVisible, isHorizontal);\r\n        return isVisible;\r\n      };\r\n\r\n      globalAutoHideDelay = autoHideDelay;\r\n\r\n      if (showNativeOverlaidScrollbarsChanged) {\r\n        _scrollbarsAddRemoveClass(classNameScrollbarThemeNone, showNativeOverlaidScrollbars);\r\n      }\r\n      if (themeChanged) {\r\n        _scrollbarsAddRemoveClass(prevTheme);\r\n        _scrollbarsAddRemoveClass(theme, true);\r\n\r\n        prevTheme = theme;\r\n      }\r\n      if (autoHideChanged) {\r\n        autoHideIsMove = autoHide === 'move';\r\n        autoHideIsLeave = autoHide === 'leave';\r\n        autoHideNotNever = autoHide !== 'never';\r\n        manageScrollbarsAutoHide(!autoHideNotNever, true);\r\n      }\r\n      if (dragScrollChanged) {\r\n        _scrollbarsAddRemoveClass(classNameScrollbarHandleInteractive, dragScroll);\r\n      }\r\n      if (clickScrollChanged) {\r\n        _scrollbarsAddRemoveClass(classNameScrollbarTrackInteractive, clickScroll);\r\n      }\r\n      if (updateVisibility) {\r\n        const xVisible = setScrollbarVisibility(_overflowStyle.x, true);\r\n        const yVisible = setScrollbarVisibility(_overflowStyle.y, false);\r\n        const hasCorner = xVisible && yVisible;\r\n\r\n        _scrollbarsAddRemoveClass(classNameScrollbarCornerless, !hasCorner);\r\n      }\r\n      if (updateHandle) {\r\n        _refreshScrollbarsHandleLength(currStructureSetupState);\r\n        _refreshScrollbarsHandleOffset(currStructureSetupState);\r\n\r\n        _scrollbarsAddRemoveClass(classNameScrollbarUnusable, !_overflowAmount.x, true);\r\n        _scrollbarsAddRemoveClass(classNameScrollbarUnusable, !_overflowAmount.y, false);\r\n        _scrollbarsAddRemoveClass(classNameScrollbarRtl, _directionIsRTL && !_isBody);\r\n      }\r\n    },\r\n    scrollbarsSetupState,\r\n    runEachAndClear.bind(0, destroyFns),\r\n  ];\r\n};\r\n","import {\r\n  assignDeep,\r\n  isEmptyObject,\r\n  each,\r\n  isFunction,\r\n  keys,\r\n  isHTMLElement,\r\n  createEventListenerHub,\r\n  isPlainObject,\r\n} from '~/support';\r\nimport { getOptionsDiff } from '~/options';\r\nimport { getEnvironment } from '~/environment';\r\nimport { cancelInitialization } from '~/initialization';\r\nimport { addInstance, getInstance, removeInstance } from '~/instances';\r\nimport { createStructureSetup, createScrollbarsSetup } from '~/setups';\r\nimport { getPlugins, addPlugin, optionsValidationPluginName } from '~/plugins';\r\nimport type { Environment } from '~/environment';\r\nimport type { XY, TRBL } from '~/support';\r\nimport type { Options, PartialOptions, ReadonlyOptions } from '~/options';\r\nimport type { Plugin, OptionsValidationPluginInstance, PluginInstance } from '~/plugins';\r\nimport type { InitializationTarget } from '~/initialization';\r\nimport type { OverflowStyle } from '~/typings';\r\nimport type { EventListenerArgs, EventListener, EventListeners } from '~/eventListeners';\r\nimport type {\r\n  ScrollbarsSetupElement,\r\n  ScrollbarStructure,\r\n} from '~/setups/scrollbarsSetup/scrollbarsSetup.elements';\r\n\r\n// Notes:\r\n// Height intrinsic detection use \"content: true\" init strategy - or open ticket for custom height intrinsic observer\r\n\r\n/**\r\n * The primary entry point to OverlayScrollbars.\r\n */\r\nexport interface OverlayScrollbarsStatic {\r\n  /**\r\n   * Returns the current OverlayScrollbars instance if the target already has an instance.\r\n   * @param target The initialization target to from which the instance shall be returned.\r\n   */\r\n  (target: InitializationTarget): OverlayScrollbars | undefined;\r\n  /**\r\n   * Initializes a new OverlayScrollbars instance to the given target\r\n   * or returns the current OverlayScrollbars instance if the target already has an instance.\r\n   * @param target The target.\r\n   * @param options The options. (Can be just an empty object)\r\n   * @param eventListeners Optional event listeners.\r\n   */\r\n  (\r\n    target: InitializationTarget,\r\n    options: PartialOptions,\r\n    eventListeners?: EventListeners\r\n  ): OverlayScrollbars;\r\n\r\n  /**\r\n   * Adds one or multiple plugins.\r\n   * @param plugin Either a signle or an array of plugins to add.\r\n   */\r\n  plugin(plugin: Plugin | Plugin[]): void;\r\n  /**\r\n   * Checks whether the passed value is a valid and not destroyed overlayscrollbars instance.\r\n   * @param osInstance The value which shall be checked.\r\n   */\r\n  valid(osInstance: any): osInstance is OverlayScrollbars;\r\n  /**\r\n   * Returns the overlayscrollbars environment.\r\n   */\r\n  env(): Environment;\r\n}\r\n\r\n/**\r\n * Describes a OverlayScrollbars instances state.\r\n */\r\nexport interface State {\r\n  /** Describes the current padding in pixel. */\r\n  padding: TRBL;\r\n  /** Whether the current padding is absolute. */\r\n  paddingAbsolute: boolean;\r\n  /** The client width (x) & height (y) of the viewport in pixel. */\r\n  overflowEdge: XY<number>;\r\n  /** The overflow amount in pixel. */\r\n  overflowAmount: XY<number>;\r\n  /** The css overflow style of the viewport. */\r\n  overflowStyle: XY<OverflowStyle>;\r\n  /** Whether the viewport has an overflow. */\r\n  hasOverflow: XY<boolean>;\r\n  /** Whether the direction is considered rtl. */\r\n  directionRTL: boolean;\r\n  /** Whether the instance is considered destroyed. */\r\n  destroyed: boolean;\r\n}\r\n\r\n/**\r\n * Describes the elements of a scrollbar.\r\n */\r\nexport interface ScrollbarElements {\r\n  /**\r\n   * The root element of the scrollbar.\r\n   * The HTML structure looks like this:\r\n   * <scrollbar>\r\n   *   <track>\r\n   *     <handle />\r\n   *   </track>\r\n   * </scrollbar>\r\n   */\r\n  scrollbar: HTMLElement;\r\n  /** The track element of the scrollbar. */\r\n  track: HTMLElement;\r\n  /** The handle element of the scrollbar. */\r\n  handle: HTMLElement;\r\n}\r\n\r\n/**\r\n * Describes the elements of a scrollbar and provides the possibility to clone them.\r\n */\r\nexport interface CloneableScrollbarElements extends ScrollbarElements {\r\n  /**\r\n   * Clones the current scrollbar and returns the cloned elements.\r\n   * The returned elements aren't added to the DOM.\r\n   */\r\n  clone(): ScrollbarElements;\r\n}\r\n\r\n/**\r\n * Describes the elements of a OverlayScrollbars instance.\r\n */\r\nexport interface Elements {\r\n  /** The element the instance was applied to. */\r\n  target: HTMLElement;\r\n  /** The host element. Its the root of all other elements. */\r\n  host: HTMLElement;\r\n  /**\r\n   * The element which is responsible to apply correct paddings.\r\n   * Depending on the Initialization it can be the same as the viewport element.\r\n   */\r\n  padding: HTMLElement;\r\n  /** The element which is responsible to do any scrolling. */\r\n  viewport: HTMLElement;\r\n  /**\r\n   * The element which is responsible to hold the content.\r\n   * Depending on the Initialization it can be the same as the viewport element.\r\n   */\r\n  content: HTMLElement;\r\n  /**\r\n   * The element through which you can get the current `scrollLeft` or `scrollTop` offset.\r\n   * Depending on the target element it can be the same as the viewport element.\r\n   */\r\n  scrollOffsetElement: HTMLElement;\r\n  /**\r\n   * The element through which you can add `scroll` events.\r\n   * Depending on the target element it can be the same as the viewport element.\r\n   */\r\n  scrollEventElement: HTMLElement | Document;\r\n  /** The horizontal scrollbar elements. */\r\n  scrollbarHorizontal: CloneableScrollbarElements;\r\n  /** The vertical scrollbar elements. */\r\n  scrollbarVertical: CloneableScrollbarElements;\r\n}\r\n\r\n/**\r\n * Describes a OverlayScrollbars instance.\r\n */\r\nexport interface OverlayScrollbars {\r\n  /** Get the current options of the instance. */\r\n  options(): Options;\r\n  /**\r\n   * Sets the options of the instance.\r\n   * If the new options are partially filled, they're deeply merged with either the current options or the current default options.\r\n   * @param newOptions The new options.\r\n   * @param pure If true the new options will be merged with the current default options instead of the current options.\r\n   * @returns Returns the current options of the instance.\r\n   */\r\n  options(newOptions: PartialOptions, pure?: boolean): Options;\r\n\r\n  /**\r\n   * Adds event listeners to the instance.\r\n   * @param eventListeners An object which contains the added listeners.\r\n   * @param pure If true all already added event listeners will be removed before the new listeners are added.\r\n   * @returns Returns a function which removes the added listeners.\r\n   */\r\n  on(eventListeners: EventListeners, pure?: boolean): () => void;\r\n  /**\r\n   * Adds an event listener to the instance.\r\n   * @param name The name of the event.\r\n   * @param listener The listener which is invoked on that event.\r\n   * @returns Returns a function which removes the added listeners.\r\n   */\r\n  on<N extends keyof EventListenerArgs>(name: N, listener: EventListener<N>): () => void;\r\n  /**\r\n   * Adds multiple event listeners to the instance.\r\n   * @param name The name of the event.\r\n   * @param listener The listeners which are invoked on that event.\r\n   * @returns Returns a function which removes the added listeners.\r\n   */\r\n  on<N extends keyof EventListenerArgs>(name: N, listener: EventListener<N>[]): () => void;\r\n\r\n  /**\r\n   * Removes an event listener from the instance.\r\n   * @param name The name of the event.\r\n   * @param listener The listener which shall be removed.\r\n   */\r\n  off<N extends keyof EventListenerArgs>(name: N, listener: EventListener<N>): void;\r\n  /**\r\n   * Removes multiple event listeners from the instance.\r\n   * @param name The name of the event.\r\n   * @param listener The listeners which shall be removed.\r\n   */\r\n  off<N extends keyof EventListenerArgs>(name: N, listener: EventListener<N>[]): void;\r\n\r\n  /**\r\n   * Updates the instance.\r\n   * @param force Whether the update should force the cache to be invalidated.\r\n   * @returns A boolean which indicates whether the `update` event was triggered through this update.\r\n   * The update event is only triggered if something changed because of this update.\r\n   */\r\n  update(force?: boolean): boolean;\r\n  /** Returns the state of the instance. */\r\n  state(): State;\r\n  /** Returns the elements of the instance. */\r\n  elements(): Elements;\r\n  /** Destroys the instance. */\r\n  destroy(): void;\r\n}\r\n\r\nconst invokePluginInstance = (\r\n  pluginInstance: PluginInstance,\r\n  staticObj?: OverlayScrollbarsStatic | false | null | undefined | 0,\r\n  instanceObj?: OverlayScrollbars | false | null | undefined | 0\r\n) => {\r\n  if (isFunction(pluginInstance)) {\r\n    pluginInstance(staticObj || undefined, instanceObj || undefined);\r\n  }\r\n};\r\n\r\n// eslint-disable-next-line @typescript-eslint/no-redeclare\r\nexport const OverlayScrollbars: OverlayScrollbarsStatic = (\r\n  target: InitializationTarget,\r\n  options?: PartialOptions,\r\n  eventListeners?: EventListeners\r\n) => {\r\n  const { _getDefaultOptions, _getDefaultInitialization, _addZoomListener, _addResizeListener } =\r\n    getEnvironment();\r\n  const plugins = getPlugins();\r\n  const targetIsElement = isHTMLElement(target);\r\n  const instanceTarget = targetIsElement ? target : target.target;\r\n  const potentialInstance = getInstance(instanceTarget);\r\n  if (options && !potentialInstance) {\r\n    let destroyed = false;\r\n    const validateOptions = (newOptions: PartialOptions) => {\r\n      const optionsValidationPlugin = getPlugins()[\r\n        optionsValidationPluginName\r\n      ] as OptionsValidationPluginInstance;\r\n      const validate = optionsValidationPlugin && optionsValidationPlugin._;\r\n      return validate ? validate(newOptions, true) : newOptions;\r\n    };\r\n    const currentOptions: ReadonlyOptions = assignDeep(\r\n      {},\r\n      _getDefaultOptions(),\r\n      validateOptions(options)\r\n    );\r\n    const [addEvent, removeEvent, triggerEvent] = createEventListenerHub(eventListeners);\r\n    const [updateStructure, structureState, destroyStructure] = createStructureSetup(\r\n      target,\r\n      currentOptions\r\n    );\r\n    const [updateScrollbars, scrollbarsState, destroyScrollbars] = createScrollbarsSetup(\r\n      target,\r\n      currentOptions,\r\n      structureState,\r\n      // eslint-disable-next-line @typescript-eslint/no-use-before-define\r\n      (scrollEvent) => triggerEvent('scroll', [instance, scrollEvent])\r\n    );\r\n    const update = (changedOptions: PartialOptions, force?: boolean): boolean =>\r\n      updateStructure(changedOptions, !!force);\r\n    const forceUpdate = update.bind(0, {}, true);\r\n    const removeZoomListener = _addZoomListener(forceUpdate);\r\n    const removeResizeListener = _addResizeListener(forceUpdate);\r\n    const destroy = (canceled?: boolean) => {\r\n      removeInstance(instanceTarget);\r\n      removeZoomListener();\r\n      removeResizeListener();\r\n\r\n      destroyScrollbars();\r\n      destroyStructure();\r\n\r\n      destroyed = true;\r\n\r\n      // eslint-disable-next-line @typescript-eslint/no-use-before-define\r\n      triggerEvent('destroyed', [instance, !!canceled]);\r\n      removeEvent();\r\n    };\r\n\r\n    const instance: OverlayScrollbars = {\r\n      options(newOptions?: PartialOptions, pure?: boolean) {\r\n        if (newOptions) {\r\n          const base = pure ? _getDefaultOptions() : {};\r\n          const changedOptions = getOptionsDiff(\r\n            currentOptions,\r\n            assignDeep(base, validateOptions(newOptions))\r\n          );\r\n          if (!isEmptyObject(changedOptions)) {\r\n            assignDeep(currentOptions, changedOptions);\r\n            update(changedOptions);\r\n          }\r\n        }\r\n        return assignDeep({}, currentOptions);\r\n      },\r\n      on: addEvent,\r\n      off: (name, listener) => {\r\n        name && listener && removeEvent(name, listener as any);\r\n      },\r\n      state() {\r\n        const {\r\n          _overflowEdge,\r\n          _overflowAmount,\r\n          _overflowStyle,\r\n          _hasOverflow,\r\n          _padding,\r\n          _paddingAbsolute,\r\n          _directionIsRTL,\r\n        } = structureState();\r\n        return assignDeep(\r\n          {},\r\n          {\r\n            overflowEdge: _overflowEdge,\r\n            overflowAmount: _overflowAmount,\r\n            overflowStyle: _overflowStyle,\r\n            hasOverflow: _hasOverflow,\r\n            padding: _padding,\r\n            paddingAbsolute: _paddingAbsolute,\r\n            directionRTL: _directionIsRTL,\r\n            destroyed,\r\n          }\r\n        );\r\n      },\r\n      elements() {\r\n        const {\r\n          _target,\r\n          _host,\r\n          _padding,\r\n          _viewport,\r\n          _content,\r\n          _scrollOffsetElement,\r\n          _scrollEventElement,\r\n        } = structureState._elements;\r\n        const { _horizontal, _vertical } = scrollbarsState._elements;\r\n        const translateScrollbarStructure = (\r\n          scrollbarStructure: ScrollbarStructure\r\n        ): ScrollbarElements => {\r\n          const { _handle, _track, _scrollbar } = scrollbarStructure;\r\n          return {\r\n            scrollbar: _scrollbar,\r\n            track: _track,\r\n            handle: _handle,\r\n          };\r\n        };\r\n        const translateScrollbarsSetupElement = (\r\n          scrollbarsSetupElement: ScrollbarsSetupElement\r\n        ): CloneableScrollbarElements => {\r\n          const { _scrollbarStructures, _clone } = scrollbarsSetupElement;\r\n          const translatedStructure = translateScrollbarStructure(_scrollbarStructures[0]);\r\n\r\n          return assignDeep({}, translatedStructure, {\r\n            clone: () => {\r\n              const result = translateScrollbarStructure(_clone());\r\n              updateScrollbars({}, true, {});\r\n              return result;\r\n            },\r\n          });\r\n        };\r\n        return assignDeep(\r\n          {},\r\n          {\r\n            target: _target,\r\n            host: _host,\r\n            padding: _padding || _viewport,\r\n            viewport: _viewport,\r\n            content: _content || _viewport,\r\n            scrollOffsetElement: _scrollOffsetElement,\r\n            scrollEventElement: _scrollEventElement,\r\n            scrollbarHorizontal: translateScrollbarsSetupElement(_horizontal),\r\n            scrollbarVertical: translateScrollbarsSetupElement(_vertical),\r\n          }\r\n        );\r\n      },\r\n      update: (force?: boolean) => update({}, force),\r\n      destroy: destroy.bind(0),\r\n    };\r\n\r\n    structureState._addOnUpdatedListener((updateHints, changedOptions, force: boolean) => {\r\n      updateScrollbars(changedOptions, force, updateHints);\r\n    });\r\n\r\n    // valid inside plugins\r\n    addInstance(instanceTarget, instance);\r\n\r\n    // init plugins\r\n    each(keys(plugins), (pluginName) => invokePluginInstance(plugins[pluginName], 0, instance));\r\n\r\n    if (\r\n      cancelInitialization(\r\n        structureState._elements._isBody,\r\n        _getDefaultInitialization().cancel,\r\n        !targetIsElement && target.cancel\r\n      )\r\n    ) {\r\n      destroy(true);\r\n      return instance;\r\n    }\r\n\r\n    structureState._appendElements();\r\n    scrollbarsState._appendElements();\r\n\r\n    triggerEvent('initialized', [instance]);\r\n\r\n    structureState._addOnUpdatedListener((updateHints, changedOptions, force) => {\r\n      const {\r\n        _sizeChanged,\r\n        _directionChanged,\r\n        _heightIntrinsicChanged,\r\n        _overflowEdgeChanged,\r\n        _overflowAmountChanged,\r\n        _overflowStyleChanged,\r\n        _contentMutation,\r\n        _hostMutation,\r\n      } = updateHints;\r\n\r\n      triggerEvent('updated', [\r\n        instance,\r\n        {\r\n          updateHints: {\r\n            sizeChanged: _sizeChanged,\r\n            directionChanged: _directionChanged,\r\n            heightIntrinsicChanged: _heightIntrinsicChanged,\r\n            overflowEdgeChanged: _overflowEdgeChanged,\r\n            overflowAmountChanged: _overflowAmountChanged,\r\n            overflowStyleChanged: _overflowStyleChanged,\r\n            contentMutation: _contentMutation,\r\n            hostMutation: _hostMutation,\r\n          },\r\n          changedOptions,\r\n          force,\r\n        },\r\n      ]);\r\n    });\r\n\r\n    instance.update(true);\r\n\r\n    return instance;\r\n  }\r\n  return potentialInstance!;\r\n};\r\n\r\nOverlayScrollbars.plugin = (plugins: Plugin | Plugin[]) => {\r\n  each(addPlugin(plugins), (pluginInstance) =>\r\n    invokePluginInstance(pluginInstance, OverlayScrollbars)\r\n  );\r\n};\r\nOverlayScrollbars.valid = (osInstance: any): osInstance is OverlayScrollbars => {\r\n  const hasElmsFn = osInstance && (osInstance as OverlayScrollbars).elements;\r\n  const elements = isFunction(hasElmsFn) && hasElmsFn();\r\n  return isPlainObject(elements) && !!getInstance(elements.target);\r\n};\r\nOverlayScrollbars.env = () => {\r\n  const {\r\n    _nativeScrollbarsSize,\r\n    _nativeScrollbarsOverlaid,\r\n    _nativeScrollbarsHiding,\r\n    _rtlScrollBehavior,\r\n    _flexboxGlue,\r\n    _cssCustomProperties,\r\n    _staticDefaultInitialization,\r\n    _staticDefaultOptions,\r\n    _getDefaultInitialization,\r\n    _setDefaultInitialization,\r\n    _getDefaultOptions,\r\n    _setDefaultOptions,\r\n  } = getEnvironment();\r\n  return assignDeep(\r\n    {},\r\n    {\r\n      scrollbarsSize: _nativeScrollbarsSize,\r\n      scrollbarsOverlaid: _nativeScrollbarsOverlaid,\r\n      scrollbarsHiding: _nativeScrollbarsHiding,\r\n      rtlScrollBehavior: _rtlScrollBehavior,\r\n      flexboxGlue: _flexboxGlue,\r\n      cssCustomProperties: _cssCustomProperties,\r\n      staticDefaultInitialization: _staticDefaultInitialization,\r\n      staticDefaultOptions: _staticDefaultOptions,\r\n\r\n      getDefaultInitialization: _getDefaultInitialization,\r\n      setDefaultInitialization: _setDefaultInitialization,\r\n      getDefaultOptions: _getDefaultOptions,\r\n      setDefaultOptions: _setDefaultOptions,\r\n    }\r\n  );\r\n};\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}